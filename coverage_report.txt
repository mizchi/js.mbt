[mizchi/js] test promise_test.mbt:514 ("Promise: @js.Promise::any returns first fulfilled promise (2)") failed
expect test failed at /Users/mizchi/mizchi/js.mbt/src/promise_test.mbt:527:3-527:33
Diff: (- expected, + actual)
----
-200
+100
----

Total tests: 1483, passed: 1482, failed: 1.
Total: 2278 uncovered line(s) in 138 file(s)

3 uncovered line(s) in src/any.mbt:

    | pub fn[T] Nullish::to_option(self : Nullish[T]) -> T? {
100 |   let js_value : Any = self |> identity
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   if ffi_is_nullish(js_value) {
102 |     None
    |     ^^^^ 	<-- UNCOVERED
    |   } else {
104 |     Some(self |> identity)
    |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

6 uncovered line(s) in src/async.mbt:

    | pub fn[R] promisify0(f : async () -> R) -> () -> Promise[R] noraise {
    |   () => {
    |     let { promise, resolve, reject } = Promise::withResolvers()
    |     run_async(async fn() noraise {
    |       try f() |> resolve catch {
 44 |         e => reject(e)
    |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     })
    |     promise
    |   }
    | }
    …

    | pub fn[A, R] promisify1(f : async (A) -> R) -> (A) -> Promise[R] noraise {
    |   a => {
    |     let { promise, resolve, reject } = Promise::withResolvers()
    |     run_async(async fn() noraise {
    |       try f(a) |> resolve catch {
 58 |         e => reject(e)
    |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     })
    |     promise
    |   }
    | }
    …

    | pub fn[A, B, R] promisify2(
    |   f : async (A, B) -> R,
    | ) -> (A, B) -> Promise[R] noraise {
    |   (a, b) => {
    |     let { promise, resolve, reject } = Promise::withResolvers()
    |     run_async(async fn() noraise {
    |       try f(a, b) |> resolve catch {
 74 |         e => reject(e)
    |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     })
    |     promise
    |   }
    | }
    …

    | pub fn[A, B, C, R] promisify3(
    |   f : async (A, B, C) -> R,
    | ) -> (A, B, C) -> Promise[R] noraise {
    |   (a, b, c) => {
    |     let { promise, resolve, reject } = Promise::withResolvers()
    |     run_async(async fn() noraise {
    |       try f(a, b, c) |> resolve catch {
 90 |         e => reject(e)
    |         ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |     })
    |     promise
    |   }
    | }
    …

    | pub async fn sleep(ms : Int) -> Unit noraise {
    |   ffi_sleep(ms).wait() catch {
105 |     _ => panic()
    |     ^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub async fn[T] from_callback(f : ((T) -> Unit) -> Unit) -> T raise Error {
131 |   suspend(fn(resolve, _reject) { f(resolve) })
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

10 uncovered line(s) in src/browser/canvas/canvas.mbt:

    | pub fn CanvasRenderingContext2D::drawImage(
    |   self : Self,
    |   image : &@js.JsImpl,
    |   dx : Double,
    |   dy : Double,
    | ) -> Unit {
269 |   self.call("drawImage", [image.to_any(), dx, dy]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::drawImageScaled(
    |   self : Self,
    |   image : &@js.JsImpl,
    |   dx : Double,
    |   dy : Double,
    |   d_width : Double,
    |   d_height : Double,
    | ) -> Unit {
281 |   self.call("drawImage", [image.to_any(), dx, dy, d_width, d_height])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   |> ignore
    | }
    …

    | pub fn CanvasRenderingContext2D::drawImageSub(
    |   self : Self,
    |   image : &@js.JsImpl,
    |   sx : Double,
    |   sy : Double,
    |   s_width : Double,
    |   s_height : Double,
    |   dx : Double,
    |   dy : Double,
    |   d_width : Double,
    |   d_height : Double,
    | ) -> Unit {
298 |   self
    |   ^^^^ 	<-- UNCOVERED
    |   .to_any()
    |   .call("drawImage", [
    |     image.to_any(),
    |     sx,
    |     sy,
    |     s_width,
    |     s_height,
    |     dx,
    |     dy,
    |     d_width,
    |     d_height,
    |   ])
311 |   |> ignore
    |   ^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ImageData::new(width : Int, height : Int) -> ImageData {
390 |   @js.identity(ffi_new_image_data(width |> @js.any, height |> @js.any))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ImageData::from_data(
    |   data : @typedarray.Uint8Array,
    |   width : Int,
    |   height : Int,
    | ) -> ImageData {
399 |   @js.identity(
    |   ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ffi_new_image_data_with_data(
    |       data.to_any(),
    |       width |> @js.any,
    |       height |> @js.any,
    |     ),
    |   )
    | }
    …

    | pub impl @worker.Transferable for ImageBitmap with to_transferable(self) -> @js.Any {
420 |   self.to_any()
    |   ^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ImageBitmap::close(self : Self) -> Unit {
425 |   self.call0("close") |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(create_image_bitmap)
    | pub fn createImageBitmap(image : &@js.JsImpl) -> ImageBitmap {
446 |   @js.identity(ffi_create_image_bitmap(image.to_any()))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(create_image_bitmap_rect)
    | pub fn createImageBitmapRect(
    |   image : &@js.JsImpl,
    |   sx : Int,
    |   sy : Int,
    |   sw : Int,
    |   sh : Int,
    | ) -> @js.Promise[ImageBitmap] {
458 |   @js.identity(
    |   ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ffi_create_image_bitmap_with_rect(
    |       image.to_any(),
    |       sx |> @js.any,
    |       sy |> @js.any,
    |       sw |> @js.any,
    |       sh |> @js.any,
    |     ),
    |   )
    | }
    …

9 uncovered line(s) in src/browser/canvas/offscreen_canvas.mbt:

   | pub impl @worker.Transferable for OffscreenCanvas with to_transferable(self) -> @js.Any {
11 |   self.to_any()
   |   ^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn OffscreenCanvas::new(width : Int, height : Int) -> OffscreenCanvas {
23 |   @js.identity(ffi_new_offscreen_canvas(width |> @js.any, height |> @js.any))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn OffscreenCanvas::width(self : Self) -> Int {
28 |   self.get("width").cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn OffscreenCanvas::setWidth(self : Self, value : Int) -> Unit {
33 |   self.set("width", value)
   |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn OffscreenCanvas::height(self : Self) -> Int {
38 |   self.get("height").cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn OffscreenCanvas::setHeight(self : Self, value : Int) -> Unit {
43 |   self.set("height", value)
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn OffscreenCanvas::getContext(
   |   self : Self,
   |   context_type : String,
   | ) -> CanvasRenderingContext2D {
51 |   self.call("getContext", [context_type]).cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn OffscreenCanvas::convertToBlob(
   |   self : Self,
   |   options? : String,
   | ) -> @js.Promise[@blob.Blob] {
59 |   match options {
   |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     Some(opts) => self.call("convertToBlob", [opts]).cast()
   |     None => self.call0("convertToBlob").cast()
   |   }
   | }
   …

   | pub fn OffscreenCanvas::transferToImageBitmap(self : Self) -> ImageBitmap {
67 |   self.call0("transferToImageBitmap").cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

32 uncovered line(s) in src/browser/dom/css.mbt:

    | pub fn css_style_from_val(val : @js.Any) -> CSSStyleDeclaration {
 20 |   @js.identity(val)
    |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleDeclaration::get_property_value(
    |   self : Self,
    |   property : String,
    | ) -> String {
 29 |   self.call("getPropertyValue", [property]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleDeclaration::set_property(
    |   self : Self,
    |   property : String,
    |   value : String,
    | ) -> Unit {
 39 |   self.call2("setProperty", property, value).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleDeclaration::set_property_priority(
    |   self : Self,
    |   property : String,
    |   value : String,
    |   priority : String,
    | ) -> Unit {
 50 |   self.call("setProperty", [property, value, priority]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleDeclaration::remove_property(
    |   self : Self,
    |   property : String,
    | ) -> String {
 59 |   self.call("removeProperty", [property]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleDeclaration::get_property_priority(
    |   self : Self,
    |   property : String,
    | ) -> String {
 68 |   self.call("getPropertyPriority", [property]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSRule::css_text(self : Self) -> String {
 83 |   self.get("cssText").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSRule::set_css_text(self : Self, text : String) -> Unit {
 89 |   self.set("cssText", text) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSRule::parent_rule(self : Self) -> CSSRule? {
 95 |   self.get("parentRule") |> @js.identity_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSRule::parent_stylesheet(self : Self) -> CSSStyleSheet? {
101 |   self.get("parentStyleSheet") |> @js.identity_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSRule::rule_type(self : Self) -> Int {
107 |   self.get("type").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleSheet::cssRules(self : Self) -> @js.Any {
123 |   self.get("cssRules")
    |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleSheet::insertRule(self : Self, rule : String) -> Int {
130 |   self.call("insertRule", [rule]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleSheet::insertRuleAt(
    |   self : Self,
    |   rule : String,
    |   index : Int,
    | ) -> Int {
140 |   self.call2("insertRule", rule, index).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleSheet::deleteRule(self : Self, index : Int) -> Unit {
147 |   self.call("deleteRule", [index]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleSheet::ownerNode(self : Self) -> @js.Any? {
153 |   self.get("ownerNode") |> @js.identity_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleSheet::disabled(self : Self) -> Bool {
159 |   self.get("disabled").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleSheet::set_disabled(self : Self, disabled : Bool) -> Unit {
165 |   self.set("disabled", disabled) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleSheet::href(self : Self) -> String? {
171 |   self.get("href") |> @js.identity_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleSheet::title(self : Self) -> String? {
177 |   self.get("title") |> @js.identity_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleSheet::media(self : Self) -> @js.Any {
183 |   self.get("media")
    |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(match_media)
    | pub fn matchMedia(query : String) -> MediaQueryList {
202 |   @js.identity(@js.global_this().call("matchMedia", [query]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MediaQueryList::addListener(
    |   self : Self,
    |   listener : (MediaQueryList) -> Unit,
    | ) -> Unit {
212 |   self.call("addListener", [listener |> @js.from_fn1]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MediaQueryList::removeListener(
    |   self : Self,
    |   listener : (MediaQueryList) -> Unit,
    | ) -> Unit {
222 |   self.call("removeListener", [listener |> @js.from_fn1]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MediaQueryList::addChangeListener(
    |   self : Self,
    |   listener : (Event) -> Unit,
    | ) -> Unit {
231 |   self.call2("addEventListener", "change", listener |> @js.from_fn1) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MediaQueryList::removeChangeListener(
    |   self : Self,
    |   listener : (Event) -> Unit,
    | ) -> Unit {
240 |   self.call2("removeEventListener", "change", listener |> @js.from_fn1)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   |> ignore
    | }
    …

    | #alias(css_escape)
    | pub fn cssEscape(value : String) -> String {
252 |   let css_obj = @js.global_this().get("CSS")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @js.identity(css_obj.call("escape", [value]))
    | }
    …

    | #alias(css_supports)
    | pub fn cssSupports(property : String, value : String) -> Bool {
261 |   let css_obj = @js.global_this().get("CSS")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   css_obj.call2("supports", property, value).cast()
    | }
    …

    | #alias(css_supports_condition)
    | pub fn cssSupportsCondition(condition : String) -> Bool {
269 |   let css_obj = @js.global_this().get("CSS")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @js.identity(css_obj.call("supports", [condition]))
    | }
    …

    | pub fn Document::styleSheets(self : Self) -> @js.Any {
277 |   self.get("styleSheets")
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Document::createStylesheet(self : Self) -> CSSStyleSheet {
283 |   let style = self.create_element("style")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match self.head() {
    |     Some(head) => head.call("appendChild", [style]) |> ignore
    |     None => ()
    |   }
288 |   style.get("sheet").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

9 uncovered line(s) in src/browser/dom/custom_elements.mbt:

    | #alias(custom_elements)
    | pub fn customElements() -> CustomElementRegistry {
 19 |   @js.identity(@js.global_this().get("customElements"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CustomElementRegistry::define_(
    |   self : Self,
    |   name : String,
    |   callbacks : CustomElementCallbacks,
    | ) -> Unit {
 62 |   let element_class = create_custom_element_class(callbacks)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   self.call2("define", name, element_class) |> ignore
    | }
    …

    | pub fn CustomElementRegistry::define_element_with_attributes(
    |   self : Self,
    |   name : String,
    |   callbacks : CustomElementCallbacks,
    |   observed_attributes : Array[String],
    | ) -> Unit {
101 |   let element_class = create_custom_element_class_with_attributes(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     callbacks, observed_attributes,
    |   )
104 |   self.call2("define", name, element_class) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CustomElementRegistry::get(self : Self, name : String) -> @js.Any? {
111 |   self.call("get", [name]) |> @js.identity_option
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CustomElementRegistry::getName(
    |   self : Self,
    |   element_constructor : @js.Any,
    | ) -> String? {
121 |   self.call("getName", [element_constructor]) |> @js.identity_option
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CustomElementRegistry::whenDefined(
    |   self : Self,
    |   name : String,
    | ) -> @js.Promise[Unit] {
131 |   self.call("whenDefined", [name]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CustomElementRegistry::upgrade(self : Self, root : Node) -> Unit {
138 |   ignore(self.call("upgrade", [root.to_any()]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CustomElementCallbacks::new(
    |   onConnected? : () -> Unit = fn() { () },
    |   onDisconnected? : () -> Unit = fn() { () },
    |   onAdopted? : () -> Unit = fn() { () },
    |   onAttributeChanged? : (String, String?, String?, String?) -> Unit = fn(
    |     _,
    |     _,
    |     _,
    |     _,
    |   ) {
    |     ()
    |   },
    | ) -> CustomElementCallbacks {
156 |   { onConnected, onDisconnected, onAdopted, onAttributeChanged }
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

5 uncovered line(s) in src/browser/dom/data_transfer.mbt:

   | pub fn DataTransfer::get_files(self : Self) -> Array[@js.Any] {
18 |   @js.array_from(self.files).map(fn(v) { v })
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn DataTransfer::get_types(self : Self) -> Array[String] {
24 |   @js.array_from(self.types).map(fn(v) { @js.identity(v) })
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn DataTransfer::getData(self : Self, format : String) -> String {
30 |   self.call("getData", [format]).cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn DataTransfer::setData(
   |   self : Self,
   |   format : String,
   |   data : String,
   | ) -> Unit {
40 |   ignore(self.call2("setData", format, data))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn DataTransfer::clearData(self : Self, format : String) -> Unit {
46 |   ignore(self.call("clearData", [format]))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

12 uncovered line(s) in src/browser/dom/document.mbt:

    | #alias(get_elements_by_class_name)
    | pub fn Document::getElementsByClassName(
    |   self : Self,
    |   class_name : String,
    | ) -> Array[Element] {
 85 |   @js.array_from(self.call("getElementsByClassName", [class_name])).map(fn(v) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     v |> @js.identity
    |   })
    | }
    …

    | #alias(get_elements_by_tag_name)
    | pub fn Document::getElementsByTagName(
    |   self : Self,
    |   tagName : String,
    | ) -> Array[Element] {
100 |   @js.array_from(self.call("getElementsByTagName", [tagName])).map(_.cast())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(set_body)
    | pub fn Document::setBody(self : Self, body : HTMLBodyElement) -> Unit {
125 |   self.set("body", body) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Document::url(self : Self) -> String {
153 |   self.get("URL").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Document::domain(self : Self) -> String {
160 |   self.get("domain").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Document::referrer(self : Self) -> String {
167 |   self.get("referrer").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(document_uri)
    | pub fn Document::documentURI(self : Self) -> String {
199 |   self.get("documentURI").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Document::doctype(self : Self) -> @js.Any? {
222 |   self.get("doctype") |> @js.identity_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(adopt_node)
    | pub fn Document::adoptNode(self : Self, node : Node) -> Node {
230 |   self.call("adoptNode", [node.to_any()]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(import_node)
    | pub fn Document::importNode(self : Self, node : Node, deep : Bool) -> Node {
238 |   self.call2("importNode", node.to_any(), deep) |> @js.identity
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Document::elementFromPoint(
    |   self : Self,
    |   x : Double,
    |   y : Double,
    | ) -> Element? {
257 |   self.call2("elementFromPoint", x, y) |> @js.identity_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Document::elementsFromPoint(
    |   self : Self,
    |   x : Double,
    |   y : Double,
    | ) -> Array[Element] {
270 |   @js.array_from(self.call2("elementsFromPoint", x, y)).map(fn(v) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     @js.identity(v)
    |   })
    | }
    …

1 uncovered line(s) in src/browser/dom/element.mbt:

    | impl ElementImpl with removeAttribute(self, name) -> Unit {
 78 |   ignore(self.call("removeAttribute", [name]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

13 uncovered line(s) in src/browser/dom/event_impl.mbt:

    | impl EventImpl with preventDefault(self) -> Unit {
 17 |   ignore(self.call0("preventDefault"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | impl EventImpl with stopPropagation(self) -> Unit {
 22 |   ignore(self.call0("stopPropagation"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | impl EventImpl with stopImmediatePropagation(self) -> Unit {
 27 |   ignore(self.call0("stopImmediatePropagation"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | impl EventImpl with target(self) -> Element {
 32 |   self.get("target").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | impl EventImpl with currentTarget(self) -> Element {
 37 |   self.get("currentTarget").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | impl EventImpl with eventType(self) -> String {
 42 |   self.get("type").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | impl EventImpl with bubbles(self) -> Bool {
 47 |   self.get("bubbles").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | impl EventImpl with cancelable(self) -> Bool {
 52 |   self.get("cancelable").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | impl EventImpl with defaultPrevented(self) -> Bool {
 57 |   self.get("defaultPrevented").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MouseEvent::relatedTarget(self : Self) -> Element? {
128 |   self.get("relatedTarget") |> @js.identity_option
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn FocusEvent::relatedTarget(self : FocusEvent) -> Element? {
179 |   self.get("relatedTarget") |> @js.identity_option
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Touch::target(self : Self) -> Element {
281 |   self.get("target").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MessageEvent::source(self : Self) -> Window? {
357 |   self.get("source") |> @js.identity_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

3 uncovered line(s) in src/browser/dom/html_element.mbt:

   | impl HTMLElementImpl with setOuterHTML(self, html) -> Unit {
66 |   self.set("outerHTML", html)
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | impl HTMLElementImpl with focus(self) -> Unit {
71 |   ignore(self.call0("focus"))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | impl HTMLElementImpl with click(self) -> Unit {
76 |   ignore(self.call0("click"))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

5 uncovered line(s) in src/browser/dom/html_elements.mbt:

    | pub fn HTMLCanvasElement::toDataURL(
    |   self : Self,
    |   image_type? : String,
    |   quality? : Double,
    | ) -> String {
 58 |   match (image_type, quality) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(t), Some(q)) => self.call2("toDataURL", t, q).cast()
    |     (Some(t), None) => self.call("toDataURL", [t]).cast()
    |     (None, _) => self.call0("toDataURL").cast()
    |   }
    | }
    …

    | pub fn HTMLCanvasElement::toBlob(
    |   self : Self,
    |   image_type? : String,
    |   quality? : Double,
    | ) -> @js.Promise[@blob.Blob] {
 71 |   match (image_type, quality) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(t), Some(q)) => self.call2("toBlob", t, q).cast()
    |     (Some(t), None) => self.call("toBlob", [t]).cast()
    |     (None, _) => self.call0("toBlob").cast()
    |   }
    | }
    …

    | pub fn HTMLInputElement::type_(self : Self) -> String {
226 |   self.get("type").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLIFrameElement::contentWindow(self : Self) -> Window? {
292 |   self.get("contentWindow").cast() |> @js.identity_option
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLIFrameElement::contentDocument(self : Self) -> Document? {
299 |   self.get("contentDocument").cast() |> @js.identity_option
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

3 uncovered line(s) in src/browser/dom/node.mbt:

    | impl NodeImpl with previousSibling(self) -> Node? {
 70 |   @js.identity_option(self.get("previousSibling"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | impl NodeImpl with nextSibling(self) -> Node? {
 75 |   @js.identity_option(self.get("nextSibling"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | impl NodeImpl with insertBefore(self, new_node, ref_node) -> Node {
    |   match ref_node {
    |     Some(node) =>
    |       @js.identity(self.call2("insertBefore", new_node.to_any(), node.to_any()))
    |     None =>
 94 |       @js.identity(self.call2("insertBefore", new_node.to_any(), @js.null_()))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

4 uncovered line(s) in src/browser/dom/request_animation_frame.mbt:

   | pub async fn requestAnimationFrame(f : () -> Unit raise) -> Unit noraise {
13 |   @js.suspend(fn(ok, _err) {
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     ffi_request_animation_frame(() => {
   |       f() catch {
   |         _ => ()
   |       }
18 |       ok(())
   |       ^^^^^^ 	<-- UNCOVERED
   |     })
   |   }) catch {
21 |     _ => ()
   |     ^^^^^^^ 	<-- UNCOVERED
   |   }
   | }
   …

   | pub async fn wait_animation_frame() -> Unit noraise {
27 |   @js.suspend((ok, _) => ffi_request_animation_frame(() => ok(()))) catch {
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     _ => ()
   |   }
   | }
   …

13 uncovered line(s) in src/browser/dom/shadow_dom.mbt:

    | pub fn ShadowRoot::mode(self : Self) -> String {
 24 |   self.get("mode").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ShadowRoot::host(self : Self) -> Element {
 31 |   self.get("host").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ShadowRoot::delegatesFocus(self : Self) -> Bool {
 38 |   self.get("delegatesFocus").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ShadowRoot::slotAssignment(self : Self) -> String {
 45 |   self.get("slotAssignment").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ShadowRoot::innerHTML(self : Self) -> String {
 52 |   self.get("innerHTML").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ShadowRoot::setInnerHTML(self : Self, html : String) -> Unit {
 58 |   self.set("innerHTML", html)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ShadowRoot::activeElement(self : Self) -> Element? {
 65 |   self.get("activeElement") |> @js.identity_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ShadowRoot::elementFromPoint(
    |   self : Self,
    |   x : Double,
    |   y : Double,
    | ) -> Element? {
 76 |   self.call2("elementFromPoint", x, y) |> @js.identity_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ShadowRoot::elementsFromPoint(
    |   self : Self,
    |   x : Double,
    |   y : Double,
    | ) -> Array[Element] {
 89 |   @js.array_from(self.call2("elementsFromPoint", x, y)).map(_.cast())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ShadowRootInit::new(
    |   mode : String,
    |   delegatesFocus? : Bool = false,
    |   slotAssignment? : String = "named",
    | ) -> ShadowRootInit {
107 |   { mode, delegatesFocus, slotAssignment }
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLElement::attachShadow(
    |   self : Self,
    |   init : ShadowRootInit,
    | ) -> ShadowRoot {
117 |   let options = @js.from_map({
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     "mode": @js.any(init.mode),
    |     "delegatesFocus": @js.any(init.delegatesFocus),
    |     "slotAssignment": @js.any(init.slotAssignment),
    |   })
122 |   self.call("attachShadow", [options]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLElement::shadowRoot(self : Self) -> ShadowRoot? {
129 |   self.get("shadowRoot") |> @js.identity_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

37 uncovered line(s) in src/browser/dom/svg_elements.mbt:

    | pub fn SVGElement::setAttribute(
    |   self : Self,
    |   name : String,
    |   value : String,
    | ) -> Unit {
 17 |   ignore(self.call2("setAttribute", name, value))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGElement::getAttribute(self : Self, name : String) -> String? {
 23 |   self.call("getAttribute", [name]) |> @js.identity_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGSVGElement::width(self : Self) -> Double {
 38 |   self.get("width").get("baseVal").get("value").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGSVGElement::height(self : Self) -> Double {
 44 |   self.get("height").get("baseVal").get("value").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGSVGElement::setAttribute(
    |   self : Self,
    |   name : String,
    |   value : String,
    | ) -> Unit {
 54 |   ignore(self.call2("setAttribute", name, value))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGSVGElement::getAttribute(self : Self, name : String) -> String? {
 60 |   self.call("getAttribute", [name]) |> @js.identity_option
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGCircleElement::cx(self : Self) -> Double {
 83 |   self.get("cx").get("baseVal").get("value").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGCircleElement::cy(self : Self) -> Double {
 89 |   self.get("cy").get("baseVal").get("value").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGCircleElement::r(self : Self) -> Double {
 95 |   self.get("r").get("baseVal").get("value").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGRectElement::x(self : Self) -> Double {
128 |   self.get("x").get("baseVal").get("value").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGRectElement::y(self : Self) -> Double {
134 |   self.get("y").get("baseVal").get("value").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGRectElement::width(self : Self) -> Double {
140 |   self.get("width").get("baseVal").get("value").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGRectElement::height(self : Self) -> Double {
146 |   self.get("height").get("baseVal").get("value").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGEllipseElement::cx(self : Self) -> Double {
179 |   self.get("cx").get("baseVal").get("value").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGEllipseElement::cy(self : Self) -> Double {
185 |   self.get("cy").get("baseVal").get("value").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGEllipseElement::rx(self : Self) -> Double {
191 |   self.get("rx").get("baseVal").get("value").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGEllipseElement::ry(self : Self) -> Double {
197 |   self.get("ry").get("baseVal").get("value").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGEllipseElement::setAttribute(
    |   self : Self,
    |   name : String,
    |   value : String,
    | ) -> Unit {
207 |   ignore(self.call2("setAttribute", name, value))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGLineElement::x1(self : Self) -> Double {
230 |   self.get("x1").get("baseVal").get("value").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGLineElement::y1(self : Self) -> Double {
236 |   self.get("y1").get("baseVal").get("value").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGLineElement::x2(self : Self) -> Double {
242 |   self.get("x2").get("baseVal").get("value").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGLineElement::y2(self : Self) -> Double {
248 |   self.get("y2").get("baseVal").get("value").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGLineElement::setAttribute(
    |   self : Self,
    |   name : String,
    |   value : String,
    | ) -> Unit {
258 |   ignore(self.call2("setAttribute", name, value))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGPolygonElement::setAttribute(
    |   self : Self,
    |   name : String,
    |   value : String,
    | ) -> Unit {
285 |   ignore(self.call2("setAttribute", name, value))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGPolylineElement::setAttribute(
    |   self : Self,
    |   name : String,
    |   value : String,
    | ) -> Unit {
312 |   ignore(self.call2("setAttribute", name, value))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGPathElement::d(self : Self) -> String {
335 |   self.get("d").cast()
    |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGPathElement::getTotalLength(self : Self) -> Double {
342 |   self.call0("getTotalLength").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGTextElement::x(self : Self) -> Double {
375 |   self.get("x").get("baseVal").get(0).get("value").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGTextElement::y(self : Self) -> Double {
381 |   self.get("y").get("baseVal").get(0).get("value").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGTextElement::setAttribute(
    |   self : Self,
    |   name : String,
    |   value : String,
    | ) -> Unit {
391 |   ignore(self.call2("setAttribute", name, value))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGImageElement::x(self : Self) -> Double {
414 |   self.get("x").get("baseVal").get("value").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGImageElement::y(self : Self) -> Double {
420 |   self.get("y").get("baseVal").get("value").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGImageElement::width(self : Self) -> Double {
426 |   self.get("width").get("baseVal").get("value").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGImageElement::height(self : Self) -> Double {
432 |   self.get("height").get("baseVal").get("value").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGImageElement::href(self : Self) -> String {
438 |   self.get("href").get("baseVal").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGImageElement::setAttribute(
    |   self : Self,
    |   name : String,
    |   value : String,
    | ) -> Unit {
448 |   ignore(self.call2("setAttribute", name, value))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SVGGElement::setAttribute(
    |   self : Self,
    |   name : String,
    |   value : String,
    | ) -> Unit {
475 |   ignore(self.call2("setAttribute", name, value))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

36 uncovered line(s) in src/browser/dom/window.mbt:

    | pub fn Window::document(self : Self) -> Document {
 22 |   self.get("document").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Window::navigator(self : Self) -> @js.Any {
 31 |   self.get("navigator")
    |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Window::location(self : Self) -> @js.Any {
 40 |   self.get("location")
    |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(local_storage)
    | pub fn Window::localStorage(self : Self) -> @js.Any {
 48 |   self.get("localStorage").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(session_storage)
    | pub fn Window::sessionStorage(self : Self) -> @js.Any {
 56 |   self.get("sessionStorage").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Window::console(self : Self) -> @js.Any {
 63 |   self.get("console").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Window::history(self : Self) -> @js.Any {
 72 |   self.get("history")
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(inner_width)
    | pub fn Window::innerWidth(self : Self) -> Int {
 80 |   self.get("innerWidth").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(inner_height)
    | pub fn Window::innerHeight(self : Self) -> Int {
 88 |   self.get("innerHeight").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(outer_width)
    | pub fn Window::outerWidth(self : Self) -> Int {
 96 |   self.get("outerWidth").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(outer_height)
    | pub fn Window::outerHeight(self : Self) -> Int {
104 |   self.get("outerHeight").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Window::screen(self : Self) -> @js.Any {
111 |   self.get("screen").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(device_pixel_ratio)
    | pub fn Window::devicePixelRatio(self : Self) -> Double {
119 |   self.get("devicePixelRatio").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Window::alert(self : Self, message : String) -> Unit {
126 |   ignore(self.call("alert", [message]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Window::confirm(self : Self, message : String) -> Bool {
133 |   self.call("confirm", [message]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Window::prompt(
    |   self : Self,
    |   message : String,
    |   default? : String,
    | ) -> String? {
144 |   match default {
    |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(d) => self.call2("prompt", message, d) |> @js.identity_option()
    |     None => self.call("prompt", [message]) |> @js.identity_option()
    |   }
    | }
    …

    | pub fn Window::open(
    |   self : Self,
    |   url? : String,
    |   target? : String,
    |   features? : String,
    | ) -> Window? {
159 |   match (url, target, features) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(u), Some(t), Some(f)) =>
161 |       self.call("open", [u, t, f]) |> @js.identity_option
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(u), Some(t), None) => self.call2("open", u, t) |> @js.identity_option
    |     (Some(u), None, _) => self.call("open", [u]) |> @js.identity_option
    |     (None, _, _) => self.call0("open") |> @js.identity_option
    |   }
    | }
    …

    | pub fn Window::close(self : Self) -> Unit {
172 |   ignore(self.call0("close"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(scroll_to)
    | pub fn Window::scrollTo(self : Self, x : Int, y : Int) -> Unit {
180 |   ignore(self.call2("scrollTo", x, y))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(scroll_by)
    | pub fn Window::scrollBy(self : Self, x : Int, y : Int) -> Unit {
188 |   ignore(self.call2("scrollBy", x, y))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(scroll_x)
    | pub fn Window::scrollX(self : Self) -> Double {
196 |   self.get("scrollX").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(scroll_y)
    | pub fn Window::scrollY(self : Self) -> Double {
204 |   self.get("scrollY").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(set_timeout)
    | pub fn Window::setTimeout(
    |   self : Self,
    |   handler : () -> Unit,
    |   delay : Int,
    | ) -> Int {
216 |   self.call2("setTimeout", @js.from_fn0(handler), delay).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(clear_timeout)
    | pub fn Window::clearTimeout(self : Self, id : Int) -> Unit {
224 |   ignore(self.call("clearTimeout", [id]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(set_interval)
    | pub fn Window::setInterval(
    |   self : Self,
    |   handler : () -> Unit,
    |   delay : Int,
    | ) -> Int {
236 |   self.call2("setInterval", @js.from_fn0(handler), delay).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(clear_interval)
    | pub fn Window::clearInterval(self : Self, id : Int) -> Unit {
244 |   ignore(self.call("clearInterval", [id]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(request_animation_frame)
    | pub fn Window::requestAnimationFrame(
    |   self : Self,
    |   callback : (Double) -> Unit,
    | ) -> Int {
255 |   self.call("requestAnimationFrame", [@js.unsafe_any(callback)]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(cancel_animation_frame)
    | pub fn Window::cancelAnimationFrame(self : Self, id : Int) -> Unit {
263 |   ignore(self.call("cancelAnimationFrame", [id]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Window::fetch(
    |   self : Self,
    |   input : String,
    |   init? : @js.Any,
    | ) -> @js.Promise[@js.Any] {
274 |   match init {
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(i) => self.call2("fetch", input, i).cast()
    |     None => self.call("fetch", [input]).cast()
    |   }
    | }
    …

    | #alias(get_selection)
    | pub fn Window::getSelection(self : Self) -> @js.Any? {
285 |   self.call0("getSelection") |> @js.identity_option
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(get_computed_style)
    | pub fn Window::getComputedStyle(
    |   self : Self,
    |   element : Element,
    |   pseudo_elt? : String,
    | ) -> @js.Any {
297 |   match pseudo_elt {
    |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(p) => self.call2("getComputedStyle", element.to_any(), p).cast()
    |     None => self.call("getComputedStyle", [element.to_any()]).cast()
    |   }
    | }
    …

    | #alias(match_media)
    | pub fn Window::matchMedia(self : Self, query : String) -> @js.Any {
308 |   self.call("matchMedia", [query]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(post_message)
    | pub fn Window::postMessage(
    |   self : Self,
    |   message : @js.Any,
    |   target_origin : String,
    | ) -> Unit {
320 |   ignore(self.call2("postMessage", message, target_origin))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[T : @worker.Transferable] Window::post_message_with_transfer(
    |   self : Self,
    |   message : @js.Any,
    |   target_origin : String,
    |   transfer : Array[T],
    | ) -> Unit {
332 |   let transfer_vals = transfer.map(fn(t) { t.to_transferable() })
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ignore(
    |     self
335 |     .to_any()
    |     ^^^^^^^^^ 	<-- UNCOVERED
    |     .call("postMessage", [message, target_origin, @js.unsafe_any(transfer_vals)]),
    |   )
    | }
    …

10 uncovered line(s) in src/browser/file/file.mbt:

    | pub fn File::slice(self : Self, start? : Int, end? : Int) -> @blob.Blob {
    |   let js = self.to_any()
    |   match (start, end) {
 80 |     (None, None) => js.call0("slice").cast()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(s), None) => js.call("slice", [s]).cast()
    |     (Some(s), Some(e)) => js.call2("slice", s, e).cast()
 83 |     (None, Some(e)) => js.call2("slice", 0, e).cast()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub fn FileReader::new() -> FileReader {
108 |   ffi_new_file_reader() |> @js.identity
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(readAsArrayBuffer)
    | pub fn FileReader::read_as_array_buffer(self : Self, blob : @blob.Blob) -> Unit {
115 |   self.call("readAsArrayBuffer", [blob.to_any()]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(readAsText)
    | pub fn FileReader::read_as_text(
    |   self : Self,
    |   blob : @blob.Blob,
    |   encoding? : String,
    | ) -> Unit {
126 |   let js = self.to_any()
    |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match encoding {
    |     Some(enc) => js.call2("readAsText", blob, enc) |> ignore
    |     None => js.call("readAsText", [blob.to_any()]) |> ignore
    |   }
    | }
    …

    | #alias(readAsDataURL)
    | pub fn FileReader::read_as_data_url(self : Self, blob : @blob.Blob) -> Unit {
137 |   self.call("readAsDataURL", [blob.to_any()]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn FileReader::abort(self : Self) -> Unit {
143 |   self.call0("abort") |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn FileReader::set_onload(
    |   self : Self,
    |   callback : (@js.Any) -> Unit noraise,
    | ) -> Unit {
152 |   self.to_any().set("onload", callback |> @js.identity)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn FileReader::set_onerror(
    |   self : Self,
    |   callback : (@js.Any) -> Unit noraise,
    | ) -> Unit {
161 |   self.to_any().set("onerror", callback |> @js.identity)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn FileReader::set_onloadend(
    |   self : Self,
    |   callback : (@js.Any) -> Unit noraise,
    | ) -> Unit {
170 |   self.to_any().set("onloadend", callback |> @js.identity)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

5 uncovered line(s) in src/browser/history/history.mbt:

   | pub fn History::back(self : Self) -> Unit {
22 |   ignore(self.call0("back"))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn History::forward(self : Self) -> Unit {
29 |   ignore(self.call0("forward"))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn History::go(self : Self, delta? : Int) -> Unit {
36 |   match delta {
   |   ^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     Some(d) => ignore(self.call("go", [d]))
   |     None => ignore(self.call0("go"))
   |   }
   | }
   …

   | #alias(push_state)
   | pub fn History::pushState(
   |   self : Self,
   |   state : @js.Any,
   |   unused : String,
   |   url? : String,
   | ) -> Unit {
52 |   match url {
   |   ^^^^^^^^^^^ 	<-- UNCOVERED
   |     Some(u) => ignore(self.call("pushState", [state, unused, u]))
   |     None => ignore(self.call2("pushState", state, unused))
   |   }
   | }
   …

   | #alias(replace_state)
   | pub fn History::replaceState(
   |   self : Self,
   |   state : @js.Any,
   |   unused : String,
   |   url? : String,
   | ) -> Unit {
68 |   match url {
   |   ^^^^^^^^^^^ 	<-- UNCOVERED
   |     Some(u) => ignore(self.call("replaceState", [state, unused, u]))
   |     None => ignore(self.call2("replaceState", state, unused))
   |   }
   | }
   …

50 uncovered line(s) in src/browser/indexeddb/indexeddb.mbt:

    | pub fn[T] IDBRequest::is_pending(self : IDBRequest[T]) -> Bool {
 25 |   self.readyState == "pending"
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[T] IDBRequest::is_done(self : IDBRequest[T]) -> Bool {
 31 |   self.readyState == "done"
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[T] IDBRequest::source_as_object_store(
    |   self : IDBRequest[T],
    | ) -> IDBObjectStore[@js.Any] {
 39 |   self.source |> @js.identity
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[T] IDBRequest::source_as_index(
    |   self : IDBRequest[T],
    | ) -> IDBIndex[@js.Any] {
 47 |   self.source |> @js.identity
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[T, U] IDBRequest::source_as_cursor(self : IDBRequest[T]) -> IDBCursor[U] {
 53 |   self.source |> @js.identity
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn IDBDatabase::transaction(
    |   self : Self,
    |   store_names : Array[String],
    |   mode? : String,
    | ) -> IDBTransaction[@js.Any] {
 94 |   let mode_str = mode.unwrap_or("readonly")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   self.call2("transaction", @js.from_array(store_names), mode_str).cast()
    | }
    …

    | pub fn IDBDatabase::createObjectStore(
    |   self : Self,
    |   name : String,
    |   keyPath? : String,
    |   autoIncrement? : Bool,
    | ) -> IDBObjectStore[@js.Any] {
106 |   let options = @js.from_entries_option([
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ("keyPath", keyPath.map(fn(x) { x })),
    |     ("autoIncrement", autoIncrement.map(fn(x) { x })),
    |   ])
110 |   self.call2("createObjectStore", name, options).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn IDBDatabase::deleteObjectStore(self : Self, name : String) -> Unit {
116 |   self.call1("deleteObjectStore", name) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn IDBDatabase::close(self : Self) -> Unit {
122 |   self.call0("close") |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[T] IDBTransaction::objectStore(
    |   self : IDBTransaction[T],
    |   name : String,
    | ) -> IDBObjectStore[T] {
145 |   self.call1("objectStore", name).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[T] IDBTransaction::commit(self : IDBTransaction[T]) -> Unit {
151 |   self.call0("commit") |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[T] IDBTransaction::abort(self : IDBTransaction[T]) -> Unit {
157 |   self.call0("abort") |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[T] IDBObjectStore::add(
    |   self : IDBObjectStore[T],
    |   value : T,
    |   key? : &@js.JsImpl,
    | ) -> IDBRequest[@js.Any] {
183 |   let js_value : @js.Any = value |> @js.identity
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match key {
    |     Some(k) => self.call2("add", js_value, k.to_any()).cast()
    |     None => self.call1("add", js_value).cast()
    |   }
    | }
    …

    | pub fn[T] IDBObjectStore::put(
    |   self : IDBObjectStore[T],
    |   value : T,
    |   key? : &@js.JsImpl,
    | ) -> IDBRequest[@js.Any] {
197 |   let js_value : @js.Any = value |> @js.identity
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match key {
    |     Some(k) => self.call2("put", js_value, k.to_any()).cast()
    |     None => self.call1("put", js_value).cast()
    |   }
    | }
    …

    | pub fn[T] IDBObjectStore::get(
    |   self : IDBObjectStore[T],
    |   key : &@js.JsImpl,
    | ) -> IDBRequest[T] {
210 |   self.call1("get", key.to_any()).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[T] IDBObjectStore::delete(
    |   self : IDBObjectStore[T],
    |   key : &@js.JsImpl,
    | ) -> IDBRequest[@js.Any] {
219 |   self.call1("delete", key.to_any()).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[T] IDBObjectStore::clear(
    |   self : IDBObjectStore[T],
    | ) -> IDBRequest[@js.Any] {
227 |   self.call0("clear").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[T] IDBObjectStore::getAll(
    |   self : IDBObjectStore[T],
    |   query? : &@js.JsImpl,
    |   count? : Int,
    | ) -> IDBRequest[@js.Any] {
237 |   match (query, count) {
    |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(q), Some(c)) => self.call2("getAll", q.to_any(), c).cast()
    |     (Some(q), None) => self.call1("getAll", q.to_any()).cast()
    |     (None, Some(c)) => self.call2("getAll", @js.undefined(), c).cast()
    |     (None, None) => self.call0("getAll").cast()
    |   }
    | }
    …

    | pub fn[T] IDBObjectStore::getAllKeys(
    |   self : IDBObjectStore[T],
    |   query? : &@js.JsImpl,
    |   count? : Int,
    | ) -> IDBRequest[@js.Any] {
252 |   match (query, count) {
    |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(q), Some(c)) => self.call2("getAllKeys", q.to_any(), c).cast()
    |     (Some(q), None) => self.call1("getAllKeys", q.to_any()).cast()
    |     (None, Some(c)) => self.call2("getAllKeys", @js.undefined(), c).cast()
    |     (None, None) => self.call0("getAllKeys").cast()
    |   }
    | }
    …

    | pub fn[T] IDBObjectStore::count(
    |   self : IDBObjectStore[T],
    |   query? : &@js.JsImpl,
    | ) -> IDBRequest[@js.Any] {
266 |   match query {
    |   ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(q) => self.call1("count", q.to_any()).cast()
    |     None => self.call0("count").cast()
    |   }
    | }
    …

    | pub fn[T] IDBObjectStore::openCursor(
    |   self : IDBObjectStore[T],
    |   query? : &@js.JsImpl,
    |   direction? : String,
    | ) -> IDBRequest[@js.Any] {
279 |   match (query, direction) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(q), Some(d)) => self.call2("openCursor", q.to_any(), d).cast()
    |     (Some(q), None) => self.call1("openCursor", q.to_any()).cast()
    |     (None, Some(d)) => self.call2("openCursor", @js.undefined(), d).cast()
    |     (None, None) => self.call0("openCursor").cast()
    |   }
    | }
    …

    | pub fn[T] IDBObjectStore::openKeyCursor(
    |   self : IDBObjectStore[T],
    |   query? : &@js.JsImpl,
    |   direction? : String,
    | ) -> IDBRequest[@js.Any] {
294 |   match (query, direction) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(q), Some(d)) => self.call2("openKeyCursor", q.to_any(), d).cast()
    |     (Some(q), None) => self.call1("openKeyCursor", q.to_any()).cast()
    |     (None, Some(d)) => self.call2("openKeyCursor", @js.undefined(), d).cast()
    |     (None, None) => self.call0("openKeyCursor").cast()
    |   }
    | }
    …

    | pub fn[T] IDBObjectStore::createIndex(
    |   self : IDBObjectStore[T],
    |   name : String,
    |   keyPath : String,
    |   unique? : Bool,
    |   multiEntry? : Bool,
    | ) -> IDBIndex[T] {
311 |   let options = @js.from_entries_option([
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ("unique", unique.map(fn(x) { x })),
    |     ("multiEntry", multiEntry.map(fn(x) { x })),
    |   ])
315 |   self.call("createIndex", [name, keyPath, options]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[T] IDBObjectStore::deleteIndex(
    |   self : IDBObjectStore[T],
    |   name : String,
    | ) -> Unit {
324 |   self.call1("deleteIndex", name) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[T] IDBObjectStore::index(
    |   self : IDBObjectStore[T],
    |   name : String,
    | ) -> IDBIndex[T] {
333 |   self.call1("index", name).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[T] IDBIndex::get(self : IDBIndex[T], key : &@js.JsImpl) -> IDBRequest[T] {
355 |   self.call1("get", key.to_any()) |> @js.identity
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[T] IDBIndex::getAll(
    |   self : IDBIndex[T],
    |   query? : &@js.JsImpl,
    |   count? : Int,
    | ) -> IDBRequest[@js.Any] {
365 |   match (query, count) {
    |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(q), Some(c)) => self.call2("getAll", q.to_any(), c).cast()
    |     (Some(q), None) => self.call1("getAll", q.to_any()).cast()
    |     (None, Some(c)) => self.call2("getAll", @js.undefined(), c).cast()
    |     (None, None) => self.call0("getAll").cast()
    |   }
    | }
    …

    | pub fn[T] IDBIndex::getAllKeys(
    |   self : IDBIndex[T],
    |   query? : &@js.JsImpl,
    |   count? : Int,
    | ) -> IDBRequest[@js.Any] {
380 |   match (query, count) {
    |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(q), Some(c)) => self.call2("getAllKeys", q.to_any(), c).cast()
    |     (Some(q), None) => self.call1("getAllKeys", q.to_any()).cast()
    |     (None, Some(c)) => self.call2("getAllKeys", @js.undefined(), c).cast()
    |     (None, None) => self.call0("getAllKeys").cast()
    |   }
    | }
    …

    | pub fn[T] IDBIndex::count(
    |   self : IDBIndex[T],
    |   query? : &@js.JsImpl,
    | ) -> IDBRequest[@js.Any] {
394 |   match query {
    |   ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(q) => self.call1("count", q.to_any()).cast()
    |     None => self.call0("count").cast()
    |   }
    | }
    …

    | pub fn[T] IDBIndex::openCursor(
    |   self : IDBIndex[T],
    |   query? : &@js.JsImpl,
    |   direction? : String,
    | ) -> IDBRequest[@js.Any] {
407 |   match (query, direction) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(q), Some(d)) => self.call2("openCursor", q.to_any(), d).cast()
    |     (Some(q), None) => self.call1("openCursor", q.to_any()).cast()
    |     (None, Some(d)) => self.call2("openCursor", @js.undefined(), d).cast()
    |     (None, None) => self.call0("openCursor").cast()
    |   }
    | }
    …

    | pub fn[T] IDBIndex::openKeyCursor(
    |   self : IDBIndex[T],
    |   query? : &@js.JsImpl,
    |   direction? : String,
    | ) -> IDBRequest[@js.Any] {
422 |   match (query, direction) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(q), Some(d)) => self.call2("openKeyCursor", q.to_any(), d).cast()
    |     (Some(q), None) => self.call1("openKeyCursor", q.to_any()).cast()
    |     (None, Some(d)) => self.call2("openKeyCursor", @js.undefined(), d).cast()
    |     (None, None) => self.call0("openKeyCursor").cast()
    |   }
    | }
    …

    | pub fn[T] IDBCursor::continue_(self : IDBCursor[T], key? : &@js.JsImpl) -> Unit {
447 |   match key {
    |   ^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(k) => self.call1("continue", k.to_any()) |> ignore
    |     None => self.call0("continue") |> ignore
    |   }
    | }
    …

    | pub fn[T] IDBCursor::advance(self : IDBCursor[T], count : Int) -> Unit {
456 |   self.call1("advance", count) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[T] IDBCursor::update(
    |   self : IDBCursor[T],
    |   value : T,
    | ) -> IDBRequest[@js.Any] {
465 |   let js_value : @js.Any = value |> @js.identity
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   self.call1("update", js_value).cast()
    | }
    …

    | pub fn[T] IDBCursor::delete_current(self : IDBCursor[T]) -> IDBRequest[@js.Any] {
472 |   self.call0("delete").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[T] IDBCursorWithValue::continue_(
    |   self : IDBCursorWithValue[T],
    |   key? : &@js.JsImpl,
    | ) -> Unit {
497 |   match key {
    |   ^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(k) => self.call1("continue", k.to_any()) |> ignore
    |     None => self.call0("continue") |> ignore
    |   }
    | }
    …

    | pub fn[T] IDBCursorWithValue::advance(
    |   self : IDBCursorWithValue[T],
    |   count : Int,
    | ) -> Unit {
509 |   self.call1("advance", count) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[T] IDBCursorWithValue::update(
    |   self : IDBCursorWithValue[T],
    |   value : T,
    | ) -> IDBRequest[@js.Any] {
518 |   let js_value : @js.Any = value |> @js.identity
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   self.call1("update", js_value).cast()
    | }
    …

    | pub fn[T] IDBCursorWithValue::delete_current(
    |   self : IDBCursorWithValue[T],
    | ) -> IDBRequest[@js.Any] {
527 |   self.call0("delete").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn IDBKeyRange::bound(
    |   lower : &@js.JsImpl,
    |   upper : &@js.JsImpl,
    |   lowerOpen? : Bool,
    |   upperOpen? : Bool,
    | ) -> IDBKeyRange {
552 |   let global = @js.globalThis()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let idb_key_range = global.get("IDBKeyRange")
    |   idb_key_range.call("bound", [
    |     lower.to_any(),
    |     upper.to_any(),
    |     lowerOpen.unwrap_or(false),
    |     upperOpen.unwrap_or(false),
    |   ])
560 |   |> @js.identity
    |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn IDBKeyRange::only(value : &@js.JsImpl) -> IDBKeyRange {
566 |   let global = @js.globalThis()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let idb_key_range = global.get("IDBKeyRange")
    |   idb_key_range.call1("only", value.to_any()).cast()
    | }
    …

    | pub fn IDBKeyRange::lowerBound(
    |   lower : &@js.JsImpl,
    |   open? : Bool,
    | ) -> IDBKeyRange {
577 |   let global = @js.globalThis()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let idb_key_range = global.get("IDBKeyRange")
    |   idb_key_range.call2("lowerBound", lower.to_any(), open.unwrap_or(false))
    |   |> @js.identity
    | }
    …

    | pub fn IDBKeyRange::upperBound(
    |   upper : &@js.JsImpl,
    |   open? : Bool,
    | ) -> IDBKeyRange {
589 |   let global = @js.globalThis()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let idb_key_range = global.get("IDBKeyRange")
    |   idb_key_range
592 |   .call2("upperBound", upper.to_any(), open.unwrap_or(false))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   .cast()
    | }
    …

    | pub fn IDBKeyRange::includes(self : Self, key : &@js.JsImpl) -> Bool {
599 |   self.call1("includes", key.to_any()).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn open(name : String, version? : Int) -> IDBOpenDBRequest {
    |   let idb = indexedDB()
    |   match version {
    |     Some(v) => idb.call2("open", name, v).cast()
616 |     None => idb.call1("open", name).cast()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub fn deleteDatabase(name : String) -> IDBOpenDBRequest {
623 |   let idb = indexedDB()
    |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   idb.call1("deleteDatabase", name).cast()
    | }
    …

4 uncovered line(s) in src/browser/location/location.mbt:

   | pub fn Location::assign(self : Self, url : String) -> Unit {
28 |   ignore(self.call("assign", [url]))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Location::replace(self : Self, url : String) -> Unit {
35 |   ignore(self.call("replace", [url]))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Location::reload(self : Self) -> Unit {
42 |   ignore(self.call0("reload"))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Location::to_string(self : Self) -> String {
49 |   self.call0("toString").cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

1 uncovered line(s) in src/browser/navigator/navigator.mbt:

   | pub fn Navigator::vibrate(self : Self, pattern : Int) -> Bool {
34 |   self.call("vibrate", [pattern]).cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

15 uncovered line(s) in src/browser/observer/observer.mbt:

    | pub fn MutationObserver::new(
    |   callback : (@js.Any?, MutationObserver) -> Unit,
    | ) -> MutationObserver {
 20 |   let ctor = @js.global_this().get("MutationObserver")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @js.new_(ctor, [callback |> @js.from_fn2]).cast()
    | }
    …

    | pub fn MutationObserver::observe(
    |   self : Self,
    |   target : @dom.Element,
    |   options : @js.Any,
    | ) -> Unit {
 32 |   self.call2("observe", target |> @js.any, options) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MutationObserver::disconnect(self : Self) -> Unit {
 39 |   self.call0("disconnect") |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MutationObserver::take_records(self : Self) -> @js.Any {
 46 |   self.call0("takeRecords")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MutationRecord::mutation_type(self : Self) -> String {
 66 |   self.to_any().get("type").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn IntersectionObserver::new(
    |   callback : (@js.Any?, IntersectionObserver) -> Unit,
    |   options? : @js.Any,
    | ) -> IntersectionObserver {
 88 |   let ctor = @js.global_this().get("IntersectionObserver")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match options {
    |     Some(opts) => @js.new_(ctor, [callback |> @js.from_fn2, opts]).cast()
    |     None => @js.new_(ctor, [callback |> @js.from_fn2]).cast()
    |   }
    | }
    …

    | pub fn IntersectionObserver::observe(
    |   self : Self,
    |   target : @dom.Element,
    | ) -> Unit {
102 |   self.call("observe", [target]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn IntersectionObserver::unobserve(
    |   self : Self,
    |   target : @dom.Element,
    | ) -> Unit {
112 |   self.call("unobserve", [target]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn IntersectionObserver::disconnect(self : Self) -> Unit {
119 |   self.call0("disconnect") |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn IntersectionObserver::take_records(self : Self) -> @js.Any {
126 |   self.call0("takeRecords")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ResizeObserver::new(
    |   callback : (@js.Any?, ResizeObserver) -> Unit,
    | ) -> ResizeObserver {
160 |   let ctor = @js.global_this().get("ResizeObserver")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @js.new_(ctor, [callback |> @js.from_fn2]).cast()
    | }
    …

    | pub fn ResizeObserver::observe(self : Self, target : @dom.Element) -> Unit {
168 |   self.call("observe", [target |> @js.any]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ResizeObserver::observe_with_options(
    |   self : Self,
    |   target : @dom.Element,
    |   options : @js.Any,
    | ) -> Unit {
178 |   self.call2("observe", target |> @js.any, options) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ResizeObserver::unobserve(self : Self, target : @dom.Element) -> Unit {
185 |   self.call("unobserve", [target |> @js.any]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ResizeObserver::disconnect(self : Self) -> Unit {
192 |   self.call0("disconnect") |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

13 uncovered line(s) in src/browser/storage/storage.mbt:

    | pub fn Storage::clear(self : Storage) -> Unit {
 56 |   self.call0("clear") |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Storage::key(self : Storage, index : Int) -> String? {
 63 |   self.call("key", [index |> @js.any]) |> @js.identity_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Storage::hasItem(self : Storage, key : String) -> Bool {
 69 |   match self.getItem(key) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(_) => true
    |     None => false
    |   }
    | }
    …

    | pub fn Storage::keys(self : Storage) -> Array[String] {
 78 |   let len = self.length
    |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let result = []
 80 |   for i = 0; i < len; i = i + 1 {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     match self.key(i) {
    |       Some(k) => result.push(k)
    |       None => ()
    |     }
    |   }
    |   result
    | }
    …

    | pub fn Storage::values(self : Storage) -> Array[String] {
 92 |   let len = self.length
    |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let result = []
 94 |   for i = 0; i < len; i = i + 1 {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     match self.key(i) {
    |       Some(k) =>
 97 |         match self.getItem(k) {
    |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           Some(v) => result.push(v)
    |           None => ()
    |         }
101 |       None => ()
    |       ^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    |   result
    | }
    …

    | pub fn Storage::entries(self : Storage) -> Array[(String, String)] {
110 |   let len = self.length
    |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let result = []
112 |   for i = 0; i < len; i = i + 1 {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     match self.key(i) {
    |       Some(k) =>
115 |         match self.getItem(k) {
    |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           Some(v) => result.push((k, v))
    |           None => ()
    |         }
119 |       None => ()
    |       ^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    |   result
    | }
    …

3 uncovered line(s) in src/builtin_promise.mbt:

    | pub fn[A] Promise::new(
    |   f : ((A) -> Unit, (Error) -> Unit) -> Unit,
    | ) -> Promise[A] {
    |   ffi_new_promise(fn(resolve, reject) {
 21 |     f(a => a |> identity |> resolve, e => e |> identity |> reject)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   })
    |   |> identity
    | }
    …

    | pub fn[A, B] Promise::then(
    |   self : Self[A],
    |   resolve : (A) -> Self[B] raise,
    | ) -> Promise[B] {
 45 |   ffi_promise_then(self.to_any(), a => (a |> identity |> resolve |> identity) catch {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     e => e |> ffi_promise_reject |> identity
    |   })
    |   |> identity
    | }
    …

    | pub fn[T] Resolvers::reject(self : Self[T], error : Error) -> Unit {
158 |   (self.reject)(error)
    |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

7 uncovered line(s) in src/builtin_types.mbt:

    | pub impl Show for JsError with output(self, logger) {
299 |   logger.write_string(self.to_string())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl Show for ThrowError with output(self, logger) {
360 |   logger.write_string(self.to_string())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn[T] AsyncIterator::next(self : AsyncIterator[T]) -> T? {
601 |   let v : Promise[Any] = self.call0("next") |> identity
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let v : Any = v.wait()
    |   if (v.get("done") |> identity) {
604 |     None
    |     ^^^^ 	<-- UNCOVERED
    |   } else {
606 |     Some(v.get("value") |> identity)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub fn AbortController::abort(self : Self) -> AbortController {
630 |   self.call0("abort") |> identity
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn AbortController::signal(self : Self) -> AbortSignal {
644 |   self.get("signal") |> identity
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

3 uncovered line(s) in src/builtins/atomics/atomics.mbt:

    | pub fn notify(typedArray : @js.Any, index : Int, count? : Int) -> Int {
122 |   match count {
    |   ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(c) => ffi_atomics_notify(typedArray, index, c).cast()
    |     None => ffi_atomics_notify_2(typedArray, index).cast()
    |   }
    | }
    …

    | pub fn wait(
    |   typedArray : @js.Any,
    |   index : Int,
    |   value : Int,
    |   timeout? : Int,
    | ) -> AtomicsWaitResult {
180 |   let result = match timeout {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(t) => ffi_atomics_wait(typedArray, index, value, t)
    |     None => ffi_atomics_wait_3(typedArray, index, value)
    |   }
184 |   let result_str : String = @js.identity(result)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match result_str {
    |     "ok" => AtomicsWaitResult::Ok
    |     "not-equal" => AtomicsWaitResult::NotEqual
    |     "timed-out" => AtomicsWaitResult::TimedOut
    |     _ => AtomicsWaitResult::Ok // fallback
    |   }
    | }
    …

1 uncovered line(s) in src/builtins/collection/collection.mbt:

    | pub fn[T] JsSet::entries(self : JsSet[T]) -> @js.JsIterator[(T, T)] {
205 |   self |> @js.identity |> @js.Any::call0("entries") |> @js.identity
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

13 uncovered line(s) in src/builtins/proxy/proxy.mbt:

    | pub fn Proxy::revocable(
    |   target : &@js.JsImpl,
    |   get? : (@js.Any, @js.Any, @js.Any) -> @js.Any,
    |   set? : (@js.Any, @js.Any, @js.Any, @js.Any) -> Bool,
    |   has? : (@js.Any, @js.Any) -> Bool,
    |   deleteProperty? : (@js.Any, @js.Any) -> Bool,
    |   apply? : (@js.Any, @js.Any, @js.Any) -> @js.Any,
    |   construct? : (@js.Any, @js.Any, @js.Any) -> @js.Any,
    |   ownKeys? : (@js.Any) -> @js.Any,
    |   getPrototypeOf? : (@js.Any) -> @js.Any,
    |   setPrototypeOf? : (@js.Any, @js.Any) -> Bool,
    |   isExtensible? : (@js.Any) -> Bool,
    |   preventExtensions? : (@js.Any) -> Bool,
    |   getOwnPropertyDescriptor? : (@js.Any, @js.Any) -> @js.Any,
    |   defineProperty? : (@js.Any, @js.Any, @js.Any) -> Bool,
    | ) -> @js.Any {
    |   let handler = @js.Object::new()
    |   if get is Some(trap) {
125 |     let js_fn : @js.Any = @js.identity(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("get", js_fn)
    |   }
    |   if set is Some(trap) {
129 |     let js_fn : @js.Any = @js.identity(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("set", js_fn)
    |   }
    |   if has is Some(trap) {
133 |     let js_fn : @js.Any = @js.identity(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("has", js_fn)
    |   }
    |   if deleteProperty is Some(trap) {
137 |     let js_fn : @js.Any = @js.identity(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("deleteProperty", js_fn)
    |   }
    |   if apply is Some(trap) {
141 |     let js_fn : @js.Any = @js.identity(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("apply", js_fn)
    |   }
    |   if construct is Some(trap) {
145 |     let js_fn : @js.Any = @js.identity(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("construct", js_fn)
    |   }
    |   if ownKeys is Some(trap) {
149 |     let js_fn : @js.Any = @js.identity(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("ownKeys", js_fn)
    |   }
    |   if getPrototypeOf is Some(trap) {
153 |     let js_fn : @js.Any = @js.identity(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("getPrototypeOf", js_fn)
    |   }
    |   if setPrototypeOf is Some(trap) {
157 |     let js_fn : @js.Any = @js.identity(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("setPrototypeOf", js_fn)
    |   }
    |   if isExtensible is Some(trap) {
161 |     let js_fn : @js.Any = @js.identity(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("isExtensible", js_fn)
    |   }
    |   if preventExtensions is Some(trap) {
165 |     let js_fn : @js.Any = @js.identity(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("preventExtensions", js_fn)
    |   }
    |   if getOwnPropertyDescriptor is Some(trap) {
169 |     let js_fn : @js.Any = @js.identity(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("getOwnPropertyDescriptor", js_fn)
    |   }
    |   if defineProperty is Some(trap) {
173 |     let js_fn : @js.Any = @js.identity(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("defineProperty", js_fn)
    |   }
    |   proxy_class().call2("revocable", target.to_any(), handler.to_any())
    | }
    …

1 uncovered line(s) in src/builtins/reflect/reflect.mbt:

    | pub fn construct(
    |   target : &@js.JsImpl,
    |   arguments_list : Array[@js.Any],
    |   new_target : @js.Any?,
    | ) -> @js.Any {
    |   match new_target {
    |     Some(nt) =>
 32 |       reflect_class().call("construct", [
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         target.to_any(),
    |         @js.from_array(arguments_list),
    |         nt,
    |       ])
    |     None =>
    |       reflect_class().call("construct", [
    |         target.to_any(),
    |         @js.from_array(arguments_list),
    |       ])
    |   }
    | }
    …

10 uncovered line(s) in src/builtins/regexp/regexp.mbt:

    | pub fn RegExp::match_(self : RegExp, string : String) -> RegExpMatchArray? {
    |   let v = ffi_string_match(string, self)
    |   if @js.is_null(v) {
    |     return None
    |   }
    |   let len : Int = v.get("length").cast()
    |   let matches : Array[String] = Array::new(capacity=len)
    |   for i = 0; i < len; i = i + 1 {
    |     matches.push(v.get(i).cast())
    |   }
    |   let index : Int? = if @js.is_undefined(v.get("index")) {
355 |     None
    |     ^^^^ 	<-- UNCOVERED
    |   } else {
    |     Some(v.get("index").cast())
    |   }
    |   let input : String? = if @js.is_undefined(v.get("input")) {
360 |     None
    |     ^^^^ 	<-- UNCOVERED
    |   } else {
    |     Some(v.get("input").cast())
    |   }
    |   let groups : Map[String, String]? = if @js.is_undefined(v.get("groups")) {
    |     None
    |   } else {
367 |     let g : Map[String, String] = {}
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let keys = @js.Object::keys(v.get("groups"))
    |     for k in keys {
370 |       g[k] = @js.identity(v.get("groups").get(k))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     Some(g)
    |   }
    |   Some({ matches, index, input, groups })
    | }
    …

    | pub fn RegExp::matchAll(
    |   self : RegExp,
    |   string : String,
    | ) -> Array[RegExpMatchArray] {
    |   let v = ffi_string_match_all(string, self)
    |   let len : Int = v.get("length").cast()
    |   let results : Array[RegExpMatchArray] = []
    |   for i = 0; i < len; i = i + 1 {
    |     let item = v.get(i)
    |     let match_len : Int = item.get("length").cast()
    |     let matches : Array[String] = Array::new(capacity=match_len)
    |     for j = 0; j < match_len; j = j + 1 {
    |       matches.push(item.get(j).cast())
    |     }
    |     let index : Int? = if @js.is_undefined(item.get("index")) {
397 |       None
    |       ^^^^ 	<-- UNCOVERED
    |     } else {
    |       Some(item.get("index").cast())
    |     }
    |     let input : String? = if @js.is_undefined(item.get("input")) {
402 |       None
    |       ^^^^ 	<-- UNCOVERED
    |     } else {
    |       Some(item.get("input").cast())
    |     }
    |     let groups : Map[String, String]? = if @js.is_undefined(item.get("groups")) {
    |       None
    |     } else {
409 |       let g : Map[String, String] = {}
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let keys = @js.Object::keys(item.get("groups"))
    |       for k in keys {
412 |         g[k] = @js.identity(item.get("groups").get(k))
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |       Some(g)
    |     }
    |     results.push({ matches, index, input, groups })
    |   }
    |   results
    | }
    …

    | pub fn RegExp::replace_fn(
    |   self : RegExp,
    |   string : String,
    |   replacer : (String, Array[String], Int, String) -> String,
    | ) -> String {
    |   let wrapper = fn(
    |     matched : String,
    |     groups_val : @js.Any,
    |     offset : Int,
    |     input : String,
    |   ) -> String {
    |     let groups_len : Int = groups_val.get("length").cast()
    |     let groups : Array[String] = Array::new(capacity=groups_len)
    |     for i = 0; i < groups_len; i = i + 1 {
    |       let item = groups_val.get(i)
    |       if @js.is_undefined(item) {
468 |         groups.push("")
    |         ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       } else {
    |         groups.push(@js.identity(item))
    |       }
    |     }
    |     replacer(matched, groups, offset, input)
    |   }
    |   ffi_string_replace_fn(string, self, @js.unsafe_any(wrapper))
    | }
    …

    | pub fn RegExp::replace_all_fn(
    |   self : RegExp,
    |   string : String,
    |   replacer : (String, Array[String], Int, String) -> String,
    | ) -> String {
    |   let wrapper = fn(
    |     matched : String,
    |     groups_val : @js.Any,
    |     offset : Int,
    |     input : String,
    |   ) -> String {
    |     let groups_len : Int = groups_val.get("length").cast()
    |     let groups : Array[String] = Array::new(capacity=groups_len)
    |     for i = 0; i < groups_len; i = i + 1 {
    |       let item = groups_val.get(i)
    |       if @js.is_undefined(item) {
499 |         groups.push("")
    |         ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       } else {
    |         groups.push(@js.identity(item))
    |       }
    |     }
    |     replacer(matched, groups, offset, input)
    |   }
    |   ffi_string_replace_all_fn(string, self, @js.unsafe_any(wrapper))
    | }
    …

76 uncovered line(s) in src/builtins/typedarray/typed_array.mbt:

     | #alias(copy_within)
     | pub fn Uint16Array::copyWithin(
     |   self : Self,
     |   target : Int,
     |   start : Int,
     |   end? : Int,
     | ) -> Self {
 160 |   match end {
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(e) => self.call("copyWithin", [target, start, e]).cast()
     |     None => self.call2("copyWithin", target, start).cast()
     |   }
     | }
     …

     | #alias(index_of)
     | pub fn Uint16Array::indexOf(
     |   self : Self,
     |   search_element : UInt,
     |   from_index? : Int = 0,
     | ) -> Int {
 173 |   self.call2("indexOf", search_element, from_index).cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | #alias(last_index_of)
     | pub fn Uint16Array::lastIndexOf(
     |   self : Self,
     |   search_element : UInt,
     |   from_index? : Int,
     | ) -> Int {
 183 |   match from_index {
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(i) => self.call2("lastIndexOf", search_element, i).cast()
     |     None => self.call("lastIndexOf", [search_element]).cast()
     |   }
     | }
     …

     | #alias(to_string)
     | pub fn Uint16Array::toString(self : Self) -> String {
 192 |   self.call0("toString").cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn Uint16Array::fill(
     |   self : Self,
     |   value : UInt,
     |   start? : Int = 0,
     |   end? : Int,
     | ) -> Self {
 253 |   match end {
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(e) => self.call("fill", [value, start, e]).cast()
     |     None => self.call2("fill", value, start).cast()
     |   }
     | }
     …

     | pub fn Uint16Array::includes(
     |   self : Self,
     |   search_element : UInt,
     |   from_index? : Int = 0,
     | ) -> Bool {
 265 |   self.call2("includes", search_element, from_index).cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | #alias(copy_within)
     | pub fn Uint32Array::copyWithin(
     |   self : Self,
     |   target : Int,
     |   start : Int,
     |   end? : Int,
     | ) -> Self {
 290 |   match end {
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(e) => self.call("copyWithin", [target, start, e]).cast()
     |     None => self.call2("copyWithin", target, start).cast()
     |   }
     | }
     …

     | #alias(index_of)
     | pub fn Uint32Array::indexOf(
     |   self : Self,
     |   search_element : UInt,
     |   from_index? : Int = 0,
     | ) -> Int {
 303 |   self.call2("indexOf", search_element, from_index).cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | #alias(last_index_of)
     | pub fn Uint32Array::lastIndexOf(
     |   self : Self,
     |   search_element : UInt,
     |   from_index? : Int,
     | ) -> Int {
 313 |   match from_index {
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(i) => self.call2("lastIndexOf", search_element, i).cast()
     |     None => self.call("lastIndexOf", [search_element]).cast()
     |   }
     | }
     …

     | #alias(to_string)
     | pub fn Uint32Array::toString(self : Self) -> String {
 322 |   self.call0("toString").cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn Uint32Array::fill(
     |   self : Self,
     |   value : UInt,
     |   start? : Int = 0,
     |   end? : Int,
     | ) -> Self {
 383 |   match end {
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(e) => self.call("fill", [value, start, e]).cast()
     |     None => self.call2("fill", value, start).cast()
     |   }
     | }
     …

     | pub fn Uint32Array::includes(
     |   self : Self,
     |   search_element : UInt,
     |   from_index? : Int = 0,
     | ) -> Bool {
 395 |   self.call2("includes", search_element, from_index).cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | #alias(copy_within)
     | pub fn Int8Array::copyWithin(
     |   self : Self,
     |   target : Int,
     |   start : Int,
     |   end? : Int,
     | ) -> Self {
 420 |   match end {
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(e) => self.call("copyWithin", [target, start, e]).cast()
     |     None => self.call2("copyWithin", target, start).cast()
     |   }
     | }
     …

     | #alias(index_of)
     | pub fn Int8Array::indexOf(
     |   self : Self,
     |   search_element : Int,
     |   from_index? : Int = 0,
     | ) -> Int {
 433 |   self.call2("indexOf", search_element, from_index).cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | #alias(last_index_of)
     | pub fn Int8Array::lastIndexOf(
     |   self : Self,
     |   search_element : Int,
     |   from_index? : Int,
     | ) -> Int {
 443 |   match from_index {
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(i) => self.call2("lastIndexOf", search_element, i).cast()
     |     None => self.call("lastIndexOf", [search_element]).cast()
     |   }
     | }
     …

     | #alias(to_string)
     | pub fn Int8Array::toString(self : Self) -> String {
 452 |   self.call0("toString").cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn Int8Array::fill(
     |   self : Self,
     |   value : Int,
     |   start? : Int = 0,
     |   end? : Int,
     | ) -> Self {
 511 |   match end {
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(e) => self.call("fill", [value, start, e]).cast()
     |     None => self.call2("fill", value, start).cast()
     |   }
     | }
     …

     | pub fn Int8Array::includes(
     |   self : Self,
     |   search_element : Int,
     |   from_index? : Int = 0,
     | ) -> Bool {
 523 |   self.call2("includes", search_element, from_index).cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | #alias(copy_within)
     | pub fn Int16Array::copyWithin(
     |   self : Self,
     |   target : Int,
     |   start : Int,
     |   end? : Int,
     | ) -> Self {
 548 |   match end {
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(e) => self.call("copyWithin", [target, start, e]).cast()
     |     None => self.call2("copyWithin", target, start).cast()
     |   }
     | }
     …

     | #alias(index_of)
     | pub fn Int16Array::indexOf(
     |   self : Self,
     |   search_element : Int,
     |   from_index? : Int = 0,
     | ) -> Int {
 561 |   self.call2("indexOf", search_element, from_index).cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | #alias(last_index_of)
     | pub fn Int16Array::lastIndexOf(
     |   self : Self,
     |   search_element : Int,
     |   from_index? : Int,
     | ) -> Int {
 571 |   match from_index {
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(i) => self.call2("lastIndexOf", search_element, i).cast()
     |     None => self.call("lastIndexOf", [search_element]).cast()
     |   }
     | }
     …

     | #alias(to_string)
     | pub fn Int16Array::toString(self : Self) -> String {
 580 |   self.call0("toString").cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn Int16Array::fill(
     |   self : Self,
     |   value : Int,
     |   start? : Int = 0,
     |   end? : Int,
     | ) -> Self {
 639 |   match end {
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(e) => self.call("fill", [value, start, e]).cast()
     |     None => self.call2("fill", value, start).cast()
     |   }
     | }
     …

     | pub fn Int16Array::includes(
     |   self : Self,
     |   search_element : Int,
     |   from_index? : Int = 0,
     | ) -> Bool {
 651 |   self.call2("includes", search_element, from_index).cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | #alias(copy_within)
     | pub fn Int32Array::copyWithin(
     |   self : Self,
     |   target : Int,
     |   start : Int,
     |   end? : Int,
     | ) -> Self {
 676 |   match end {
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(e) => self.call("copyWithin", [target, start, e]).cast()
     |     None => self.call2("copyWithin", target, start).cast()
     |   }
     | }
     …

     | #alias(index_of)
     | pub fn Int32Array::indexOf(
     |   self : Self,
     |   search_element : Int,
     |   from_index? : Int = 0,
     | ) -> Int {
 689 |   self.call2("indexOf", search_element, from_index).cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | #alias(last_index_of)
     | pub fn Int32Array::lastIndexOf(
     |   self : Self,
     |   search_element : Int,
     |   from_index? : Int,
     | ) -> Int {
 699 |   match from_index {
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(i) => self.call2("lastIndexOf", search_element, i).cast()
     |     None => self.call("lastIndexOf", [search_element]).cast()
     |   }
     | }
     …

     | #alias(to_string)
     | pub fn Int32Array::toString(self : Self) -> String {
 708 |   self.call0("toString").cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn Int32Array::fill(
     |   self : Self,
     |   value : Int,
     |   start? : Int = 0,
     |   end? : Int,
     | ) -> Self {
 767 |   match end {
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(e) => self.call("fill", [value, start, e]).cast()
     |     None => self.call2("fill", value, start).cast()
     |   }
     | }
     …

     | pub fn Int32Array::includes(
     |   self : Self,
     |   search_element : Int,
     |   from_index? : Int = 0,
     | ) -> Bool {
 779 |   self.call2("includes", search_element, from_index).cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | #alias(copy_within)
     | pub fn Float32Array::copyWithin(
     |   self : Self,
     |   target : Int,
     |   start : Int,
     |   end? : Int,
     | ) -> Self {
 804 |   match end {
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(e) => self.call("copyWithin", [target, start, e]).cast()
     |     None => self.call2("copyWithin", target, start).cast()
     |   }
     | }
     …

     | #alias(index_of)
     | pub fn Float32Array::indexOf(
     |   self : Self,
     |   search_element : Double,
     |   from_index? : Int = 0,
     | ) -> Int {
 817 |   self.call2("indexOf", search_element, from_index).cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | #alias(last_index_of)
     | pub fn Float32Array::lastIndexOf(
     |   self : Self,
     |   search_element : Double,
     |   from_index? : Int,
     | ) -> Int {
 827 |   match from_index {
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(i) => self.call2("lastIndexOf", search_element, i).cast()
     |     None => self.call("lastIndexOf", [search_element]).cast()
     |   }
     | }
     …

     | #alias(to_string)
     | pub fn Float32Array::toString(self : Self) -> String {
 836 |   self.call0("toString").cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn Float32Array::fill(
     |   self : Self,
     |   value : Double,
     |   start? : Int = 0,
     |   end? : Int,
     | ) -> Self {
 897 |   match end {
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(e) => self.call("fill", [value, start, e]).cast()
     |     None => self.call2("fill", value, start).cast()
     |   }
     | }
     …

     | pub fn Float32Array::includes(
     |   self : Self,
     |   search_element : Double,
     |   from_index? : Int = 0,
     | ) -> Bool {
 909 |   self.call2("includes", search_element, from_index).cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | #alias(copy_within)
     | pub fn Float64Array::copyWithin(
     |   self : Self,
     |   target : Int,
     |   start : Int,
     |   end? : Int,
     | ) -> Self {
 934 |   match end {
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(e) => self.call("copyWithin", [target, start, e]).cast()
     |     None => self.call2("copyWithin", target, start).cast()
     |   }
     | }
     …

     | #alias(index_of)
     | pub fn Float64Array::indexOf(
     |   self : Self,
     |   search_element : Double,
     |   from_index? : Int = 0,
     | ) -> Int {
 947 |   self.call2("indexOf", search_element, from_index).cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | #alias(last_index_of)
     | pub fn Float64Array::lastIndexOf(
     |   self : Self,
     |   search_element : Double,
     |   from_index? : Int,
     | ) -> Int {
 957 |   match from_index {
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(i) => self.call2("lastIndexOf", search_element, i).cast()
     |     None => self.call("lastIndexOf", [search_element]).cast()
     |   }
     | }
     …

     | #alias(to_string)
     | pub fn Float64Array::toString(self : Self) -> String {
 966 |   self.call0("toString").cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn Float64Array::fill(
     |   self : Self,
     |   value : Double,
     |   start? : Int = 0,
     |   end? : Int,
     | ) -> Self {
1027 |   match end {
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(e) => self.call("fill", [value, start, e]).cast()
     |     None => self.call2("fill", value, start).cast()
     |   }
     | }
     …

     | pub fn Float64Array::includes(
     |   self : Self,
     |   search_element : Double,
     |   from_index? : Int = 0,
     | ) -> Bool {
1039 |   self.call2("includes", search_element, from_index).cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | #alias(copy_within)
     | pub fn Uint8ClampedArray::copyWithin(
     |   self : Self,
     |   target : Int,
     |   start : Int,
     |   end? : Int,
     | ) -> Self {
1064 |   match end {
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(e) => self.call("copyWithin", [target, start, e]).cast()
     |     None => self.call2("copyWithin", target, start).cast()
     |   }
     | }
     …

     | #alias(index_of)
     | pub fn Uint8ClampedArray::indexOf(
     |   self : Self,
     |   search_element : UInt,
     |   from_index? : Int = 0,
     | ) -> Int {
1077 |   self.call2("indexOf", search_element, from_index).cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | #alias(last_index_of)
     | pub fn Uint8ClampedArray::lastIndexOf(
     |   self : Self,
     |   search_element : UInt,
     |   from_index? : Int,
     | ) -> Int {
1087 |   match from_index {
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(i) => self.call2("lastIndexOf", search_element, i).cast()
     |     None => self.call("lastIndexOf", [search_element]).cast()
     |   }
     | }
     …

     | #alias(to_string)
     | pub fn Uint8ClampedArray::toString(self : Self) -> String {
1096 |   self.call0("toString").cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn Uint8ClampedArray::from_size(length : UInt) -> Uint8ClampedArray {
1101 |   @js.identity(ffi_uint8clampedarray_from_size(length))
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn Uint8ClampedArray::from_array(array : Array[UInt]) -> Uint8ClampedArray {
1110 |   @js.identity(ffi_uint8clampedarray_from_array(@js.from_array(array)))
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn Uint8ClampedArray::from_array_buffer(
     |   buffer : @js.ArrayBuffer,
     |   byte_offset? : UInt = 0,
     |   length? : UInt,
     | ) -> Uint8ClampedArray {
1123 |   @js.identity(
     |   ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     ffi_uint8clampedarray_from_buffer(buffer.to_any(), byte_offset, length),
     |   )
     | }
     …

     | pub fn Uint8ClampedArray::set(
     |   self : Self,
     |   array : Array[UInt],
     |   offset? : UInt = 0,
     | ) -> Unit {
1156 |   self.call2("set", @js.from_array(array), offset) |> ignore
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn Uint8ClampedArray::fill(
     |   self : Self,
     |   value : UInt,
     |   start? : Int = 0,
     |   end? : Int,
     | ) -> Self {
1166 |   match end {
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(e) => self.call("fill", [value, start, e]).cast()
     |     None => self.call2("fill", value, start).cast()
     |   }
     | }
     …

     | pub fn Uint8ClampedArray::includes(
     |   self : Self,
     |   search_element : UInt,
     |   from_index? : Int = 0,
     | ) -> Bool {
1178 |   self.call2("includes", search_element, from_index).cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | #alias(byte_length)
     | pub fn BigUint64Array::byteLength(self : Self) -> UInt {
1194 |   self.get("byteLength").cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | #alias(byte_offset)
     | pub fn BigUint64Array::byteOffset(self : Self) -> UInt {
1200 |   self.get("byteOffset").cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | #alias(copy_within)
     | pub fn BigUint64Array::copyWithin(
     |   self : Self,
     |   target : Int,
     |   start : Int,
     |   end? : Int,
     | ) -> Self {
1211 |   match end {
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(e) => self.call("copyWithin", [target, start, e]).cast()
     |     None => self.call2("copyWithin", target, start).cast()
     |   }
     | }
     …

     | #alias(index_of)
     | pub fn BigUint64Array::indexOf(
     |   self : Self,
     |   search_element : @bigint.JsBigInt,
     |   from_index? : Int = 0,
     | ) -> Int {
1224 |   self.call2("indexOf", search_element, from_index).cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | #alias(last_index_of)
     | pub fn BigUint64Array::lastIndexOf(
     |   self : Self,
     |   search_element : @bigint.JsBigInt,
     |   from_index? : Int,
     | ) -> Int {
1234 |   match from_index {
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(i) => self.call2("lastIndexOf", search_element, i).cast()
     |     None => self.call("lastIndexOf", [search_element]).cast()
     |   }
     | }
     …

     | #alias(to_string)
     | pub fn BigUint64Array::toString(self : Self) -> String {
1243 |   self.call0("toString").cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BigUint64Array::from_size(length : UInt) -> BigUint64Array {
1248 |   @js.identity(ffi_biguint64array_from_size(length))
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BigUint64Array::from_array(
     |   array : Array[@bigint.JsBigInt],
     | ) -> BigUint64Array {
1259 |   @js.identity(ffi_biguint64array_from_array(@js.from_array(array)))
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BigUint64Array::from_array_buffer(
     |   buffer : @js.ArrayBuffer,
     |   byte_offset? : UInt = 0,
     |   length? : UInt,
     | ) -> BigUint64Array {
1272 |   @js.identity(
     |   ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     ffi_biguint64array_from_buffer(buffer.to_any(), byte_offset, length),
     |   )
     | }
     …

     | pub fn BigUint64Array::set(
     |   self : Self,
     |   array : Array[@bigint.JsBigInt],
     |   offset? : UInt = 0,
     | ) -> Unit {
1308 |   self.call2("set", @js.from_array(array), offset) |> ignore
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BigUint64Array::fill(
     |   self : Self,
     |   value : @bigint.JsBigInt,
     |   start? : Int = 0,
     |   end? : Int,
     | ) -> Self {
1318 |   match end {
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(e) => self.call("fill", [value, start, e]).cast()
     |     None => self.call2("fill", value, start).cast()
     |   }
     | }
     …

     | pub fn BigUint64Array::includes(
     |   self : Self,
     |   search_element : @bigint.JsBigInt,
     |   from_index? : Int = 0,
     | ) -> Bool {
1330 |   self.call2("includes", search_element, from_index).cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | #alias(byte_length)
     | pub fn BigInt64Array::byteLength(self : Self) -> UInt {
1346 |   self.get("byteLength").cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | #alias(byte_offset)
     | pub fn BigInt64Array::byteOffset(self : Self) -> UInt {
1352 |   self.get("byteOffset").cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | #alias(copy_within)
     | pub fn BigInt64Array::copyWithin(
     |   self : Self,
     |   target : Int,
     |   start : Int,
     |   end? : Int,
     | ) -> Self {
1363 |   match end {
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(e) => self.call("copyWithin", [target, start, e]).cast()
     |     None => self.call2("copyWithin", target, start).cast()
     |   }
     | }
     …

     | #alias(index_of)
     | pub fn BigInt64Array::indexOf(
     |   self : Self,
     |   search_element : @bigint.JsBigInt,
     |   from_index? : Int = 0,
     | ) -> Int {
1376 |   self.call2("indexOf", search_element, from_index).cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | #alias(last_index_of)
     | pub fn BigInt64Array::lastIndexOf(
     |   self : Self,
     |   search_element : @bigint.JsBigInt,
     |   from_index? : Int,
     | ) -> Int {
1386 |   match from_index {
     |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(i) => self.call2("lastIndexOf", search_element, i).cast()
     |     None => self.call("lastIndexOf", [search_element]).cast()
     |   }
     | }
     …

     | #alias(to_string)
     | pub fn BigInt64Array::toString(self : Self) -> String {
1395 |   self.call0("toString").cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BigInt64Array::from_size(length : UInt) -> BigInt64Array {
1400 |   @js.identity(ffi_bigint64array_from_size(length))
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BigInt64Array::from_array(
     |   array : Array[@bigint.JsBigInt],
     | ) -> BigInt64Array {
1411 |   @js.identity(ffi_bigint64array_from_array(@js.from_array(array)))
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BigInt64Array::from_array_buffer(
     |   buffer : @js.ArrayBuffer,
     |   byte_offset? : UInt = 0,
     |   length? : UInt,
     | ) -> BigInt64Array {
1424 |   @js.identity(
     |   ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     ffi_bigint64array_from_buffer(buffer.to_any(), byte_offset, length),
     |   )
     | }
     …

     | pub fn BigInt64Array::set(
     |   self : Self,
     |   array : Array[@bigint.JsBigInt],
     |   offset? : UInt = 0,
     | ) -> Unit {
1460 |   self.call2("set", @js.from_array(array), offset) |> ignore
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

     | pub fn BigInt64Array::fill(
     |   self : Self,
     |   value : @bigint.JsBigInt,
     |   start? : Int = 0,
     |   end? : Int,
     | ) -> Self {
1470 |   match end {
     |   ^^^^^^^^^^^ 	<-- UNCOVERED
     |     Some(e) => self.call("fill", [value, start, e]).cast()
     |     None => self.call2("fill", value, start).cast()
     |   }
     | }
     …

     | pub fn BigInt64Array::includes(
     |   self : Self,
     |   search_element : @bigint.JsBigInt,
     |   from_index? : Int = 0,
     | ) -> Bool {
1482 |   self.call2("includes", search_element, from_index).cast()
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     | }
     …

4 uncovered line(s) in src/builtins/typedarray/typed_array_trait.mbt:

    | impl TypedArrayImpl with byteLength(self) -> UInt {
 50 |   self.get("byteLength").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | impl TypedArrayImpl with byteOffset(self) -> UInt {
 55 |   self.get("byteOffset").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | impl TypedArrayImpl with copyWithin(self, target, start, end? : Int) -> Self {
 76 |   match end {
    |   ^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(e) => self.call("copyWithin", [target, start, e]).cast()
    |     None => self.call2("copyWithin", target, start).cast()
    |   }
    | }
    …

    | impl TypedArrayImpl with toString(self) -> String {
 99 |   self.call0("toString").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

1 uncovered line(s) in src/builtins/weak/weak.mbt:

    | pub fn[T : @js.JsImpl] FinalizationRegistry::new(
    |   cleanup_callback : (T) -> Unit,
    | ) -> FinalizationRegistry[T] {
132 |   ffi_new_finalization_registry(fn(val) { cleanup_callback(val.cast()) }).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

4 uncovered line(s) in src/cloudflare/cloudflare.mbt:

   | pub fn CloudflareRequest::cf(self : CloudflareRequest) -> CloudflareContext {
23 |   self.get("cf").cast()
   |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn CloudflareRequest::url(self : CloudflareRequest) -> String {
28 |   self.get("url").cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | #alias(waitUntil)
   | pub fn CloudflareContext::wait_until(
   |   self : CloudflareContext,
   |   promise : @js.Promise[Unit],
   | ) -> Unit {
37 |   @js.identity(self.get("waitUntil").call_self([promise |> @js.identity]))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | #alias(passThroughException)
   | pub fn CloudflareContext::pass_through_exception(
   |   self : CloudflareContext,
   | ) -> Unit {
45 |   self.get("passThroughException").call_self([]) |> ignore
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

21 uncovered line(s) in src/cloudflare/d1.mbt:

    | pub fn D1Database::prepare(self : Self, query : String) -> D1PreparedStatement {
 13 |   self.call("prepare", [query]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn D1Database::exec(
    |   self : Self,
    |   query : String,
    | ) -> @js.Promise[D1ExecResult] {
 22 |   self.call("exec", [query]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn D1Database::batch(
    |   self : Self,
    |   statements : Array[D1PreparedStatement],
    | ) -> @js.Promise[Array[D1Result]] {
 31 |   let stmts_js = @js.JsArray::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let mut i = 0
    |   while i < statements.length() {
 34 |     stmts_js.call("push", [statements[i]]) |> ignore
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     i = i + 1
    |   }
 37 |   self.call("batch", [stmts_js]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn D1Database::dump(self : Self) -> @js.Promise[@js.Any] {
 43 |   self.call0("dump").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn D1PreparedStatement::bind(self : Self, params : Array[@js.Any]) -> Self {
    |   // Cloudflare's bind() expects variadic arguments, not an array
    |   // We need to spread the array when calling bind
 60 |   let stmt_js = self.to_any()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let bind_fn = stmt_js.get("bind")
    | 
    |   // Convert MoonBit array to JavaScript array
 64 |   let params_js = @js.JsArray::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let mut i = 0
    |   while i < params.length() {
 67 |     params_js.call("push", [params[i]]) |> ignore
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     i = i + 1
    |   }
    | 
    |   // Use apply to spread the array as individual arguments
 72 |   bind_fn.call2("apply", stmt_js, params_js).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn D1PreparedStatement::bind1(self : Self, param : @js.Any) -> Self {
 78 |   self.bind([param])
    |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn D1PreparedStatement::bind2(
    |   self : Self,
    |   p1 : @js.Any,
    |   p2 : @js.Any,
    | ) -> Self {
 88 |   self.bind([p1, p2])
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn D1PreparedStatement::bind3(
    |   self : Self,
    |   p1 : @js.Any,
    |   p2 : @js.Any,
    |   p3 : @js.Any,
    | ) -> Self {
 99 |   self.bind([p1, p2, p3])
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn D1PreparedStatement::first(self : Self) -> @js.Promise[@js.Any?] {
105 |   self.call0("first").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn D1PreparedStatement::first_col(
    |   self : Self,
    |   col_name : String,
    | ) -> @js.Promise[@js.Any?] {
114 |   self.call1("first", col_name).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn D1PreparedStatement::all(self : Self) -> @js.Promise[D1Result] {
120 |   self.call0("all").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn D1PreparedStatement::run(self : Self) -> @js.Promise[D1Result] {
126 |   self.call0("run").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn D1PreparedStatement::raw(self : Self) -> @js.Promise[Array[@js.Any]] {
132 |   self.call0("raw").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn D1PreparedStatement::raw_with_options(
    |   self : Self,
    |   options : D1RawOptions,
    | ) -> @js.Promise[Array[@js.Any]] {
141 |   self.call1("raw", options).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl @js.JsImpl for D1RawOptions with to_any(self) {
152 |   @js.from_entries_option_cast([("columnNames", self.columnNames)])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn D1Result::get_results(self : Self) -> Array[@js.Any] {
172 |   match self.results {
    |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(r) => r
    |     None => []
    |   }
    | }
    …

75 uncovered line(s) in src/cloudflare/do.mbt:

    | pub fn DurableObjectNamespace::get(
    |   self : Self,
    |   id : DurableObjectId,
    | ) -> DurableObjectStub {
 16 |   self.call1("get", id).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectNamespace::get_by_id_string(
    |   self : Self,
    |   id : String,
    | ) -> DurableObjectStub {
 25 |   self.call1("get", id).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectNamespace::get_by_name(
    |   self : Self,
    |   name : String,
    | ) -> DurableObjectStub {
 34 |   self.call("get", [self.id_from_name(name).to_any()]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectNamespace::new_unique_id(self : Self) -> DurableObjectId {
 40 |   self.call0("newUniqueId").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectNamespace::new_unique_id_with_options(
    |   self : Self,
    |   options : DurableObjectIdOptions,
    | ) -> DurableObjectId {
 49 |   self.call("newUniqueId", [options.to_any()]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectNamespace::id_from_name(
    |   self : Self,
    |   name : String,
    | ) -> DurableObjectId {
 58 |   self.call("idFromName", [name]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectNamespace::id_from_string(
    |   self : Self,
    |   id : String,
    | ) -> DurableObjectId {
 67 |   self.call("idFromString", [id]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl @js.JsImpl for DurableObjectIdOptions with to_any(self) {
 78 |   @js.from_entries_option_cast([("jurisdiction", self.jurisdiction)])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectId::to_string(self : Self) -> String {
 92 |   self.call0("toString").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectId::equals(self : Self, other : DurableObjectId) -> Bool {
 98 |   self.call("equals", [other.to_any()]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectId::name(self : Self) -> String? {
104 |   self.get("name").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStub::id(self : Self) -> DurableObjectId {
118 |   self.get("id").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStub::name(self : Self) -> String? {
124 |   self.get("name").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStub::fetch(
    |   self : Self,
    |   request : @js.Any,
    | ) -> @js.Promise[@js.Any] {
133 |   self.call("fetch", [request]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStub::fetch_with_init(
    |   self : Self,
    |   request : @js.Any,
    |   init : @js.Any,
    | ) -> @js.Promise[@js.Any] {
143 |   self.call2("fetch", request, init).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStub::fetch_url(
    |   self : Self,
    |   url : String,
    | ) -> @js.Promise[@js.Any] {
152 |   self.call("fetch", [url]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStub::fetch_url_with_init(
    |   self : Self,
    |   url : String,
    |   init : @js.Any,
    | ) -> @js.Promise[@js.Any] {
162 |   self.call2("fetch", url, init).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectState::id(self : Self) -> DurableObjectId {
176 |   self.get("id").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectState::storage(self : Self) -> DurableObjectStorage {
182 |   self.get("storage").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectState::wait_until(self : Self, promise : @js.Any) -> Unit {
188 |   self.call("waitUntil", [promise]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectState::block_concurrency_while(
    |   self : Self,
    |   callback : @js.Any,
    | ) -> @js.Promise[Unit] {
197 |   self.call("blockConcurrencyWhile", [callback]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::get(
    |   self : Self,
    |   key : String,
    | ) -> @js.Promise[@js.Any?] {
214 |   self.call("get", [key]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::get_with_options(
    |   self : Self,
    |   key : String,
    |   options : DurableObjectGetOptions,
    | ) -> @js.Promise[@js.Any?] {
224 |   self.call2("get", key, options).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::get_multiple(
    |   self : Self,
    |   keys : Array[String],
    | ) -> @js.Promise[@js.Any] {
233 |   let keys_js = @js.JsArray::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let mut i = 0
    |   while i < keys.length() {
236 |     keys_js.call("push", [keys[i]]) |> ignore
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     i = i + 1
    |   }
239 |   self.call("get", [keys_js]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::get_multiple_with_options(
    |   self : Self,
    |   keys : Array[String],
    |   options : DurableObjectGetOptions,
    | ) -> @js.Promise[@js.Any] {
249 |   let keys_js = @js.JsArray::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let mut i = 0
    |   while i < keys.length() {
252 |     keys_js.call("push", [keys[i]]) |> ignore
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     i = i + 1
    |   }
255 |   self.call2("get", keys_js, options.to_any()).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::put(
    |   self : Self,
    |   key : String,
    |   value : @js.Any,
    | ) -> @js.Promise[Unit] {
265 |   self.call2("put", key, value).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::put_with_options(
    |   self : Self,
    |   key : String,
    |   value : @js.Any,
    |   options : DurableObjectPutOptions,
    | ) -> @js.Promise[Unit] {
276 |   self.call("put", [key, value, options]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::put_multiple(
    |   self : Self,
    |   entries : @js.Any,
    | ) -> @js.Promise[Unit] {
285 |   self.call("put", [entries]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::put_multiple_with_options(
    |   self : Self,
    |   entries : @js.Any,
    |   options : DurableObjectPutOptions,
    | ) -> @js.Promise[Unit] {
295 |   self.call2("put", entries, options.to_any()).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::delete(
    |   self : Self,
    |   key : String,
    | ) -> @js.Promise[Bool] {
304 |   self.call("delete", [key]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::delete_with_options(
    |   self : Self,
    |   key : String,
    |   options : DurableObjectPutOptions,
    | ) -> @js.Promise[Bool] {
314 |   self.call2("delete", key, options).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::delete_multiple(
    |   self : Self,
    |   keys : Array[String],
    | ) -> @js.Promise[Int] {
323 |   let keys_js = @js.JsArray::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let mut i = 0
    |   while i < keys.length() {
326 |     keys_js.call("push", [keys[i]]) |> ignore
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     i = i + 1
    |   }
329 |   self.call("delete", [keys_js]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::delete_multiple_with_options(
    |   self : Self,
    |   keys : Array[String],
    |   options : DurableObjectPutOptions,
    | ) -> @js.Promise[Int] {
339 |   let keys_js = @js.JsArray::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let mut i = 0
    |   while i < keys.length() {
342 |     keys_js.call("push", [keys[i]]) |> ignore
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     i = i + 1
    |   }
345 |   self.call2("delete", keys_js, options.to_any()).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::delete_all(self : Self) -> @js.Promise[Unit] {
351 |   self.call0("deleteAll").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::delete_all_with_options(
    |   self : Self,
    |   options : DurableObjectPutOptions,
    | ) -> @js.Promise[Unit] {
360 |   self.call("deleteAll", [options.to_any()]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::list(self : Self) -> @js.Promise[@js.Any] {
366 |   self.call0("list").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::list_with_options(
    |   self : Self,
    |   options : DurableObjectListOptions,
    | ) -> @js.Promise[@js.Any] {
375 |   self.call("list", [options.to_any()]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::transaction(
    |   self : Self,
    |   closure : @js.Any,
    | ) -> @js.Promise[@js.Any] {
384 |   self.call("transaction", [closure]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::get_alarm(self : Self) -> @js.Promise[Int?] {
390 |   self.call0("getAlarm").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::get_alarm_with_options(
    |   self : Self,
    |   options : DurableObjectGetAlarmOptions,
    | ) -> @js.Promise[Int?] {
399 |   self.call("getAlarm", [options.to_any()]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::set_alarm(
    |   self : Self,
    |   scheduled_time : Int,
    | ) -> @js.Promise[Unit] {
408 |   self.call("setAlarm", [scheduled_time]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::set_alarm_with_options(
    |   self : Self,
    |   scheduled_time : Int,
    |   options : DurableObjectSetAlarmOptions,
    | ) -> @js.Promise[Unit] {
418 |   self.call2("setAlarm", scheduled_time, options).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::delete_alarm(self : Self) -> @js.Promise[Unit] {
424 |   self.call0("deleteAlarm").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::delete_alarm_with_options(
    |   self : Self,
    |   options : DurableObjectSetAlarmOptions,
    | ) -> @js.Promise[Unit] {
433 |   self.call("deleteAlarm", [options.to_any()]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::sync(self : Self) -> @js.Promise[Unit] {
439 |   self.call0("sync").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl @js.JsImpl for DurableObjectGetOptions with to_any(self) {
451 |   @js.from_entries_option_cast([
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ("allowConcurrency", self.allowConcurrency),
    |     ("noCache", self.noCache),
    |   ])
    | }
    …

    | pub impl @js.JsImpl for DurableObjectPutOptions with to_any(self) {
467 |   @js.from_entries_option_cast([
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ("allowConcurrency", self.allowConcurrency),
    |     ("allowUnconfirmed", self.allowUnconfirmed),
    |     ("noCache", self.noCache),
    |   ])
    | }
    …

    | pub impl @js.JsImpl for DurableObjectListOptions with to_any(self) {
489 |   @js.from_entries_option([
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ("start", self.start.map(x => x)),
    |     ("startAfter", self.startAfter.map(x => x)),
    |     ("end", self.end.map(x => x)),
    |     ("prefix", self.prefix.map(x => x)),
    |     ("reverse", self.reverse.map(x => x)),
    |     ("limit", self.limit.map(x => x)),
    |     ("allowConcurrency", self.allowConcurrency.map(x => x)),
    |     ("noCache", self.noCache.map(x => x)),
    |   ])
    | }
    …

    | pub impl @js.JsImpl for DurableObjectGetAlarmOptions with to_any(self) {
509 |   @js.from_entries_option_cast([("allowConcurrency", self.allowConcurrency)])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl @js.JsImpl for DurableObjectSetAlarmOptions with to_any(self) {
521 |   @js.from_entries_option_cast([
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ("allowConcurrency", self.allowConcurrency),
    |     ("allowUnconfirmed", self.allowUnconfirmed),
    |   ])
    | }
    …

    | pub fn DurableObjectTransaction::get(
    |   self : Self,
    |   key : String,
    | ) -> @js.Promise[@js.Any?] {
541 |   self.call("get", [key]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectTransaction::get_multiple(
    |   self : Self,
    |   keys : Array[String],
    | ) -> @js.Promise[@js.Any] {
550 |   let keys_js = @js.JsArray::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let mut i = 0
    |   while i < keys.length() {
553 |     keys_js.call("push", [keys[i]]) |> ignore
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     i = i + 1
    |   }
556 |   self.call("get", [keys_js]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectTransaction::put(
    |   self : Self,
    |   key : String,
    |   value : @js.Any,
    | ) -> @js.Promise[Unit] {
566 |   self.call2("put", key, value).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectTransaction::put_multiple(
    |   self : Self,
    |   entries : @js.Any,
    | ) -> @js.Promise[Unit] {
575 |   self.call("put", [entries]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectTransaction::delete(
    |   self : Self,
    |   key : String,
    | ) -> @js.Promise[Bool] {
584 |   self.call("delete", [key]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectTransaction::delete_multiple(
    |   self : Self,
    |   keys : Array[String],
    | ) -> @js.Promise[Int] {
593 |   let keys_js = @js.JsArray::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let mut i = 0
    |   while i < keys.length() {
596 |     keys_js.call("push", [keys[i]]) |> ignore
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     i = i + 1
    |   }
599 |   self.call("delete", [keys_js]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectTransaction::delete_all(self : Self) -> @js.Promise[Unit] {
605 |   self.call0("deleteAll").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectTransaction::list(self : Self) -> @js.Promise[@js.Any] {
611 |   self.call0("list").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectTransaction::list_with_options(
    |   self : Self,
    |   options : DurableObjectListOptions,
    | ) -> @js.Promise[@js.Any] {
620 |   self.call("list", [options.to_any()]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectTransaction::rollback(self : Self) -> Unit {
626 |   self.call0("rollback").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectTransaction::get_alarm(self : Self) -> @js.Promise[Int?] {
632 |   self.call0("getAlarm").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectTransaction::set_alarm(
    |   self : Self,
    |   scheduled_time : Int,
    | ) -> @js.Promise[Unit] {
641 |   self.call("setAlarm", [scheduled_time]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectTransaction::delete_alarm(self : Self) -> @js.Promise[Unit] {
647 |   self.call0("deleteAlarm").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

12 uncovered line(s) in src/cloudflare/kv.mbt:

    | pub fn KVNamespace::get_array_buffer(
    |   self : Self,
    |   key : String,
    | ) -> @js.Promise[@js.Any?] {
 29 |   let opts_js = @js.from_entries([("type", "arrayBuffer")])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   self.call2("get", key, opts_js).cast()
    | }
    …

    | pub fn KVNamespace::get_json(
    |   self : Self,
    |   key : String,
    | ) -> @js.Promise[@js.Any?] {
 39 |   let opts_js = @js.from_entries([("type", "json")])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   self.call2("get", key, opts_js).cast()
    | }
    …

    | pub fn KVNamespace::get_stream(
    |   self : Self,
    |   key : String,
    | ) -> @js.Promise[@js.Any?] {
 49 |   let opts_js = @js.from_entries([("type", "stream")])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   self.call2("get", key, opts_js).cast()
    | }
    …

    | pub fn KVNamespace::get_with_metadata(
    |   self : Self,
    |   key : String,
    |   options : KVGetOptions?,
    | ) -> @js.Promise[KVValueWithMetadata] {
 60 |   match options {
    |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => {
    |       let opts_js = @js.from_entries([("type", "text")])
    |       self.call2("getWithMetadata", key, opts_js).cast()
    |     }
 65 |     Some(opts) => self.call2("getWithMetadata", key, opts).cast()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub fn KVNamespace::put(
    |   self : Self,
    |   key : String,
    |   value : String,
    |   options : KVPutOptions?,
    | ) -> @js.Promise[Unit] {
 77 |   match options {
    |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => self.call2("put", key, value).cast()
    |     Some(opts) => self.call("put", [key, value, opts]).cast()
    |   }
    | }
    …

    | pub fn KVNamespace::put_with_metadata(
    |   self : Self,
    |   key : String,
    |   value : String,
    |   metadata : @js.Any,
    | ) -> @js.Promise[Unit] {
 91 |   let opts_js = @js.from_entries([("metadata", metadata)])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   self.call("put", [key, value, opts_js]).cast()
    | }
    …

    | pub fn KVNamespace::delete(self : Self, key : String) -> @js.Promise[Unit] {
 98 |   self.call("delete", [key]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn KVNamespace::list(
    |   self : Self,
    |   options : KVListOptions?,
    | ) -> @js.Promise[KVListResult] {
107 |   match options {
    |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => self.call0("list").cast()
    |     Some(opts) => self.call("list", [opts.to_any()]).cast()
    |   }
    | }
    …

    | pub impl @js.JsImpl for KVGetOptions with to_any(self) {
122 |   @js.from_entries_option([
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ("type", self.type_.map(x => x)),
    |     ("cacheTtl", self.cacheTtl.map(x => x)),
    |   ])
    | }
    …

    | pub impl @js.JsImpl for KVPutOptions with to_any(self) {
138 |   @js.from_entries_option([
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ("expiration", self.expiration.map(x => x)),
    |     ("expirationTtl", self.expirationTtl.map(x => x)),
    |     ("metadata", self.metadata.map(x => x)),
    |   ])
    | }
    …

    | pub impl @js.JsImpl for KVListOptions with to_any(self) {
155 |   @js.from_entries_option([
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ("prefix", self.prefix.map(x => x)),
    |     ("limit", self.limit.map(x => x)),
    |     ("cursor", self.cursor.map(x => x)),
    |   ])
    | }
    …

53 uncovered line(s) in src/cloudflare/r2.mbt:

    | pub fn R2Bucket::get(self : Self, key : String) -> @js.Promise[R2Object?] {
 13 |   self.call("get", [key]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Bucket::get_with_options(
    |   self : Self,
    |   key : String,
    |   options : R2GetOptions,
    | ) -> @js.Promise[R2Object?] {
 23 |   self.call2("get", key, options).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Bucket::head(self : Self, key : String) -> @js.Promise[R2Object?] {
 29 |   self.call("head", [key]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Bucket::put(
    |   self : Self,
    |   key : String,
    |   value : @js.Any,
    | ) -> @js.Promise[R2Object] {
 39 |   self.call2("put", key, value).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Bucket::put_with_options(
    |   self : Self,
    |   key : String,
    |   value : @js.Any,
    |   options : R2PutOptions,
    | ) -> @js.Promise[R2Object] {
 50 |   self.call("put", [key, value, options]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Bucket::delete(self : Self, key : String) -> @js.Promise[Unit] {
 56 |   self.call("delete", [key]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Bucket::delete_multiple(
    |   self : Self,
    |   keys : Array[String],
    | ) -> @js.Promise[Unit] {
 65 |   let keys_js = @js.JsArray::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let mut i = 0
    |   while i < keys.length() {
 68 |     keys_js.call("push", [keys[i]]) |> ignore
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     i = i + 1
    |   }
 71 |   self.call("delete", [keys_js]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Bucket::list(self : Self) -> @js.Promise[R2Objects] {
 77 |   self.call0("list").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Bucket::list_with_options(
    |   self : Self,
    |   options : R2ListOptions,
    | ) -> @js.Promise[R2Objects] {
 86 |   self.call("list", [options]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Bucket::create_multipart_upload(
    |   self : Self,
    |   key : String,
    | ) -> @js.Promise[R2MultipartUpload] {
 95 |   self.call("createMultipartUpload", [key]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Bucket::create_multipart_upload_with_options(
    |   self : Self,
    |   key : String,
    |   options : R2PutOptions,
    | ) -> @js.Promise[R2MultipartUpload] {
105 |   self.call2("createMultipartUpload", key, options).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Bucket::resume_multipart_upload(
    |   self : Self,
    |   key : String,
    |   upload_id : String,
    | ) -> R2MultipartUpload {
115 |   self.call2("resumeMultipartUpload", key, upload_id).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl @js.JsImpl for R2GetOptions with to_any(self) {
127 |   let onlyIf_js : @js.Any? = match self.onlyIf {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(cond) =>
129 |       Some(
    |       ^^^^^ 	<-- UNCOVERED
    |         @js.from_entries_option([
    |           ("etagMatches", cond.etagMatches.map(fn(x) { x as &@js.JsImpl })),
    |           (
    |             "etagDoesNotMatch",
134 |             cond.etagDoesNotMatch.map(fn(x) { x as &@js.JsImpl }),
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           ),
    |           (
    |             "uploadedBefore",
138 |             cond.uploadedBefore.map(fn(x) { x as &@js.JsImpl }),
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           ),
140 |           ("uploadedAfter", cond.uploadedAfter.map(fn(x) { x as &@js.JsImpl })),
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         ]),
    |       )
143 |     None => None
    |     ^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
145 |   let range_js : @js.Any? = match self.range {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(r) =>
147 |       Some(
    |       ^^^^^ 	<-- UNCOVERED
    |         @js.from_entries_option([
    |           ("offset", r.offset.map(fn(x) { x as &@js.JsImpl })),
    |           ("length", r.length.map(fn(x) { x as &@js.JsImpl })),
    |           ("suffix", r.suffix.map(fn(x) { x as &@js.JsImpl })),
    |         ]),
    |       )
154 |     None => None
    |     ^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
156 |   @js.from_entries_option([
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ("onlyIf", onlyIf_js.map(fn(x) { x as &@js.JsImpl })),
    |     ("range", range_js.map(fn(x) { x as &@js.JsImpl })),
    |   ])
    | }
    …

    | pub impl @js.JsImpl for R2PutOptions with to_any(self) {
193 |   let httpMetadata_js : @js.Any? = match self.httpMetadata {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(meta) => Some(meta.to_any())
    |     None => None
    |   }
197 |   @js.from_entries_option([
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ("httpMetadata", httpMetadata_js.map(fn(x) { x as &@js.JsImpl })),
    |     ("customMetadata", self.customMetadata.map(fn(x) { x as &@js.JsImpl })),
    |     ("md5", self.md5.map(fn(x) { x as &@js.JsImpl })),
    |     ("sha1", self.sha1.map(fn(x) { x as &@js.JsImpl })),
    |     ("sha256", self.sha256.map(fn(x) { x as &@js.JsImpl })),
    |     ("sha384", self.sha384.map(fn(x) { x as &@js.JsImpl })),
    |     ("sha512", self.sha512.map(fn(x) { x as &@js.JsImpl })),
    |   ])
    | }
    …

    | pub impl @js.JsImpl for R2HttpMetadata with to_any(self) {
221 |   @js.from_entries_option([
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ("contentType", self.contentType.map(fn(x) { x as &@js.JsImpl })),
    |     ("contentLanguage", self.contentLanguage.map(fn(x) { x as &@js.JsImpl })),
    |     (
    |       "contentDisposition",
226 |       self.contentDisposition.map(fn(x) { x as &@js.JsImpl }),
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ),
228 |     ("contentEncoding", self.contentEncoding.map(fn(x) { x as &@js.JsImpl })),
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ("cacheControl", self.cacheControl.map(fn(x) { x as &@js.JsImpl })),
    |     ("cacheExpiry", self.cacheExpiry.map(fn(x) { x as &@js.JsImpl })),
    |   ])
    | }
    …

    | pub impl @js.JsImpl for R2ListOptions with to_any(self) {
247 |   let include_js : @js.Any? = match self.include_ {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(inc) => Some(@js.from_array(inc))
    |     None => None
    |   }
251 |   @js.from_entries_option([
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ("limit", self.limit.map(fn(x) { x as &@js.JsImpl })),
    |     ("prefix", self.prefix.map(fn(x) { x as &@js.JsImpl })),
    |     ("cursor", self.cursor.map(fn(x) { x as &@js.JsImpl })),
    |     ("delimiter", self.delimiter.map(fn(x) { x as &@js.JsImpl })),
    |     ("startAfter", self.startAfter.map(fn(x) { x as &@js.JsImpl })),
    |     ("include", include_js.map(fn(x) { x as &@js.JsImpl })),
    |   ])
    | }
    …

    | pub fn R2Object::key(self : Self) -> String {
272 |   self.get("key").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Object::version(self : Self) -> String {
278 |   self.get("version").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Object::size(self : Self) -> Int {
284 |   self.get("size").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Object::etag(self : Self) -> String {
290 |   self.get("etag").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Object::http_metadata(self : Self) -> @js.Any {
296 |   self.get("httpMetadata")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Object::custom_metadata(self : Self) -> @js.Any {
302 |   self.get("customMetadata")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Object::uploaded(self : Self) -> @js.Any {
308 |   self.get("uploaded")
    |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Object::array_buffer(self : Self) -> @js.Promise[@js.ArrayBuffer] {
314 |   self.call0("arrayBuffer").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Object::text(self : Self) -> @js.Promise[String] {
320 |   self.call0("text").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Object::json(self : Self) -> @js.Promise[@js.Any] {
326 |   self.call0("json").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Object::blob(self : Self) -> @js.Promise[@blob.Blob] {
332 |   self.call0("blob").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Object::body(self : Self) -> @streams.ReadableStream {
338 |   self.get("body").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Object::body_used(self : Self) -> Bool {
344 |   self.get("bodyUsed").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Object::write_http_metadata(self : Self, headers : @js.Any) -> Unit {
350 |   self.call("writeHttpMetadata", [headers]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2MultipartUpload::key(self : Self) -> String {
376 |   self.get("key").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2MultipartUpload::uploadId(self : Self) -> String {
382 |   self.get("uploadId").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2MultipartUpload::upload_part(
    |   self : Self,
    |   part_number : Int,
    |   value : @js.Any,
    | ) -> @js.Promise[R2UploadedPart] {
392 |   self.call2("uploadPart", part_number, value).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2MultipartUpload::abort(self : Self) -> @js.Promise[Unit] {
398 |   self.call0("abort").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2MultipartUpload::complete(
    |   self : Self,
    |   parts : Array[R2UploadedPart],
    | ) -> @js.Promise[R2Object] {
407 |   let parts_js = @js.JsArray::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let mut i = 0
    |   while i < parts.length() {
410 |     parts_js.call("push", [parts[i]]) |> ignore
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     i = i + 1
    |   }
413 |   self.call("complete", [parts_js]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl @js.JsImpl for R2UploadedPart with to_any(self) {
425 |   @js.from_entries([("partNumber", self.partNumber), ("etag", self.etag)])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

15 uncovered line(s) in src/convert.mbt:

    | pub impl ToJson for Any with to_json(self) -> Json {
215 |   if is_nullish(self) {
    |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     return null
    |   }
218 |   match typeof_(self) {
    |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     "boolean" => {
    |       // let v : Bool = identity(self)
221 |       let v : Bool = identity(self)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       return v.to_json()
    |     }
224 |     "number" => {
    |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let v : Double = identity(self)
    |       return v.to_json()
    |     }
228 |     "string" => {
    |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let v : String = identity(self)
    |       return v.to_json()
    |     }
232 |     _ => ()
    |     ^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if is_array(self) {
235 |     let len : Int = self.call0("length") |> identity
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let arr : Array[Json] = []
237 |     for i = 0; i < len; i = i + 1 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let v = self.get(i.to_string())
    |       arr.push(v.to_json())
    |     }
241 |     return arr.to_json()
    |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if typeof_(self) == "object" {
244 |     let out : Map[String, Json] = {}
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let keys = self |> ffi_object_keys()
    |     for k in keys {
247 |       let v = self.get(k)
    |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       out[k] = v.to_json()
    |     }
250 |     return out.to_json()
    |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   return {}
    | }
    …

    | pub impl JsImpl for Json with to_any(self) -> Any {
    |   match self {
    |     Null => null_()
    |     String(s) => any(s)
    |     Number(n, ..) => any(n)
261 |     True => any(true)
    |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     False => any(false)
    |     Object(o) => {
    |       let obj = Object::new()
    |       for k, v in o {
    |         let v : Any = JsImpl::to_any(v)
    |         obj.set(k, v)
    |       }
    |       obj.to_any()
    |     }
    |     Array(a) => {
    |       let arr = JsArray::new()
    |       for v in a {
    |         let v : Any = JsImpl::to_any(v)
    |         arr.call("push", [v]) |> ignore
    |       }
    |       arr.to_any()
    |     }
    |   }
    | }
    …

    | pub fn[T] log(v : T) -> Unit {
434 |   ffi_console_log([v |> identity]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[T, U] log2(a : T, b : U) -> Unit {
440 |   ffi_console_log([a |> identity, b |> identity]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

73 uncovered line(s) in src/deno/_tests/main.mbt:

    | fn main {
 17 |   let d = @deno.deno()
    |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | 
    |   // Test environment variables
 20 |   d.test_async("environment variables", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     d.env_set("TEST_VAR", "hello")
    |     let value = d.env_get("TEST_VAR")
    |     assert_eq(value, Some("hello"))
    |     d.env_delete("TEST_VAR")
    |     let deleted = d.env_get("TEST_VAR")
    |     assert_eq(deleted, None)
    |   })
    | 
    |   // Test current directory
 30 |   d.test_async("current directory", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let cwd = d.cwd()
    |     assert_true(cwd.length() > 0)
    |   })
    | 
    |   // Test command line arguments
 36 |   d.test_async("command line args", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let args = d.args()
    |     // args will contain test runner arguments
 39 |     assert_true(args.length() >= 0)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   })
    | 
    |   // Test file operations
 43 |   d.test_async("file read/write text", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let test_file = "test_deno_text.txt"
    |     let content = "Hello, Deno from MoonBit!"
 46 |     d.writeTextFile(test_file, content).wait()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let read_content = d.readTextFile(test_file).wait()
    |     assert_eq(read_content, content)
    |     d.remove(test_file).wait()
    |   })
    | 
    |   // Test directory operations
 53 |   d.test_async("directory operations", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let test_dir = "test_deno_dir"
    |     let nested_dir = "test_deno_dir/nested"
 56 |     d.mkdir(test_dir).wait()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     d.mkdir(nested_dir, recursive=true).wait()
    | 
    |     // Clean up
 60 |     d.remove(test_dir, recursive=true).wait()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   })
    | 
    |   // Test permissions (this will work with --allow-all flag)
 64 |   d.test_async("permissions query", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let status = d.permissions_query("read").wait()
    |     let state = status.state()
    |     // With --allow-all, should be "granted"
 68 |     assert_true(state == "granted" || state == "prompt" || state == "denied")
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   })
    | 
    |   // Test multiple file operations
 72 |   d.test_async("multiple files", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     d.writeTextFile("test1.txt", "content1").wait()
    |     d.writeTextFile("test2.txt", "content2").wait()
    |     let c1 = d.readTextFile("test1.txt").wait()
    |     let c2 = d.readTextFile("test2.txt").wait()
    |     assert_eq(c1, "content1")
    |     assert_eq(c2, "content2")
    |     d.remove("test1.txt").wait()
    |     d.remove("test2.txt").wait()
    |   })
    | 
    |   // Test env_toObject
 84 |   d.test_async("env toObject", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     d.env_set("DENO_TEST_1", "value1")
    |     d.env_set("DENO_TEST_2", "value2")
    |     let env_obj = d.env_toObject()
    |     // env_obj contains all environment variables
 89 |     assert_true(@js.typeof_(env_obj) == "object")
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     d.env_delete("DENO_TEST_1")
    |     d.env_delete("DENO_TEST_2")
    |   })
    | 
    |   // Example of synchronous test
 95 |   d.test_("synchronous test", fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let cwd = d.cwd()
    |     // Just check it returns something
 98 |     ignore(cwd)
    |     ^^^^^^^^^^^ 	<-- UNCOVERED
    |   })
    | 
    |   // Test process information
102 |   d.test_async("process info", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let pid = d.pid()
    |     assert_true(pid > 0)
    |     let ppid = d.ppid()
    |     assert_true(ppid > 0)
    |     let os = d.build_os()
    |     assert_true(os.length() > 0)
    |     let arch = d.build_arch()
    |     assert_true(arch.length() > 0)
    |   })
    | 
    |   // Test file rename
114 |   d.test_async("file rename", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let old_name = "test_rename_old.txt"
    |     let new_name = "test_rename_new.txt"
117 |     d.writeTextFile(old_name, "rename test").wait()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     d.rename(old_name, new_name).wait()
    |     let content = d.readTextFile(new_name).wait()
    |     assert_eq(content, "rename test")
    |     d.remove(new_name).wait()
    |   })
    | 
    |   // Test file copy
125 |   d.test_async("file copy", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let source = "test_copy_source.txt"
    |     let dest = "test_copy_dest.txt"
128 |     d.writeTextFile(source, "copy test").wait()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     d.copyFile(source, dest).wait()
    |     let content = d.readTextFile(dest).wait()
    |     assert_eq(content, "copy test")
    |     d.remove(source).wait()
    |     d.remove(dest).wait()
    |   })
    | 
    |   // Test file stat
137 |   d.test_async("file stat", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let test_file = "test_stat.txt"
    |     d.writeTextFile(test_file, "stat test").wait()
    |     let stat = d.stat(test_file).wait()
    | 
    |     // Check that stat returns an object
143 |     assert_true(@js.typeof_(stat) == "object")
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     d.remove(test_file).wait()
    |   })
    | 
    |   // Test realPath
148 |   d.test_async("real path", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let _cwd = d.cwd()
    |     let real = d.realPath(".").wait()
    | 
    |     // realPath should return an absolute path
153 |     assert_true(real.length() > 0)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   })
    | 
    |   // Test chmod (Unix only, might fail on Windows)
157 |   d.test_async("chmod", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let test_file = "test_chmod.txt"
    |     d.writeTextFile(test_file, "chmod test").wait()
    | 
    |     // Try to change permissions (might not work on all platforms)
162 |     let result = d.chmod(test_file, 0o644).wait() catch { _ => () }
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ignore(result)
    |     d.remove(test_file).wait()
    |   })
    | 
    |   // Test symlink (might not work on all platforms/permissions)
168 |   d.test_async("symlink", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let target = "test_symlink_target.txt"
    |     let link = "test_symlink_link.txt"
171 |     d.writeTextFile(target, "symlink test").wait()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | 
    |     // Try to create symlink (might fail without proper permissions)
174 |     let result = d.symlink(target, link).wait() catch { _ => () }
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ignore(result)
    | 
    |     // Clean up - ignore errors if symlink wasn't created
178 |     let _ = d.remove(link).wait() catch { _ => () }
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     d.remove(target).wait()
    |   })
    | 
    |   // Test binary file operations
183 |   d.test_async("binary file read/write", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let test_file = "test_binary.bin"
    | 
    |     // Create binary data using TextEncoder
187 |     let encoder = new_text_encoder()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let arr = encoder.call("encode", [@js.any("binary test data")])
    |     d.writeFile(test_file, arr).wait()
    |     let data = d.readFile(test_file).wait()
    |     assert_true(@js.typeof_(data) == "object")
    |     d.remove(test_file).wait()
    |   })
    | 
    |   // Test temporary directory
196 |   d.test_async("make temp dir", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let temp_dir = d.makeTempDir(prefix="test_").wait()
    |     assert_true(temp_dir.length() > 0)
    | 
    |     // Clean up
201 |     d.remove(temp_dir, recursive=true).wait()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   })
    | 
    |   // Test temporary file
205 |   d.test_async("make temp file", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let temp_file = d.makeTempFile(prefix="test_").wait()
    |     assert_true(temp_file.length() > 0)
    | 
    |     // Write some data
210 |     d.writeTextFile(temp_file, "temp data").wait()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let content = d.readTextFile(temp_file).wait()
    |     assert_eq(content, "temp data")
    | 
    |     // Clean up
215 |     d.remove(temp_file).wait()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   })
    | 
    |   // Test truncate
219 |   d.test_async("truncate file", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let test_file = "test_truncate.txt"
    |     d.writeTextFile(test_file, "Hello, World! This is a long text.").wait()
    |     d.truncate(test_file, 5).wait()
    |     let content = d.readTextFile(test_file).wait()
    |     assert_eq(content, "Hello")
    |     d.remove(test_file).wait()
    |   })
    | 
    |   // Test system info
229 |   d.test_async("system information", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let hostname = d.hostname()
    |     assert_true(hostname.length() > 0)
    |     let os_release = d.osRelease()
    |     assert_true(os_release.length() > 0)
    |     let uptime = d.osUptime()
    |     assert_true(uptime >= 0)
    |   })
    | 
    |   // Test load average (Unix only, might fail on Windows)
239 |   d.test_async("load average", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let loadavg = d.loadavg()
    |     // Should return array of 3 numbers on Unix, empty on Windows
242 |     assert_true(loadavg.length() == 3 || loadavg.length() == 0)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   })
    | 
    |   // Test network interfaces
246 |   d.test_async("network interfaces", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let interfaces = d.networkInterfaces()
    |     assert_true(@js.typeof_(interfaces) == "object")
    |   })
    | 
    |   // Test system memory info
252 |   d.test_async("system memory info", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let mem_info = d.systemMemoryInfo()
    |     assert_true(@js.typeof_(mem_info) == "object")
    |   })
    | 
    |   // Test uid/gid (Unix only)
258 |   d.test_async("uid and gid", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let uid = d.uid()
    |     let gid = d.gid()
    |     // On Unix, these should be Some(Int), on Windows None
    |     // Just check they don't crash
263 |     ignore(uid)
    |     ^^^^^^^^^^^ 	<-- UNCOVERED
    |     ignore(gid)
    |   })
    | 
    |   // Test high resolution time
268 |   d.test_async("high resolution time", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let t1 = d.now()
    |     // Just verify it returns a number
271 |     assert_true(t1 >= 0.0)
    |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   })
    | 
    |   // Test file handle operations
275 |   d.test_async("file handle open/write/read", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let test_file = "test_handle.txt"
    | 
    |     // Create and write using file handle
279 |     let file = d.create(test_file).wait()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let encoder = new_text_encoder()
    |     let data = encoder.call("encode", [@js.any("file handle test")])
    |     let written = file.write(data).wait()
    |     assert_true(written > 0)
    |     file.close()
    | 
    |     // Read back using file handle
287 |     let read_file = d.open(test_file, read=true).wait()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let buffer = new_uint8array(100)
    |     let read_bytes = read_file.read(buffer).wait()
    |     assert_true(read_bytes > 0)
    |     read_file.close()
    | 
    |     // Clean up
294 |     d.remove(test_file).wait()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   })
    | 
    |   // Test permissions request
298 |   d.test_async("permissions request", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     // Query read permission
300 |     let status = d.query_permission("read").wait()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     assert_true(@js.typeof_(status) == "object")
    |   })
    | 
    |   // Test DNS resolution
305 |   d.test_async("dns resolution", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     // Try to resolve localhost
307 |     let result = d.resolveDns("localhost", "A").wait() catch {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         _ =>
    |           // DNS resolution might fail in some environments
310 |           return
    |           ^^^^^^ 	<-- UNCOVERED
    |       }
312 |     ignore(result)
    |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   })
    | 
    |   // Test file seek
316 |   d.test_async("file seek", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let test_file = "test_seek.txt"
    | 
    |     // Create file with content
320 |     d.writeTextFile(test_file, "0123456789").wait()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | 
    |     // Open file and seek
323 |     let file = d.open(test_file, read=true).wait()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let pos = file.seek(5, 0).wait() // SEEK_SET = 0
    |     assert_eq(pos, 5)
    |     file.close()
    |     d.remove(test_file).wait()
    |   })
    | 
    |   // Test multiple file handles
331 |   d.test_async("multiple file handles", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let file1 = "test_handle1.txt"
    |     let file2 = "test_handle2.txt"
334 |     d.writeTextFile(file1, "file1 content").wait()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     d.writeTextFile(file2, "file2 content").wait()
    |     let f1 = d.open(file1, read=true).wait()
    |     let f2 = d.open(file2, read=true).wait()
    |     f1.close()
    |     f2.close()
    |     d.remove(file1).wait()
    |     d.remove(file2).wait()
    |   })
    | 
    |   // Test lstat (doesn't throw on non-existent files)
345 |   d.test_async("lstat", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let test_file = "test_lstat.txt"
    |     d.writeTextFile(test_file, "lstat test").wait()
    |     let stat = d.lstat(test_file).wait()
    |     assert_true(@js.typeof_(stat) == "object")
    |     d.remove(test_file).wait()
    |   })
    | 
    |   // Test readLink (might not work without symlinks)
354 |   d.test_async("readLink", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let target = "test_readlink_target.txt"
    |     d.writeTextFile(target, "readlink test").wait()
    | 
    |     // Just verify we can stat the file (readLink requires symlinks which may not work)
359 |     let stat = d.stat(target).wait()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ignore(stat)
    |     d.remove(target).wait()
    |   })
    | 
    |   // Test readDir (directory listing)
365 |   d.test_async("readDir", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let test_dir = "test_readdir"
    |     d.mkdir(test_dir).wait()
    |     d.writeTextFile(test_dir + "/file1.txt", "content1").wait()
    |     d.writeTextFile(test_dir + "/file2.txt", "content2").wait()
    |     let entries = d.readDir(test_dir)
    |     assert_true(@js.typeof_(entries) == "object")
    |     d.remove(test_dir, recursive=true).wait()
    |   })
    | 
    |   // Test multiple temp files
376 |   d.test_async("multiple temp files", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let temp1 = d.makeTempFile(prefix="test1_").wait()
    |     let temp2 = d.makeTempFile(prefix="test2_").wait()
    |     assert_true(temp1 != temp2)
    |     d.writeTextFile(temp1, "temp1").wait()
    |     d.writeTextFile(temp2, "temp2").wait()
    |     let content1 = d.readTextFile(temp1).wait()
    |     let content2 = d.readTextFile(temp2).wait()
    |     assert_eq(content1, "temp1")
    |     assert_eq(content2, "temp2")
    |     d.remove(temp1).wait()
    |     d.remove(temp2).wait()
    |   })
    | 
    |   // Test nested directories
391 |   d.test_async("nested directories", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let base_dir = "test_nested"
    |     let nested_path = base_dir + "/level1/level2/level3"
394 |     d.mkdir(nested_path, recursive=true).wait()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let test_file = nested_path + "/deep.txt"
396 |     d.writeTextFile(test_file, "deep content").wait()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let content = d.readTextFile(test_file).wait()
    |     assert_eq(content, "deep content")
    |     d.remove(base_dir, recursive=true).wait()
    |   })
    | 
    |   // Test file overwrite
403 |   d.test_async("file overwrite", async fn(_ctx) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let test_file = "test_overwrite.txt"
    |     d.writeTextFile(test_file, "original").wait()
    |     let content1 = d.readTextFile(test_file).wait()
    |     assert_eq(content1, "original")
    |     d.writeTextFile(test_file, "updated").wait()
    |     let content2 = d.readTextFile(test_file).wait()
    |     assert_eq(content2, "updated")
    |     d.remove(test_file).wait()
    |   })
    | }
    …

66 uncovered line(s) in src/deno/deno.mbt:

    | pub fn Deno::env_get(self : Deno, key : String) -> String? {
 22 |   self.get("env").call("get", [@js.any(key)]).cast() |> @js.identity_option
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::env_set(self : Deno, key : String, value : String) -> Unit {
 28 |   self.get("env").call("set", [@js.any(key), @js.any(value)]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::env_delete(self : Deno, key : String) -> Unit {
 34 |   self.get("env").call("delete", [@js.any(key)]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::env_toObject(self : Deno) -> @js.Any {
 40 |   self.get("env").call("toObject", [])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::cwd(self : Deno) -> String {
 46 |   self.call("cwd", []).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::exit(self : Deno, code? : Int) -> Unit {
 52 |   match code {
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(c) => self.call("exit", [@js.any(c)]) |> ignore
    |     None => self.call("exit", []) |> ignore
    |   }
    | }
    …

    | pub fn Deno::args(self : Deno) -> Array[String] {
 63 |   self.get("args").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::pid(self : Deno) -> Int {
 69 |   self.get("pid").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::ppid(self : Deno) -> Int {
 75 |   self.get("ppid").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::build_os(self : Deno) -> String {
 81 |   self.get("build").get("os").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::build_arch(self : Deno) -> String {
 87 |   self.get("build").get("arch").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::stdin_read(self : Deno) -> @js.Promise[@js.Any] {
 93 |   self.get("stdin").call("read", []).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::stdout_write(self : Deno, data : @js.Any) -> @js.Promise[Int] {
 99 |   self.get("stdout").call("write", [data]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::stderr_write(self : Deno, data : @js.Any) -> @js.Promise[Int] {
105 |   self.get("stderr").call("write", [data]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::readTextFile(self : Deno, path : String) -> @js.Promise[String] {
113 |   self.call("readTextFile", [@js.any(path)]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::writeTextFile(
    |   self : Deno,
    |   path : String,
    |   data : String,
    | ) -> @js.Promise[Unit] {
123 |   self.call("writeTextFile", [@js.any(path), @js.any(data)]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::readFile(self : Deno, path : String) -> @js.Promise[@js.Any] {
129 |   self.call("readFile", [@js.any(path)]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::writeFile(
    |   self : Deno,
    |   path : String,
    |   data : @js.Any,
    | ) -> @js.Promise[Unit] {
139 |   self.call("writeFile", [@js.any(path), data]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::remove(
    |   self : Deno,
    |   path : String,
    |   recursive? : Bool,
    | ) -> @js.Promise[Unit] {
149 |   match recursive {
    |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(r) =>
151 |       self
    |       ^^^^ 	<-- UNCOVERED
    |       .call("remove", [
    |         @js.any(path),
    |         @js.from_entries_option_cast([("recursive", Some(r))]),
    |       ])
156 |       .cast()
    |       ^^^^^^^ 	<-- UNCOVERED
    |     None => self.call("remove", [@js.any(path)]).cast()
    |   }
    | }
    …

    | pub fn Deno::mkdir(
    |   self : Deno,
    |   path : String,
    |   recursive? : Bool,
    | ) -> @js.Promise[Unit] {
168 |   match recursive {
    |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(r) =>
170 |       self
    |       ^^^^ 	<-- UNCOVERED
    |       .call("mkdir", [
    |         @js.any(path),
    |         @js.from_entries_option_cast([("recursive", Some(r))]),
    |       ])
175 |       .cast()
    |       ^^^^^^^ 	<-- UNCOVERED
    |     None => self.call("mkdir", [@js.any(path)]).cast()
    |   }
    | }
    …

    | pub fn Deno::readDir(self : Deno, path : String) -> @js.Any {
183 |   self.call("readDir", [@js.any(path)])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::rename(
    |   self : Deno,
    |   oldpath : String,
    |   newpath : String,
    | ) -> @js.Promise[Unit] {
193 |   self.call("rename", [@js.any(oldpath), @js.any(newpath)]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::copyFile(
    |   self : Deno,
    |   from : String,
    |   to : String,
    | ) -> @js.Promise[Unit] {
203 |   self.call("copyFile", [@js.any(from), @js.any(to)]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::stat(self : Deno, path : String) -> @js.Promise[@js.Any] {
209 |   self.call("stat", [@js.any(path)]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::lstat(self : Deno, path : String) -> @js.Promise[@js.Any] {
215 |   self.call("lstat", [@js.any(path)]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::readLink(self : Deno, path : String) -> @js.Promise[String] {
221 |   self.call("readLink", [@js.any(path)]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::symlink(
    |   self : Deno,
    |   target : String,
    |   path : String,
    | ) -> @js.Promise[Unit] {
231 |   self.call("symlink", [@js.any(target), @js.any(path)]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::chmod(self : Deno, path : String, mode : Int) -> @js.Promise[Unit] {
237 |   self.call("chmod", [@js.any(path), @js.any(mode)]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::realPath(self : Deno, path : String) -> @js.Promise[String] {
243 |   self.call("realPath", [@js.any(path)]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::truncate(
    |   self : Deno,
    |   name : String,
    |   len : Int,
    | ) -> @js.Promise[Unit] {
253 |   self.call("truncate", [@js.any(name), @js.any(len)]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::makeTempDir(self : Deno, prefix? : String) -> @js.Promise[String] {
259 |   match prefix {
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(p) =>
261 |       self
    |       ^^^^ 	<-- UNCOVERED
    |       .call("makeTempDir", [@js.from_entries_option_cast([("prefix", Some(p))])])
    |       .cast()
    |     None => self.call("makeTempDir", []).cast()
    |   }
    | }
    …

    | pub fn Deno::makeTempFile(self : Deno, prefix? : String) -> @js.Promise[String] {
271 |   match prefix {
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(p) =>
273 |       self
    |       ^^^^ 	<-- UNCOVERED
    |       .call("makeTempFile", [
    |         @js.from_entries_option_cast([("prefix", Some(p))]),
    |       ])
277 |       .cast()
    |       ^^^^^^^ 	<-- UNCOVERED
    |     None => self.call("makeTempFile", []).cast()
    |   }
    | }
    …

    | pub fn Deno::hostname(self : Deno) -> String {
285 |   self.call("hostname", []).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::osRelease(self : Deno) -> String {
291 |   self.call("osRelease", []).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::osUptime(self : Deno) -> Int {
297 |   self.call("osUptime", []).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::loadavg(self : Deno) -> Array[Double] {
305 |   self.call("loadavg", []).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::networkInterfaces(self : Deno) -> @js.Any {
311 |   self.call("networkInterfaces", [])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::systemMemoryInfo(self : Deno) -> @js.Any {
317 |   self.call("systemMemoryInfo", [])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::uid(self : Deno) -> Int? {
323 |   self.call("uid", []).cast() |> @js.identity_option
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::gid(self : Deno) -> Int? {
329 |   self.call("gid", []).cast() |> @js.identity_option
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::connect(
    |   self : Self,
    |   hostname : String,
    |   port : Int,
    | ) -> @js.Promise[@js.Any] {
341 |   self
    |   ^^^^ 	<-- UNCOVERED
    |   .call("connect", [@js.from_entries([("hostname", hostname), ("port", port)])])
    |   .cast()
    | }
    …

    | pub fn Deno::listen(self : Deno, hostname : String, port : Int) -> @js.Any {
349 |   self.call("listen", [
    |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     @js.from_entries([("hostname", hostname), ("port", port)]),
    |   ])
    | }
    …

    | pub fn Deno::resolveDns(
    |   self : Deno,
    |   query : String,
    |   recordType : String,
    | ) -> @js.Promise[@js.Any] {
361 |   self.call("resolveDns", [@js.any(query), @js.any(recordType)]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::serve(self : Deno, port : Int, handler : @js.Any) -> @js.Any {
369 |   self.call1("serve", @js.from_entries([("port", port), ("handler", handler)]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::request_permission(
    |   self : Self,
    |   name : String,
    | ) -> @js.Promise[@js.Any] {
380 |   self
    |   ^^^^ 	<-- UNCOVERED
    |   .get("permissions")
    |   .call1("request", @js.from_entries([("name", name)]))
    |   .cast()
    | }
    …

    | pub fn Deno::query_permission(
    |   self : Deno,
    |   name : String,
    | ) -> @js.Promise[@js.Any] {
392 |   self
    |   ^^^^ 	<-- UNCOVERED
    |   .get("permissions")
    |   .call1("query", @js.from_entries([("name", name)]))
    |   .cast()
    | }
    …

    | pub fn Deno::revoke_permission(
    |   self : Deno,
    |   name : String,
    | ) -> @js.Promise[@js.Any] {
404 |   self
    |   ^^^^ 	<-- UNCOVERED
    |   .get("permissions")
    |   .call1("revoke", @js.from_entries([("name", name)]))
    |   .cast()
    | }
    …

    | pub fn Deno::open(
    |   self : Deno,
    |   path : String,
    |   create? : Bool,
    |   write? : Bool,
    |   read? : Bool,
    | ) -> @js.Promise[FsFile] {
435 |   self
    |   ^^^^ 	<-- UNCOVERED
    |   .call("open", [
    |     @js.any(path),
    |     @js.from_entries_option_cast([
    |       ("create", create),
    |       ("write", write),
    |       ("read", read),
    |     ]),
    |   ])
444 |   .cast()
    |   ^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::create(self : Deno, path : String) -> @js.Promise[FsFile] {
450 |   self.call("create", [@js.any(path)]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn FsFile::close(self : FsFile) -> Unit {
456 |   self.call("close", []) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn FsFile::read(self : FsFile, buffer : @js.Any) -> @js.Promise[Int] {
462 |   self.call("read", [buffer]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn FsFile::write(self : FsFile, data : @js.Any) -> @js.Promise[Int] {
468 |   self.call("write", [data]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn FsFile::seek(
    |   self : FsFile,
    |   offset : Int,
    |   whence : Int,
    | ) -> @js.Promise[Int] {
478 |   self.call("seek", [@js.any(offset), @js.any(whence)]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::test_(
    |   self : Deno,
    |   name : String,
    |   f : (TestContext) -> Unit,
    | ) -> Unit {
497 |   self.call("test", [@js.any(name), @js.from_fn1(f)]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Deno::test_async(
    |   self : Deno,
    |   name : String,
    |   f : async (TestContext) -> Unit,
    | ) -> Unit {
507 |   self.call("test", [@js.any(name), @js.promisify1(f) |> @js.from_fn1])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   |> ignore
    | }
    …

    | pub fn Deno::test_only(
    |   self : Deno,
    |   name : String,
    |   f : async (TestContext) -> Unit,
    | ) -> Unit {
518 |   self.call("test", [
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     @js.from_entries([
    |       ("name", name),
    |       ("only", true),
522 |       ("fn", @js.promisify1(f) |> @js.from_fn1),
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ]),
    |   ])
525 |   |> ignore
    |   ^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

12 uncovered line(s) in src/deno/permissions.mbt:

   | pub fn PermissionStatus::state(self : PermissionStatus) -> String {
15 |   self.get("state").cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn PermissionStatus::is_granted(self : PermissionStatus) -> Bool {
21 |   self.state() == "granted"
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Deno::permissions(self : Deno) -> @js.Any {
27 |   self.get("permissions")
   |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Deno::permissions_query(
   |   self : Deno,
   |   name : String,
   |   path? : String,
   | ) -> @js.Promise[PermissionStatus] {
37 |   let perms = self.permissions()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   perms
39 |   .call("query", [
   |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     @js.from_entries_option([("name", Some(name)), ("path", path.map(x => x))]),
   |   ])
42 |   .cast()
   |   ^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Deno::permissions_request(
   |   self : Deno,
   |   name : String,
   |   path? : String,
   | ) -> @js.Promise[PermissionStatus] {
52 |   let perms = self.permissions()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   perms
54 |   .call("request", [
   |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     @js.from_entries_option([("name", Some(name)), ("path", path.map(x => x))]),
   |   ])
57 |   .cast()
   |   ^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Deno::permissions_revoke(
   |   self : Deno,
   |   name : String,
   |   path? : String,
   | ) -> @js.Promise[PermissionStatus] {
67 |   let perms = self.permissions()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   perms
69 |   .call("revoke", [
   |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     @js.from_entries_option([("name", Some(name)), ("path", path.map(x => x))]),
   |   ])
72 |   .cast()
   |   ^^^^^^^ 	<-- UNCOVERED
   | }
   …

43 uncovered line(s) in src/examples/cfw/kv_example.mbt:

    | fn get_kv(env : @cloudflare.CloudflareEnv) -> @cloudflare.KVNamespace? {
 23 |   let env_js : @js.Any = @js.identity(env)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let kv_js = env_js.get("MY_KV")
    |   if @js.typeof_(kv_js) == "undefined" {
 26 |     None
    |     ^^^^ 	<-- UNCOVERED
    |   } else {
 28 |     Some(@js.identity(kv_js))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub fn get_kv_handler() -> @cloudflare.CloudflareFetchHandler {
 35 |   let async_handler = async fn(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     req : @cloudflare.CloudflareRequest,
    |     env : @cloudflare.CloudflareEnv,
    |     _ctx : @cloudflare.CloudflareContext,
    |   ) -> @http.Response {
 40 |     let url_str = req.url()
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let url = @url.URL::new(url_str)
    |     let pathname = url.pathname
    | 
    |     // Get KV namespace
 45 |     let kv = match get_kv(env) {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       Some(k) => k
    |       None =>
 48 |         return kv_json_response(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           "{\"error\":\"KV namespace not configured\"}", 500,
    |         )
    |     }
    | 
    |     // Route handling for KV operations
    |     if pathname == "/kv/get" {
    |       // Get a key from KV
 56 |       let key = url.searchParams().get("key")
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       match key {
    |         Some(k) => {
    |           let value = kv.get(k, None).wait() catch {
    |               _ =>
 61 |                 return kv_json_response(
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                   "{\"error\":\"Failed to get key\"}", 500,
    |                 )
    |             }
 65 |           match value {
    |           ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             Some(v) =>
 67 |               kv_json_response(
    |               ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                 "{\"key\":\"" + k + "\",\"value\":\"" + v + "\"}",
    |                 200,
    |               )
 71 |             None => kv_json_response("{\"error\":\"Key not found\"}", 404)
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           }
    |         }
 74 |         None => kv_json_response("{\"error\":\"Missing key parameter\"}", 400)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
 76 |     } else if pathname == "/kv/put" {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       // Put a key-value pair into KV
 78 |       let key = url.searchParams().get("key")
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let value = url.searchParams().get("value")
    |       match (key, value) {
    |         (Some(k), Some(v)) => {
    |           kv.put(k, v, None).wait() catch {
    |             _ =>
 84 |               return kv_json_response("{\"error\":\"Failed to put key\"}", 500)
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           }
 86 |           kv_json_response("{\"success\":true,\"key\":\"" + k + "\"}", 200)
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |         _ =>
 89 |           kv_json_response(
    |           ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             "{\"error\":\"Missing key or value parameter\"}", 400,
    |           )
    |       }
 93 |     } else if pathname == "/kv/delete" {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       // Delete a key from KV
 95 |       let key = url.searchParams().get("key")
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       match key {
    |         Some(k) => {
    |           kv.delete(k).wait() catch {
    |             _ =>
100 |               return kv_json_response(
    |               ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                 "{\"error\":\"Failed to delete key\"}", 500,
    |               )
    |           }
104 |           kv_json_response("{\"success\":true,\"key\":\"" + k + "\"}", 200)
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
106 |         None => kv_json_response("{\"error\":\"Missing key parameter\"}", 400)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
108 |     } else if pathname == "/kv/counter/increment" {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       // Increment a counter
110 |       let current_str = kv.get("counter", None).wait() catch {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           _ =>
112 |             return kv_json_response(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               "{\"error\":\"Failed to get counter\"}", 500,
    |             )
    |         }
116 |       let current = match current_str {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Some(s) => parse_int(s)
    |         None => 0
    |       }
    |       let new_value = current + 1
121 |       let new_value_str = new_value.to_string()
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       kv.put("counter", new_value_str, None).wait() catch {
    |         _ =>
124 |           return kv_json_response(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             "{\"error\":\"Failed to update counter\"}", 500,
    |           )
    |       }
128 |       kv_json_response("{\"counter\":" + new_value_str + "}", 200)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     } else if pathname == "/kv/counter/get" {
    |       // Get current counter value
131 |       let current_str = kv.get("counter", None).wait() catch {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           _ =>
133 |             return kv_json_response(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               "{\"error\":\"Failed to get counter\"}", 500,
    |             )
    |         }
137 |       let current = match current_str {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Some(s) => s
    |         None => "0"
    |       }
141 |       kv_json_response("{\"counter\":" + current + "}", 200)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     } else if pathname == "/kv/list" {
    |       // List all keys
144 |       let result = kv.list(None).wait() catch {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           _ =>
146 |             return kv_json_response("{\"error\":\"Failed to list keys\"}", 500)
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
    |       let keys = result.keys
149 |       let keys_json = @js.JsArray::new()
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let mut i = 0
    |       while i < keys.length() {
152 |         let key = keys[i]
    |         ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         let name = key.name
154 |         keys_json.call("push", [@js.any(name)]) |> ignore
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         i = i + 1
    |       }
157 |       let response_json = @js.Object::new()
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       response_json.set("keys", keys_json)
    |       response_json.set("count", keys.length())
    | 
    |       // Convert to JSON string
162 |       let json_str = json_stringify(response_json.to_any())
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       kv_json_response(json_str, 200)
    |     } else {
    |       // Help/index page
166 |       let help = "{\"endpoints\":[\"/kv/get?key=x\",\"/kv/put?key=x&value=y\",\"/kv/delete?key=x\",\"/kv/counter/increment\",\"/kv/counter/get\",\"/kv/list\"]}"
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       kv_json_response(help, 200)
    |     }
    |   }
170 |   promisify3(async_handler)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

13 uncovered line(s) in src/examples/cfw/main.mbt:

    | pub fn get_fetch_handler() -> @cloudflare.CloudflareFetchHandler {
 12 |   let async_handler = async fn(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     req : @cloudflare.CloudflareRequest,
    |     _env : @cloudflare.CloudflareEnv,
    |     _ctx : @cloudflare.CloudflareContext,
    |   ) -> Response {
 17 |     let url_str = req.url()
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let url = URL::new(url_str)
    |     let pathname = url.pathname
    | 
    |     // Route handling
    |     if pathname == "/" {
 23 |       Response::html(
    |       ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         "<h1>Cloudflare Worker with MoonBit</h1><p>Available routes: /api/hello, /api/echo, /api/fetch, /api/json</p>",
    |         200,
    |       )
 27 |     } else if pathname == "/api/hello" {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let data = @js.Object::new()
    |       data.set("message", "Hello from MoonBit Worker!")
    |       let options = @js.Object::new()
    |       options.set("status", 200)
    |       Response::json_(data, options~)
    |     } else if pathname == "/api/echo" {
    |       let data = @js.Object::new()
    |       data.set("url", url_str)
    |       let options = @js.Object::new()
    |       options.set("status", 200)
    |       Response::json_(data, options~)
    |     } else if pathname == "/api/fetch" {
    |       // Fetch external API
 41 |       let res = fetch(
    |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         "https://jsonplaceholder.typicode.com/todos/1",
    |         method_="GET",
 44 |       ).wait() catch {
    |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         e => {
    |           log("Error: " + e.to_string())
    |           let data = @js.Object::new()
    |           data.set("error", "Failed to fetch")
    |           let options = @js.Object::new()
    |           options.set("status", 500)
    |           return Response::json_(data, options~)
    |         }
    |       }
    |       res
 55 |     } else if pathname == "/api/json" {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let data = @js.Object::new()
    |       data.set("status", "ok")
    |       let inner_data = @js.Object::new()
    |       inner_data.set("foo", "bar")
    |       inner_data.set("num", 42)
    |       data.set("data", inner_data)
    |       data.set("timestamp", 1234567890)
    |       let options = @js.Object::new()
    |       options.set("status", 200)
    |       Response::json_(data, options~)
    |     } else if pathname == "/api/redirect" {
    |       Response::redirect("/", status=302)
    |     } else if pathname == "/api/headers" {
    |       let headers = @js.Object::new()
    |       headers.set("Content-Type", "application/json")
    |       headers.set("x-custom-header", "MoonBit-Worker")
    |       headers.set("x-powered-by", "Cloudflare")
    |       let data = @js.Object::new()
    |       data.set("message", "Check the headers")
    |       let options = @js.Object::new()
    |       options.set("status", 200)
    |       options.set("headers", headers)
    |       Response::json_(data, options~)
    |     } else if pathname == "/api/status/404" {
    |       let data = @js.Object::new()
    |       data.set("error", "Not Found")
    |       let options = @js.Object::new()
    |       options.set("status", 404)
    |       Response::json_(data, options~)
    |     } else if pathname == "/api/status/500" {
    |       let data = @js.Object::new()
    |       data.set("error", "Internal Server Error")
    |       let options = @js.Object::new()
    |       options.set("status", 500)
    |       Response::json_(data, options~)
    |     } else if pathname == "/api/text" {
    |       Response::text_("Plain text response from MoonBit", 200)
    |     } else if pathname == "/api/query" {
    |       // Parse query parameters
 95 |       let params = url.searchParams()
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let name = match params.get("name") {
    |         Some(n) => n
    |         None => "World"
    |       }
100 |       let message = match params.get("message") {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Some(m) => m
    |         None => "Hello"
    |       }
104 |       let data = @js.Object::new()
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       data.set("greeting", message + ", " + name + "!")
    |       let options = @js.Object::new()
    |       options.set("status", 200)
    |       Response::json_(data, options~)
    |     } else if pathname == "/api/time" {
    |       let data = @js.Object::new()
    |       data.set("timestamp", 1234567890)
    |       let options = @js.Object::new()
    |       options.set("status", 200)
    |       Response::json_(data, options~)
    |     } else if pathname == "/api/user-agent" {
    |       let data = @js.Object::new()
    |       data.set("userAgent", "unknown")
    |       let options = @js.Object::new()
    |       options.set("status", 200)
    |       Response::json_(data, options~)
    |     } else if pathname == "/api/method" {
    |       let data = @js.Object::new()
    |       data.set("method", "unknown")
    |       let options = @js.Object::new()
    |       options.set("status", 200)
    |       Response::json_(data, options~)
    |     } else if pathname == "/health" {
    |       let data = @js.Object::new()
    |       data.set("status", "healthy")
    |       data.set("service", "moonbit-worker")
    |       let options = @js.Object::new()
    |       options.set("status", 200)
    |       Response::json_(data, options~)
    |     } else if pathname == "/api/math/add" {
    |       let params = url.searchParams()
    |       let a_str = params.get("a")
    |       let b_str = params.get("b")
    |       match (a_str, b_str) {
    |         (Some(a), Some(b)) => {
    |           let data = @js.Object::new()
    |           data.set("result", a + "+" + b)
    |           let options = @js.Object::new()
    |           options.set("status", 200)
    |           Response::json_(data, options~)
    |         }
146 |         _ => {
    |         ^^^^^^ 	<-- UNCOVERED
    |           let data = @js.Object::new()
    |           data.set("error", "Missing parameters a or b")
    |           let options = @js.Object::new()
    |           options.set("status", 400)
    |           Response::json_(data, options~)
    |         }
    |       }
    |     } else {
155 |       let data = @js.Object::new()
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       data.set("error", "Route not found")
    |       let options = @js.Object::new()
    |       options.set("status", 404)
    |       Response::json_(data, options~)
    |     }
    |   }
162 |   promisify3(async_handler)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

39 uncovered line(s) in src/examples/react_app/main.mbt:

    | fn item_component(props : ItemViewProps) -> @react.Element {
 57 |   createElement(
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     "div",
    |     style={ "padding": "5px", "borderBottom": "1px solid #ccc" },
    |     [props.name],
    |   )
    | }
    …

    | fn init_myctx() -> Unit {
 69 |   myctx.val = Some(createContext(None))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | fn use_myctx() -> MyContextProps {
 74 |   guard myctx.val is Some(ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   useContext(ctx)
    | }
    …

    | fn ctx_consumer(_ : EmptyProps) -> @react.Element {
 80 |   let ctx_value = use_myctx()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   createElement("div", props={ "className": "context-value" |> @js.any }, [
    |     "Context value: \{ctx_value.v}",
    |   ])
    | }
    …

    | fn counter(_ : EmptyProps) -> @react.Element {
 93 |   let (count, dispatch) = useReducer(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (state : Int, action : CounterAction) => match action {
    |       CounterAction::Increment => state + 1
    |     },
    |     0,
    |   )
 99 |   let on_click = useCallback(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     () => {
    |       dispatch(CounterAction::Increment)
    |       log("Counter clicked: \{count + 1}")
    |     },
    |     [count],
    |   )
106 |   createElement("button", props={ "onClick": on_click |> identity }, [
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     "Count: \{count}",
    |   ])
    | }
    …

    | fn async_counter(_ : EmptyProps) -> @react.Element {
113 |   let (count, dispatch, is_pending) = useActionState(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     async fn(state : Int, action : CounterAction) -> Int noraise {
115 |       match action {
    |       ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Increment => state + 1
    |       }
    |     },
    |     0,
    |   )
121 |   let on_click = useCallback(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     _ => run_async(async fn() noraise {
    |       sleep(500)
    |       @react.startTransition(() => dispatch(Increment))
    |     }),
    |     [count],
    |   )
128 |   button(on_click~, [
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     "Async Count: \{count}",
    |     if is_pending {
131 |       " (Updating...)"
    |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     } else {
133 |       ""
    |       ^^ 	<-- UNCOVERED
    |     },
    |   ])
    | }
    …

    | fn app(props : AppProps) -> @react.Element {
146 |   let (cnt, set_cnt) = useState(props.x)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let textarea_ref : @react.ReactRef[@dom.HTMLTextAreaElement] = @react.useRef(
    |     None,
    |   )
150 |   let handler = useCallback(_ => set_cnt(cnt + 1), [cnt])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   useEffect(
    |     () => {
    |       log("mounted with x = \{props.x}")
    |       () => log("unmounted")
    |     },
    |     [cnt, textarea_ref],
    |   )
158 |   useEffect(
    |   ^^^^^^^^^^ 	<-- UNCOVERED
    |     () => {
    |       run_async(async fn() noraise {
    |         sleep(300)
    |         if textarea_ref.get_current() is Some(textarea) {
163 |           textarea.focus()
    |           ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
165 |         log("Starting async operation...")
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       })
167 |       () => log("Component unmounted")
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     },
    |     [],
    |   )
171 |   let (input_text, set_text) = useState("")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let on_change : @dom.ChangeEventHandler = useCallback(
    |     ev => {
    |       let target : @dom.HTMLTextAreaElement = identity(ev.target().to_any())
    |       let value : String = target.value
176 |       set_text(value)
    |       ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       log("Textarea changed: \{value}")
    |     },
    |     [input_text],
    |   )
    |   guard myctx.val is Some(myctx)
182 |   provider(myctx, value={ v: "xxx" }, [
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     h1(["Hello, Moonbit React!"]),
    |     div(
    |       id="foo",
    |       class="foo bar",
    |       style={ "border": "1px solid black", "padding": "10px" },
    |       on_click=handler,
    |       [
190 |         h2(["Counter: \{cnt}"]),
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         "x = \{cnt}",
192 |         fragment([createElement("h1", ["xxx"])]),
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         div(id="textarea-container", [
    |           textarea(
    |             id="my-textarea",
    |             on_change~,
    |             props={
198 |               let obj = @js.Object::new()
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               obj.set("rows", 4)
    |               obj.set("cols", 40)
    |               obj
    |             },
    |             ref_=textarea_ref,
    |             value=input_text,
    |             [],
    |           ),
207 |           div(class="textarea-value", ["Textarea value: \{input_text}"]),
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         ]),
    |         // ]
210 |         ul(
    |         ^^^ 	<-- UNCOVERED
    |           props.items.mapi((idx, item) => createElement(
    |             "li",
213 |             key=idx.to_string(),
    |             ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             [component(item_component, { name: item }, key=idx.to_string())],
    |           )),
    |         ),
217 |         component(ctx_consumer, EmptyProps::default()),
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         component(counter, EmptyProps::default()),
    |         component(async_counter, EmptyProps::default()),
    |         hr(),
    |         form(
    |           method_="post",
    |           style={ "marginTop": "10px" },
    |           enc_type="application/x-www-form-urlencoded",
225 |           action=form => {
    |           ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             log(form)
    |             let v : String = form.get("username") |> identity
    |             log("Username: \{v}")
    |           },
    |           [
231 |             input(type_="text", name="username"),
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             input(type_="submit", value="Submit"),
    |           ],
    |         ),
235 |         svg(width=500, height=100, [
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           circle(cx=50, cy=50, r=40, stroke="black", stroke_width=3, fill="red"),
    |           rect(
    |             x=120,
    |             y=10,
    |             width=80,
    |             height=80,
    |             stroke="blue",
    |             stroke_width=3,
    |             fill="green",
    |           ),
246 |           text(x=100, y=30, dx="50%", dy="50%", ["Hello, SVG Text!"]),
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           line(x1=220, y1=10, x2=300, y2=90, stroke="black", stroke_width=2),
    |         ]),
    |       ],
    |     ),
    |   ])
    | }
    …

    | async fn main {
256 |   @react.dynamic_import_async()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @react_router.dynamic_import_async()
    |   let client = @react_dom_client.dynamic_import_async()
    |   guard @dom.document().querySelector("#app") is Some(app_root)
260 |   init_myctx()
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let index = (_props : @react_router.RouteProps) => component(app, {
    |     x: 42,
    |     items: ["Item 1", "Item 2", "Item 3"],
    |   })
265 |   let routes = @react_router.create_browser_router([
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Component(path="/", component=index),
    |     Element(
    |       path="/about",
269 |       element=createElement("div", [
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         "About page",
271 |         @react_router.link(to="/", ["Go to Top"]),
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       ]),
    |     ),
    |   ])
275 |   client.create_root(app_root).render(router_provider(routes))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

1 uncovered line(s) in src/globals.mbt:

    | #alias(dynamic_import)
    | pub fn dynamicImport(module_name : String) -> Any {
128 |   ffi_dynamic_import(module_name)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

1 uncovered line(s) in src/impl.mbt:

    | impl JsImpl with call_self_throwable(self, args) -> Any raise ThrowError {
130 |   throwable(() => ffi_call_self(self.to_any(), args.map(_.to_any())))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

1 uncovered line(s) in src/js_bench.mbt:

    | fn get_test_obj() -> Any {
 20 |   ffi_create_test_function()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

18 uncovered line(s) in src/node/assert/assert.mbt:

    | pub fn equal(
    |   actual : &@js.JsImpl,
    |   expected : &@js.JsImpl,
    |   message? : String,
    | ) -> Unit {
    |   let a = assert_module()
    |   match message {
    |     Some(msg) =>
 29 |       a.call("equal", [actual.to_any(), expected.to_any(), msg]) |> ignore
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => a.call2("equal", actual.to_any(), expected.to_any()) |> ignore
    |   }
    | }
    …

    | pub fn notEqual(
    |   actual : &@js.JsImpl,
    |   expected : &@js.JsImpl,
    |   message? : String,
    | ) -> Unit {
    |   let a = assert_module()
    |   match message {
    |     Some(msg) =>
 44 |       a.call("notEqual", [actual.to_any(), expected.to_any(), msg]) |> ignore
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => a.call2("notEqual", actual.to_any(), expected.to_any()) |> ignore
    |   }
    | }
    …

    | pub fn deepEqual(
    |   actual : &@js.JsImpl,
    |   expected : &@js.JsImpl,
    |   message? : String,
    | ) -> Unit {
    |   let a = assert_module()
    |   match message {
    |     Some(msg) =>
 59 |       a.call("deepEqual", [actual.to_any(), expected.to_any(), msg]) |> ignore
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => a.call2("deepEqual", actual.to_any(), expected.to_any()) |> ignore
    |   }
    | }
    …

    | pub fn notDeepEqual(
    |   actual : &@js.JsImpl,
    |   expected : &@js.JsImpl,
    |   message? : String,
    | ) -> Unit {
    |   let a = assert_module()
    |   match message {
    |     Some(msg) =>
 74 |       a.call("notDeepEqual", [actual.to_any(), expected.to_any(), msg])
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       |> ignore
    |     None =>
    |       a.call2("notDeepEqual", actual.to_any(), expected.to_any()) |> ignore
    |   }
    | }
    …

    | pub fn strictEqual(
    |   actual : &@js.JsImpl,
    |   expected : &@js.JsImpl,
    |   message? : String,
    | ) -> Unit {
    |   let a = assert_module()
    |   match message {
    |     Some(msg) =>
 91 |       a.call("strictEqual", [actual.to_any(), expected.to_any(), msg]) |> ignore
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => a.call2("strictEqual", actual.to_any(), expected.to_any()) |> ignore
    |   }
    | }
    …

    | pub fn notStrictEqual(
    |   actual : &@js.JsImpl,
    |   expected : &@js.JsImpl,
    |   message? : String,
    | ) -> Unit {
    |   let a = assert_module()
    |   match message {
    |     Some(msg) =>
106 |       a.call("notStrictEqual", [actual.to_any(), expected.to_any(), msg])
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       |> ignore
    |     None =>
    |       a.call2("notStrictEqual", actual.to_any(), expected.to_any()) |> ignore
    |   }
    | }
    …

    | pub fn throws(fn_ : () -> Unit, message? : String) -> Unit {
    |   let a = assert_module()
    |   match message {
120 |     Some(msg) => a.call2("throws", @js.from_fn0(fn_), msg) |> ignore
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => a.call("throws", [@js.from_fn0(fn_)]) |> ignore
    |   }
    | }
    …

    | pub fn doesNotThrow(fn_ : () -> Unit, message? : String) -> Unit {
    |   let a = assert_module()
    |   match message {
130 |     Some(msg) => a.call2("doesNotThrow", @js.from_fn0(fn_), msg) |> ignore
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => a.call("doesNotThrow", [@js.from_fn0(fn_)]) |> ignore
    |   }
    | }
    …

    | pub fn rejects(
    |   promise : &@js.JsImpl,
    |   error? : &@js.JsImpl,
    |   message? : String,
    | ) -> @js.Promise[Unit] {
142 |   let a = assert_module()
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match (error, message) {
    |     (Some(err), Some(msg)) =>
145 |       a.call("rejects", [promise.to_any(), err.to_any(), msg]).cast()
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(err), None) =>
147 |       a.call2("rejects", promise.to_any(), err.to_any()).cast()
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (None, Some(msg)) => a.call2("rejects", promise.to_any(), msg).cast()
    |     (None, None) => a.call("rejects", [promise.to_any()]).cast()
    |   }
    | }
    …

    | pub fn doesNotReject(
    |   promise : &@js.JsImpl,
    |   message? : String,
    | ) -> @js.Promise[Unit] {
159 |   let a = assert_module()
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match message {
    |     Some(msg) => a.call2("doesNotReject", promise.to_any(), msg).cast()
    |     None => a.call("doesNotReject", [promise.to_any()]).cast()
    |   }
    | }
    …

    | pub fn fail(message? : String) -> Unit {
171 |   let a = assert_module()
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match message {
    |     Some(msg) => a.call("fail", [msg]) |> ignore
    |     None => a.call0("fail") |> ignore
    |   }
    | }
    …

    | pub fn doesNotMatch(
    |   actual : String,
    |   regexp : String,
    |   message? : String,
    | ) -> Unit {
    |   let a = assert_module()
    |   let regex = create_regexp(regexp)
    |   match message {
204 |     Some(msg) => a.call("doesNotMatch", [actual, regex, msg]) |> ignore
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => a.call2("doesNotMatch", actual, regex) |> ignore
    |   }
    | }
    …

    | pub fn instanceOf(
    |   value : &@js.JsImpl,
    |   ctor : &@js.JsImpl,
    |   message? : String,
    | ) -> Unit {
216 |   let a = assert_module()
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match message {
    |     Some(msg) =>
219 |       a.call("instanceOf", [value.to_any(), ctor.to_any(), msg]) |> ignore
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => a.call2("instanceOf", value.to_any(), ctor.to_any()) |> ignore
    |   }
    | }
    …

    | pub fn notInstanceOf(
    |   value : &@js.JsImpl,
    |   ctor : &@js.JsImpl,
    |   message? : String,
    | ) -> Unit {
231 |   let a = assert_module()
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match message {
    |     Some(msg) =>
234 |       a.call("notInstanceOf", [value.to_any(), ctor.to_any(), msg]) |> ignore
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => a.call2("notInstanceOf", value.to_any(), ctor.to_any()) |> ignore
    |   }
    | }
    …

11 uncovered line(s) in src/node/buffer/buffer.mbt:

    | pub fn Buffer::from_arraybuffer(
    |   ab : @js.ArrayBuffer,
    |   byte_offset? : Int = 0,
    |   length? : Int,
    | ) -> Buffer {
 44 |   let ctor = buffer_constructor()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match length {
    |     Some(len) => ctor.call("from", [ab, byte_offset, len]).cast()
    |     None => ctor.call2("from", ab, byte_offset).cast()
    |   }
    | }
    …

    | pub fn Buffer::concat(list : Array[Buffer], total_length? : Int) -> Buffer {
    |   let ctor = buffer_constructor()
    |   let list_js = @js.JsArray::new()
    |   let mut i = 0
    |   while i < list.length() {
    |     list_js.call("push", [list[i]]) |> ignore
    |     i = i + 1
    |   }
    |   match total_length {
114 |     Some(len) => ctor.call2("concat", list_js, len).cast()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ctor.call("concat", [list_js]).cast()
    |   }
    | }
    …

    | pub fn Buffer::write(
    |   self : Self,
    |   str : String,
    |   offset? : Int = 0,
    |   length? : Int,
    |   encoding? : String = "utf-8",
    | ) -> Int {
    |   let buf_js = self.to_any()
    |   match length {
159 |     Some(len) => buf_js.call("write", [str, offset, len, encoding]).cast()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => buf_js.call("write", [str, offset, encoding]).cast()
    |   }
    | }
    …

    | pub fn Buffer::subarray(self : Self, start? : Int = 0, end? : Int) -> Buffer {
    |   let buf_js = self.to_any()
    |   match end {
    |     Some(e) => buf_js.call2("subarray", start, e).cast()
180 |     None => buf_js.call("subarray", [start]).cast()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub fn Buffer::copy(
    |   self : Self,
    |   target : Buffer,
    |   target_start? : Int = 0,
    |   source_start? : Int = 0,
    |   source_end? : Int,
    | ) -> Int {
    |   let buf_js = self.to_any()
    |   match source_end {
    |     Some(se) =>
196 |       buf_js
    |       ^^^^^^ 	<-- UNCOVERED
    |       .call("copy", [target.to_any(), target_start, source_start, se])
    |       .cast()
    |     None =>
    |       buf_js.call("copy", [target.to_any(), target_start, source_start]).cast()
    |   }
    | }
    …

    | pub fn Buffer::compare_with(
    |   self : Self,
    |   target : Buffer,
    |   target_start? : Int = 0,
    |   target_end? : Int,
    |   source_start? : Int = 0,
    |   source_end? : Int,
    | ) -> Int {
236 |   let buf_js = self.to_any()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let args = @js.JsArray::new()
    |   args.call("push", [target.to_any()]) |> ignore
    |   args.call("push", [target_start]) |> ignore
    |   match target_end {
    |     Some(te) => args.call("push", [te]) |> ignore
    |     None => ()
    |   }
244 |   args.call("push", [source_start]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match source_end {
    |     Some(se) => args.call("push", [se]) |> ignore
    |     None => ()
    |   }
249 |   let compare_fn = buf_js.get("compare")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let apply = compare_fn.get("apply")
    |   apply.call("call", [compare_fn, buf_js, args]).cast()
    | }
    …

    | #alias(last_index_of)
    | pub fn Buffer::lastIndexOf(
    |   self : Self,
    |   value : @js.Any,
    |   byte_offset? : Int,
    |   encoding? : String = "utf-8",
    | ) -> Int {
286 |   let buf_js = self.to_any()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match byte_offset {
    |     Some(offset) => buf_js.call("lastIndexOf", [value, offset, encoding]).cast()
    |     None => buf_js.call2("lastIndexOf", value, encoding).cast()
    |   }
    | }
    …

    | pub fn Buffer::buffer(self : Self) -> @js.ArrayBuffer {
316 |   self.get("buffer").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(byte_offset)
    | pub fn Buffer::byteOffset(self : Self) -> Int {
323 |   self.get("byteOffset").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

13 uncovered line(s) in src/node/child_process/child_process.mbt:

    | pub fn ChildProcess::send(self : Self, message : &@js.JsImpl) -> Bool {
 48 |   self.call("send", [message.to_any()]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ChildProcess::disconnect(self : Self) -> Unit {
 54 |   self.call0("disconnect") |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn spawn(
    |   command : String,
    |   args? : Array[String],
    |   cwd? : String,
    |   env? : @js.Any,
    |   shell? : Bool,
    |   timeout? : Int,
    |   signal? : @js.AbortSignal,
    | ) -> ChildProcess {
    |   let cp = ffi_require_child_process()
    |   let options = @js.from_entries_option([
    |     ("cwd", cwd.map(x => x)),
    |     ("env", env.map(x => x)),
    |     ("shell", shell.map(x => x)),
    |     ("timeout", timeout.map(x => x)),
 92 |     ("signal", signal.map(x => x.to_any())),
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ])
    |   match args {
    |     Some(a) => cp.call("spawn", [command, a |> @js.from_array, options]).cast()
    |     None => cp.call2("spawn", command, options).cast()
    |   }
    | }
    …

    | pub fn exec(
    |   command : String,
    |   callback : (@js.Any?, String, String) -> Unit noraise,
    |   cwd? : String,
    |   env? : @js.Any,
    |   shell? : String,
    |   timeout? : Int,
    |   max_buffer? : Int,
    |   signal? : @js.AbortSignal,
    | ) -> ChildProcess {
113 |   let cp = ffi_require_child_process()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let options = @js.from_entries_option([
    |     ("cwd", cwd.map(x => x)),
    |     ("env", env.map(x => x)),
    |     ("shell", shell.map(x => x)),
    |     ("timeout", timeout.map(x => x)),
    |     ("maxBuffer", max_buffer.map(x => x)),
    |     ("signal", signal.map(x => x.to_any())),
    |   ])
122 |   cp.call("exec", [command |> @js.any, options, @js.identity(callback)]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(exec_file)
    | pub fn execFile(
    |   file : String,
    |   args : Array[String],
    |   callback : (@js.Any?, String, String) -> Unit noraise,
    |   cwd? : String,
    |   env? : @js.Any,
    |   timeout? : Int,
    |   max_buffer? : Int,
    |   signal? : @js.AbortSignal,
    | ) -> ChildProcess {
139 |   let cp = ffi_require_child_process()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let options = @js.from_entries_option([
    |     ("cwd", cwd.map(x => x)),
    |     ("env", env.map(x => x)),
    |     ("timeout", timeout.map(x => x)),
    |     ("maxBuffer", max_buffer.map(x => x)),
    |     ("signal", signal.map(x => x.to_any())),
    |   ])
    |   cp
148 |   .call("execFile", [
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     file,
150 |     args |> @js.from_array,
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     options,
152 |     @js.identity(callback),
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ])
154 |   .cast()
    |   ^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn fork(
    |   module_path : String,
    |   args? : Array[String],
    |   cwd? : String,
    |   env? : @js.Any,
    |   silent? : Bool,
    |   timeout? : Int,
    |   signal? : @js.AbortSignal,
    | ) -> ChildProcess {
169 |   let cp = ffi_require_child_process()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let options = @js.from_entries_option([
    |     ("cwd", cwd.map(x => x)),
    |     ("env", env.map(x => x)),
    |     ("silent", silent.map(x => x)),
    |     ("timeout", timeout.map(x => x)),
    |     ("signal", signal.map(x => x.to_any())),
    |   ])
177 |   match args {
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(a) =>
179 |       cp
    |       ^^ 	<-- UNCOVERED
    |       .call("fork", [module_path |> @js.any, a |> @js.from_array, options])
    |       .cast()
    |     None => cp.call2("fork", module_path |> @js.any, options).cast()
    |   }
    | }
    …

13 uncovered line(s) in src/node/child_process/typed_listener.mbt:

   | pub fn ChildProcess::on_exit(
   |   self : Self,
   |   callback : (Int?, String?) -> Unit noraise,
   | ) -> Unit {
10 |   self.call("on", [
   |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     "exit",
12 |     @js.identity(fn(code : @js.Any, signal : @js.Any) {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       callback(
   |         code |> @js.identity_option(),
   |         signal |> @js.identity_option(),
   |       )
   |     }),
   |   ])
19 |   |> ignore
   |   ^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn ChildProcess::on_close(
   |   self : Self,
   |   callback : (Int?, String?) -> Unit noraise,
   | ) -> Unit {
29 |   self.call("on", [
   |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     "close",
31 |     @js.identity(fn(code : @js.Any, signal : @js.Any) {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       callback(
   |         code |> @js.identity_option(),
   |         signal |> @js.identity_option(),
   |       )
   |     }),
   |   ])
38 |   |> ignore
   |   ^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn ChildProcess::on_error(
   |   self : Self,
   |   callback : (@js.Any) -> Unit noraise,
   | ) -> Unit {
48 |   self.call2("on", "error", @js.identity(callback)) |> ignore
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn ChildProcess::on_message(
   |   self : Self,
   |   callback : (@js.Any, @js.Any?) -> Unit noraise,
   | ) -> Unit {
58 |   self.call("on", [
   |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     "message",
60 |     @js.identity(fn(message : @js.Any, sendHandle : @js.Any) {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       callback(message, sendHandle |> @js.identity_option())
   |     }),
   |   ])
64 |   |> ignore
   |   ^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn ChildProcess::on_disconnect(
   |   self : Self,
   |   callback : () -> Unit noraise,
   | ) -> Unit {
74 |   self.call2("on", "disconnect", @js.identity(callback)) |> ignore
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn ChildProcess::on_spawn(
   |   self : Self,
   |   callback : () -> Unit noraise,
   | ) -> Unit {
84 |   self.call2("on", "spawn", @js.identity(callback)) |> ignore
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn ChildProcess::on_stdout_data(
   |   self : Self,
   |   callback : (@js.Any) -> Unit noraise,
   | ) -> Unit {
94 |   self.stdout.call2("on", "data", @js.identity(callback)) |> ignore
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

16 uncovered line(s) in src/node/dns/dns.mbt:

    | pub fn LookupOptions::to_any(self : LookupOptions) -> @js.Any {
    |   let obj = @js.Object::new()
    |   match self.family {
 22 |     Some(v) => obj.set("family", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.all {
 26 |     Some(v) => obj.set("all", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.order {
 30 |     Some(v) => obj.set("order", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   obj.to_any()
    | }
    …

    | pub fn lookup(
    |   hostname : String,
    |   options : LookupOptions,
    |   callback : (@js.Object?, @js.Object) -> Unit,
    | ) -> Unit {
 54 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ffi_lookup(hostname, options.to_any(), cb)
    | }
    …

    | pub fn resolve(
    |   hostname : String,
    |   rrtype : String,
    |   callback : (@js.Object?, @js.JsArray) -> Unit,
    | ) -> Unit {
 76 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ffi_resolve(hostname, rrtype, cb)
    | }
    …

    | pub fn resolve4(
    |   hostname : String,
    |   callback : (@js.Object?, @js.JsArray) -> Unit,
    | ) -> Unit {
 93 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ffi_resolve4(hostname, cb)
    | }
    …

    | pub fn resolve6(
    |   hostname : String,
    |   callback : (@js.Object?, @js.JsArray) -> Unit,
    | ) -> Unit {
110 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ffi_resolve6(hostname, cb)
    | }
    …

    | pub fn resolve_mx(
    |   hostname : String,
    |   callback : (@js.Object?, @js.JsArray) -> Unit,
    | ) -> Unit {
127 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ffi_resolve_mx(hostname, cb)
    | }
    …

    | pub fn resolve_txt(
    |   hostname : String,
    |   callback : (@js.Object?, @js.JsArray) -> Unit,
    | ) -> Unit {
144 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ffi_resolve_txt(hostname, cb)
    | }
    …

    | pub fn resolve_srv(
    |   hostname : String,
    |   callback : (@js.Object?, @js.JsArray) -> Unit,
    | ) -> Unit {
161 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ffi_resolve_srv(hostname, cb)
    | }
    …

    | pub fn resolve_ns(
    |   hostname : String,
    |   callback : (@js.Object?, @js.JsArray) -> Unit,
    | ) -> Unit {
178 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ffi_resolve_ns(hostname, cb)
    | }
    …

    | pub fn resolve_cname(
    |   hostname : String,
    |   callback : (@js.Object?, @js.JsArray) -> Unit,
    | ) -> Unit {
195 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ffi_resolve_cname(hostname, cb)
    | }
    …

    | pub fn reverse(
    |   ip : String,
    |   callback : (@js.Object?, @js.JsArray) -> Unit,
    | ) -> Unit {
212 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ffi_reverse(ip, cb)
    | }
    …

    | pub fn set_servers(servers : Array[String]) -> Unit {
239 |   let arr = @js.JsArray::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let mut i = 0
    |   while i < servers.length() {
242 |     arr.call("push", [servers[i]]) |> ignore
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     i = i + 1
    |   }
245 |   ffi_set_servers(arr)
    |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

4 uncovered line(s) in src/node/events/event_emitter.mbt:

    | impl EventEmitterImpl with on2(
    |   self,
    |   name : String,
    |   callback : (@js.Any?, @js.Any) -> Unit,
    | ) -> Unit {
 32 |   self.call2("on", name, callback |> @js.from_fn2).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | impl EventEmitterImpl with listeners(self, event? : String) {
 56 |   match event {
    |   ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(name) => self.call("listenerCount", [name]).cast()
    |     None => self.call0("listenerCount").cast()
    |   }
    | }
    …

    | impl EventEmitterImpl with off(
    |   self,
    |   name : String,
    |   callback : (@js.Any) -> Unit,
    | ) -> Unit {
 68 |   self.call2("off", name, callback |> @js.from_fn1).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | impl EventEmitterImpl with removeListener(
    |   self,
    |   name : String,
    |   callback : (@js.Any) -> Unit,
    | ) -> Unit {
 77 |   self.call2("removeListener", name, callback |> @js.from_fn1).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

4 uncovered line(s) in src/node/fs/fs.mbt:

    | #alias(rm_sync)
    | pub fn rmSync(
    |   path : String,
    |   recursive? : Bool,
    |   force? : Bool,
    | ) -> Unit raise @js.ThrowError {
    |   @js.throwable(fn() {
    |     let fs = fs_module()
    |     match (recursive, force) {
179 |       (None, None) => fs.call1("rmSync", path) |> ignore
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       _ =>
    |         fs.call2(
    |           "rmSync",
    |           path,
    |           @js.from_entries_option_cast([
    |             ("recursive", recursive),
    |             ("force", force),
    |           ]),
    |         )
    |         |> ignore
    |     }
    |   })
    | }
    …

    | pub fn createReadStream(path : String) -> @stream.Readable {
196 |   let fs = fs_module()
    |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   fs.call1("createReadStream", path) |> @js.identity
    | }
    …

    | pub fn createWriteStream(path : String) -> @stream.Writable {
202 |   let fs = fs_module()
    |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   fs.call1("createWriteStream", path) |> @js.identity
    | }
    …

    | #alias(symlink_sync)
    | pub fn symlinkSync(
    |   target : String,
    |   path : String,
    |   type_? : String,
    | ) -> Unit raise @js.ThrowError {
    |   @js.throwable(fn() {
    |     let fs = fs_module()
    |     match type_ {
243 |       Some(t) => fs.call("symlinkSync", [target, path, t]) |> ignore
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       None => fs.call2("symlinkSync", target, path) |> ignore
    |     }
    |   })
    | }
    …

4 uncovered line(s) in src/node/fs/stat.mbt:

   | pub fn Stat::isFile(self : Self) -> Bool {
10 |   self.call0("isFile").cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Stat::isDirectory(self : Self) -> Bool {
15 |   self.call0("isDirectory").cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Stat::size(self : Self) -> Int {
20 |   self.get("size").cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Stat::mtime_ms(self : Self) -> Float {
25 |   let mtime = self.get("mtime")
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   @js.identity(mtime.get("getTime").call("call", [mtime]))
   | }
   …

2 uncovered line(s) in src/node/fs/watch.mbt:

   | pub fn watch(
   |   filename : String,
   |   persistent? : Bool,
   |   recursive? : Bool,
   |   encoding? : String,
   |   listener? : (String, String) -> Unit,
   | ) -> FSWatcher {
   |   let fs = fs_module()
   |   let has_options = not(persistent is None) ||
   |     not(recursive is None) ||
   |     not(encoding is None)
   |   if has_options {
   |     let map : Map[String, @js.Any] = {
   |       let m = Map::new()
   |       match persistent {
   |         Some(p) => m.set("persistent", @js.identity(p))
   |         None => ()
   |       }
   |       match recursive {
   |         Some(r) => m.set("recursive", @js.identity(r))
   |         None => ()
   |       }
   |       match encoding {
54 |         Some(e) => m.set("encoding", @js.identity(e))
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |         None => ()
   |       }
   |       m
   |     }
   |     let options = @js.from_map(map)
   |     match listener {
   |       Some(l) => fs.call("watch", [filename, options, @js.from_fn2(l)]).cast()
   |       None => fs.call2("watch", filename, options).cast()
   |     }
   |   } else {
   |     match listener {
66 |       Some(l) => fs.call2("watch", filename, @js.from_fn2(l)).cast()
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       None => fs.call1("watch", filename).cast()
   |     }
   |   }
   | }
   …

35 uncovered line(s) in src/node/fs_promises/promises.mbt:

    | pub fn Stat::isFile(self : Self) -> Bool {
 10 |   self.call0("isFile").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Stat::isDirectory(self : Self) -> Bool {
 15 |   self.call0("isDirectory").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Stat::size(self : Self) -> Int {
 20 |   self.get("size").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Stat::mtime_ms(self : Self) -> Float {
 25 |   let mtime = self.get("mtime")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @js.identity(mtime.get("getTime").call("call", [mtime]))
    | }
    …

    | pub fn stat(path : String) -> @js.Promise[Stat] {
 32 |   let fs = @node.require("node:fs/promises")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @js.identity(fs.call("stat", [path]))
    | }
    …

    | pub fn glob(
    |   path : String,
    |   cwd? : String,
    |   exclude? : Array[String],
    |   exclude_fn? : (String) -> Bool,
    | ) -> @js.AsyncIterator[String] {
 56 |   let fs = @node.require("node:fs/promises")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @js.identity(
    |     fs.call("glob", [
    |       path,
 60 |       @js.from_entries_option([
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         ("cwd", cwd.map(x => x)),
    |         ("exclude", exclude.map(fn(x) { x |> @js.from_array })),
    |         ("exclude", exclude_fn.map(fn(x) { x |> @js.from_fn1 })),
    |       ]),
    |     ]),
    |   )
    | }
    …

    | #alias(is_file)
    | pub fn Dirent::isFile(self : Self) -> Bool {
 79 |   self.call0("isFile").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(is_directory)
    | pub fn Dirent::isDirectory(self : Self) -> Bool {
 85 |   self.call0("isDirectory").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Dirent::name(self : Self) -> String {
 90 |   self.get("name").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn glob_with_filetype(
    |   path : String,
    |   cwd? : String,
    |   exclude? : Array[String],
    |   exclude_fn? : (String) -> Bool,
    | ) -> @js.AsyncIterator[Dirent] {
100 |   let fs = @node.require("node:fs/promises")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @js.identity(
    |     fs.call("glob", [
    |       path,
104 |       @js.from_entries_option([
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         ("withFileTypes", Some(true)),
106 |         ("cwd", cwd.map(x => x)),
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         ("exclude", exclude.map(fn(x) { x |> @js.from_array })),
    |         ("exclude", exclude_fn.map(fn(x) { x |> @js.from_fn1 })),
    |       ]),
    |     ]),
    |   )
    | }
    …

    | pub fn open(path : String) -> @js.Promise[FileHandle] {
121 |   let fs = @node.require("node:fs/promises")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @js.identity(fs.call("open", [path]))
    | }
    …

    | #alias(read_file)
    | pub fn readFile(
    |   path : String,
    |   encoding? : String = "utf-8",
    | ) -> @js.Promise[String] {
131 |   let fs = @node.require("node:fs/promises")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   fs.call2("readFile", path, encoding).cast()
    | }
    …

    | pub fn read_file_as_string(
    |   path : String,
    |   encoding? : String = "utf8",
    | ) -> @js.Promise[String] {
142 |   let fs = @node.require("node:fs/promises")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   fs.call2("readFile", path, encoding).cast()
    | }
    …

    | pub fn read_file_as_buffer(path : String) -> @js.Promise[@buffer.Buffer] {
150 |   let fs = @node.require("node:fs/promises")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @js.identity(fs.call("readFile", [path]))
    | }
    …

    | pub fn rename(path : String, dest : String) -> @js.Promise[Unit] {
183 |   let fs = @node.require("node:fs/promises")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   fs.call2("rename", path, dest).cast()
    | }
    …

    | pub fn cp(path : String, dest : String, recursive? : Bool) -> @js.Promise[Unit] {
200 |   let fs = @node.require("node:fs/promises")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @js.identity(
    |     fs.call("cp", [
    |       path,
    |       dest,
205 |       @js.from_entries_option_cast([("recursive", recursive)]),
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ]),
    |   )
    | }
    …

    | pub fn chmod(path : String, mode : Int) -> @js.Promise[Unit] {
215 |   let fs = @node.require("node:fs/promises")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   fs.call2("chmod", path, mode).cast()
    | }
    …

    | pub fn chown(path : String, uid : Int, gid : Int) -> @js.Promise[Unit] {
222 |   let fs = @node.require("node:fs/promises")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @js.identity(fs.call("chown", [path, uid, gid]))
    | }
    …

    | pub fn symlink(
    |   target : String,
    |   path : String,
    |   type_? : String,
    | ) -> @js.Promise[Unit] {
233 |   let fs = @node.require("node:fs/promises")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match type_ {
    |     Some(t) => @js.identity(fs.call("symlink", [target, path, t]))
    |     None => fs.call2("symlink", target, path).cast()
    |   }
    | }
    …

    | pub fn readlink(path : String) -> @js.Promise[String] {
243 |   let fs = @node.require("node:fs/promises")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @js.identity(fs.call("readlink", [path]))
    | }
    …

    | pub fn truncate(path : String, len? : Int) -> @js.Promise[Unit] {
257 |   let fs = @node.require("node:fs/promises")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match len {
    |     Some(l) => fs.call2("truncate", path, l).cast()
    |     None => @js.identity(fs.call("truncate", [path]))
    |   }
    | }
    …

    | pub fn rmdir(path : String, recursive? : Bool) -> @js.Promise[Unit] {
267 |   let fs = @node.require("node:fs/promises")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @js.identity(
    |     fs.call("rmdir", [
    |       path,
271 |       @js.from_entries_option_cast([("recursive", recursive)]),
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ]),
    |   )
    | }
    …

    | pub fn access(path : String, mode? : Int) -> @js.Promise[Unit] {
279 |   let fs = @node.require("node:fs/promises")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match mode {
    |     Some(m) => fs.call2("access", path, m).cast()
    |     None => @js.identity(fs.call("access", [path]))
    |   }
    | }
    …

    | pub fn appendFile(
    |   path : String,
    |   data : String,
    |   encoding? : String,
    | ) -> @js.Promise[Unit] {
293 |   let fs = @node.require("node:fs/promises")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match encoding {
    |     Some(enc) =>
296 |       @js.identity(
    |       ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         fs.call("appendFile", [
    |           path,
    |           data,
300 |           @js.from_entries_option_cast([("encoding", Some(enc))]),
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         ]),
    |       )
303 |     None => fs.call2("appendFile", path, data).cast()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub fn copyFile(src : String, dest : String) -> @js.Promise[Unit] {
310 |   let fs = @node.require("node:fs/promises")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   fs.call2("copyFile", src, dest).cast()
    | }
    …

    | pub fn readdir(path : String) -> @js.Promise[Array[String]] {
317 |   let fs = @node.require("node:fs/promises")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @js.identity(fs.call("readdir", [path]))
    | }
    …

    | pub fn unlink(path : String) -> @js.Promise[Unit] {
324 |   let fs = @node.require("node:fs/promises")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @js.identity(fs.call("unlink", [path]))
    | }
    …

47 uncovered line(s) in src/node/http/http.mbt:

    | pub fn IncomingMessage::as_readable(self : IncomingMessage) -> @stream.Readable {
 29 |   @js.identity(self)
    |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn IncomingMessage::method_(self : IncomingMessage) -> String? {
 35 |   self.get("method") |> @js.identity_option
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn IncomingMessage::setTimeout(
    |   self : IncomingMessage,
    |   msecs : Int,
    |   callback? : () -> Unit,
    | ) -> IncomingMessage {
 45 |   match callback {
    |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(cb) =>
 47 |       self.call2("setTimeout", msecs, @js.from_fn0(cb)) |> @js.identity
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => self.call("setTimeout", [msecs]).cast()
    |   }
    | }
    …

    | pub fn ServerResponse::as_writable(self : ServerResponse) -> @stream.Writable {
 67 |   @js.identity(self)
    |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ServerResponse::writeHead(
    |   self : ServerResponse,
    |   statusCode : Int,
    |   statusMessage? : String,
    |   headers? : @js.Any,
    | ) -> ServerResponse {
 78 |   match (statusMessage, headers) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(msg), Some(hdrs)) =>
 80 |       self.call("writeHead", [statusCode, msg, hdrs]).cast()
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(msg), None) =>
 82 |       self.call2("writeHead", statusCode, msg) |> @js.identity
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (None, Some(hdrs)) =>
 84 |       self.call2("writeHead", statusCode, hdrs) |> @js.identity
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (None, None) => self.call("writeHead", [statusCode]).cast()
    |   }
    | }
    …

    | pub fn ServerResponse::write(
    |   self : ServerResponse,
    |   chunk : String,
    |   encoding? : String,
    | ) -> Bool {
 96 |   match encoding {
    |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(enc) => self.call2("write", chunk, enc) |> @js.identity
    |     None => self.call("write", [chunk]).cast()
    |   }
    | }
    …

    | pub fn ServerResponse::end(
    |   self : ServerResponse,
    |   data? : String,
    |   encoding? : String,
    | ) -> Unit {
109 |   match (data, encoding) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(d), Some(enc)) => self.call2("end", d, enc) |> ignore
    |     (Some(d), None) => self.call("end", [d]) |> ignore
    |     (None, _) => self.call0("end") |> ignore
    |   }
    | }
    …

    | pub fn ServerResponse::setHeader(
    |   self : ServerResponse,
    |   name : String,
    |   value : String,
    | ) -> Unit {
123 |   self.call2("setHeader", name, value) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ServerResponse::getHeader(
    |   self : ServerResponse,
    |   name : String,
    | ) -> String? {
132 |   self.call("getHeader", [name]) |> @js.identity_option
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ServerResponse::removeHeader(
    |   self : ServerResponse,
    |   name : String,
    | ) -> Unit {
141 |   self.call("removeHeader", [name]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ServerResponse::headersSent(self : ServerResponse) -> Bool {
147 |   self.get("headersSent").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ServerResponse::statusCode(self : ServerResponse) -> Int {
153 |   self.get("statusCode").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ServerResponse::set_statusCode(
    |   self : ServerResponse,
    |   code : Int,
    | ) -> Unit {
162 |   self.set("statusCode", code |> @js.any)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ServerResponse::statusMessage(self : ServerResponse) -> String {
168 |   self.get("statusMessage").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ServerResponse::set_statusMessage(
    |   self : ServerResponse,
    |   message : String,
    | ) -> Unit {
177 |   self.set("statusMessage", message)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ServerResponse::setTimeout(
    |   self : ServerResponse,
    |   msecs : Int,
    |   callback? : () -> Unit,
    | ) -> ServerResponse {
187 |   match callback {
    |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(cb) =>
189 |       self.call2("setTimeout", msecs, @js.from_fn0(cb)) |> @js.identity
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => self.call("setTimeout", [msecs]).cast()
    |   }
    | }
    …

    | pub fn Server::listen(
    |   self : Server,
    |   port : Int,
    |   host? : String,
    |   backlog? : Int,
    |   callback? : () -> Unit,
    | ) -> Server {
    |   // Register callback as 'listening' event listener if provided
    |   match callback {
    |     Some(cb) => self.once("listening", fn(_) { cb() })
    |     None => ()
    |   }
    | 
    |   // Call listen with port, host, and backlog
    |   match (host, backlog) {
223 |     (Some(h), Some(b)) => self.call("listen", [port, h, b]).cast()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(h), None) => self.call2("listen", port, h) |> @js.identity
225 |     (None, Some(b)) => self.call2("listen", port, b) |> @js.identity
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (None, None) => self.call("listen", [port]).cast()
    |   }
    | }
    …

    | pub fn Server::close(self : Server, callback? : () -> Unit) -> Server {
    |   match callback {
234 |     Some(cb) => self.call("close", [@js.from_fn0(cb)]).cast()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => self.call0("close") |> @js.identity
    |   }
    | }
    …

    | pub fn Server::address(self : Server) -> @js.Any? {
242 |   self.call0("address") |> @js.identity_option
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Server::maxHeadersCount(self : Server) -> Int? {
254 |   self.get("maxHeadersCount") |> @js.identity_option
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Server::set_maxHeadersCount(self : Server, max : Int) -> Unit {
260 |   self.set("maxHeadersCount", max |> @js.any)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Server::setTimeout(
    |   self : Server,
    |   msecs : Int,
    |   callback? : () -> Unit,
    | ) -> Server {
270 |   match callback {
    |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(cb) =>
272 |       self.call2("setTimeout", msecs, @js.from_fn0(cb)) |> @js.identity
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => self.call("setTimeout", [msecs]).cast()
    |   }
    | }
    …

    | pub fn Server::timeout(self : Server) -> Int {
280 |   self.get("timeout").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Server::set_timeout(self : Server, msecs : Int) -> Unit {
286 |   self.set("timeout", msecs |> @js.any)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ClientRequest::as_writable(self : ClientRequest) -> @stream.Writable {
304 |   @js.identity(self)
    |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ClientRequest::write(
    |   self : ClientRequest,
    |   chunk : String,
    |   encoding? : String,
    | ) -> Bool {
314 |   match encoding {
    |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(enc) => self.call2("write", chunk, enc) |> @js.identity
    |     None => self.call("write", [chunk]).cast()
    |   }
    | }
    …

    | pub fn ClientRequest::end(
    |   self : ClientRequest,
    |   data? : String,
    |   encoding? : String,
    | ) -> Unit {
327 |   match (data, encoding) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(d), Some(enc)) => self.call2("end", d, enc) |> ignore
    |     (Some(d), None) => self.call("end", [d]) |> ignore
    |     (None, _) => self.call0("end") |> ignore
    |   }
    | }
    …

    | pub fn ClientRequest::abort(self : ClientRequest) -> Unit {
337 |   self.call0("abort") |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ClientRequest::setHeader(
    |   self : ClientRequest,
    |   name : String,
    |   value : String,
    | ) -> Unit {
347 |   self.call2("setHeader", name, value) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ClientRequest::getHeader(self : ClientRequest, name : String) -> String? {
353 |   self.call("getHeader", [name]) |> @js.identity_option
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ClientRequest::removeHeader(self : ClientRequest, name : String) -> Unit {
359 |   self.call("removeHeader", [name]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ClientRequest::setTimeout(
    |   self : ClientRequest,
    |   msecs : Int,
    |   callback? : () -> Unit,
    | ) -> ClientRequest {
369 |   match callback {
    |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(cb) =>
371 |       self.call2("setTimeout", msecs, @js.from_fn0(cb)) |> @js.identity
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => self.call("setTimeout", [msecs]).cast()
    |   }
    | }
    …

    | pub fn request(
    |   url : String,
    |   options? : @js.Any,
    |   callback? : (IncomingMessage) -> Unit,
    | ) -> ClientRequest {
398 |   match (options, callback) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(opts), Some(cb)) =>
400 |       http_module().call("request", [url, opts, @js.from_fn1(cb)])
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       |> @js.identity
    |     (Some(opts), None) =>
403 |       http_module().call2("request", url, opts) |> @js.identity
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (None, Some(cb)) =>
405 |       http_module().call2("request", url, @js.from_fn1(cb)) |> @js.identity
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (None, None) => http_module().call("request", [url]).cast()
    |   }
    | }
    …

    | pub fn get(
    |   url : String,
    |   options? : @js.Any,
    |   callback? : (IncomingMessage) -> Unit,
    | ) -> ClientRequest {
417 |   match (options, callback) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(opts), Some(cb)) =>
419 |       http_module().call("get", [url, opts, @js.from_fn1(cb)]).cast()
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(opts), None) => http_module().call2("get", url, opts) |> @js.identity
    |     (None, Some(cb)) =>
422 |       http_module().call2("get", url, @js.from_fn1(cb)) |> @js.identity
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (None, None) => http_module().call("get", [url]).cast()
    |   }
    | }
    …

29 uncovered line(s) in src/node/http2/http2.mbt:

    | pub fn ServerOptions::to_any(self : ServerOptions) -> @js.Any {
    |   let obj = @js.Object::new()
    |   match self.allow_http1 {
106 |     Some(v) => obj.set("allowHTTP1", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.max_deflate_dynamic_table_size {
110 |     Some(v) => obj.set("maxDeflateDynamicTableSize", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.max_session_memory {
114 |     Some(v) => obj.set("maxSessionMemory", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.max_header_list_size {
118 |     Some(v) => obj.set("maxHeaderListSize", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.max_outstanding_pings {
122 |     Some(v) => obj.set("maxOutstandingPings", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.max_send_header_block_length {
126 |     Some(v) => obj.set("maxSendHeaderBlockLength", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.padding_strategy {
130 |     Some(v) => obj.set("paddingStrategy", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   obj.to_any()
    | }
    …

    | pub fn SecureServerOptions::to_any(self : SecureServerOptions) -> @js.Any {
    |   let obj = @js.Object::new()
    |   match self.key {
157 |     Some(v) => obj.set("key", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.cert {
161 |     Some(v) => obj.set("cert", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.pfx {
165 |     Some(v) => obj.set("pfx", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.passphrase {
169 |     Some(v) => obj.set("passphrase", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.allow_http1 {
173 |     Some(v) => obj.set("allowHTTP1", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   obj.to_any()
    | }
    …

    | pub fn create_server(
    |   options : ServerOptions,
    |   request_handler : (@js.Object, @js.Object) -> Unit,
    | ) -> Http2Server {
195 |   ffi_create_server(options.to_any(), @js.from_fn2(request_handler))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn create_secure_server(
    |   options : SecureServerOptions,
    |   request_handler : (@js.Object, @js.Object) -> Unit,
    | ) -> Http2SecureServer {
214 |   ffi_create_secure_server(options.to_any(), @js.from_fn2(request_handler))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Http2Server::listen(
    |   self : Http2Server,
    |   port : Int,
    |   callback : () -> Unit,
    | ) -> Unit {
224 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   self.call2("listen", port, cb) |> ignore
    | }
    …

    | pub fn Http2SecureServer::listen(
    |   self : Http2SecureServer,
    |   port : Int,
    |   callback : () -> Unit,
    | ) -> Unit {
235 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   self.call2("listen", port, cb) |> ignore
    | }
    …

    | pub fn Http2Server::close(self : Http2Server, callback : () -> Unit) -> Unit {
242 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   self.call("close", [cb]) |> ignore
    | }
    …

    | pub fn Http2SecureServer::close(
    |   self : Http2SecureServer,
    |   callback : () -> Unit,
    | ) -> Unit {
252 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   self.call("close", [cb]) |> ignore
    | }
    …

    | pub fn connect(authority : String) -> Http2Session {
269 |   ffi_connect(authority, @js.undefined())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Http2Session::request(
    |   self : Http2Session,
    |   headers : @js.Object,
    | ) -> ClientHttp2Stream {
278 |   self.call("request", [headers.to_any()]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Http2Session::close(self : Http2Session) -> Unit {
284 |   self.call0("close") |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Http2Session::ping(self : Http2Session, callback : () -> Unit) -> Unit {
290 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   self.call("ping", [cb]) |> ignore
    | }
    …

    | pub fn ServerHttp2Stream::respond(
    |   self : ServerHttp2Stream,
    |   headers : @js.Object,
    | ) -> Unit {
300 |   self.call("respond", [headers.to_any()]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ServerHttp2Stream::end(self : ServerHttp2Stream, data : String) -> Unit {
306 |   self.call("end", [data]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ClientHttp2Stream::write(
    |   self : ClientHttp2Stream,
    |   data : String,
    | ) -> Unit {
315 |   self.call("write", [data]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ClientHttp2Stream::end(self : ClientHttp2Stream) -> Unit {
321 |   self.call0("end") |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ClientHttp2Stream::on_data(
    |   self : ClientHttp2Stream,
    |   callback : (@js.Object) -> Unit,
    | ) -> ClientHttp2Stream {
330 |   self.addEventListener("data", fn(e : @js.Any) { callback(@js.identity(e)) })
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   self
    | }
    …

    | pub fn ClientHttp2Stream::on_response(
    |   self : ClientHttp2Stream,
    |   callback : (@js.Object) -> Unit,
    | ) -> ClientHttp2Stream {
340 |   self.addEventListener("response", fn(e : @js.Any) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     callback(@js.identity(e))
    |   })
    |   self
    | }
    …

    | pub fn ClientHttp2Stream::on_end(
    |   self : ClientHttp2Stream,
    |   callback : () -> Unit,
    | ) -> ClientHttp2Stream {
352 |   self.addEventListener("end", fn(_e : @js.Any) { callback() })
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   self
    | }
    …

25 uncovered line(s) in src/node/https/https.mbt:

    | pub fn AgentOptions::to_any(self : AgentOptions) -> @js.Any {
    |   let obj = @js.Object::new()
    |   match self.max_cached_sessions {
 43 |     Some(v) => obj.set("maxCachedSessions", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.servername {
 47 |     Some(v) => obj.set("servername", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.keep_alive {
 51 |     Some(v) => obj.set("keepAlive", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.keep_alive_msecs {
 55 |     Some(v) => obj.set("keepAliveMsecs", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.max_sockets {
 59 |     Some(v) => obj.set("maxSockets", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.max_free_sockets {
 63 |     Some(v) => obj.set("maxFreeSockets", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.timeout {
 67 |     Some(v) => obj.set("timeout", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   obj.to_any()
    | }
    …

    | pub fn ServerOptions::to_any(self : ServerOptions) -> @js.Any {
    |   let obj = @js.Object::new()
    |   match self.key {
118 |     Some(v) => obj.set("key", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.cert {
122 |     Some(v) => obj.set("cert", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.pfx {
126 |     Some(v) => obj.set("pfx", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.passphrase {
130 |     Some(v) => obj.set("passphrase", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   obj.to_any()
    | }
    …

    | pub fn create_server(
    |   options : ServerOptions,
    |   request_listener : (@js.Object, @js.Object) -> Unit,
    | ) -> Server {
152 |   let listener = @js.from_fn2(request_listener)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ffi_create_server(options.to_any(), listener)
    | }
    …

    | pub fn Server::listen(self : Server, port : Int, callback : () -> Unit) -> Unit {
159 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   self.call2("listen", port, cb) |> ignore
    | }
    …

    | pub fn Server::close(self : Server, callback : () -> Unit) -> Unit {
166 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   self.call("close", [cb]) |> ignore
    | }
    …

    | pub fn RequestOptions::to_any(self : RequestOptions) -> @js.Any {
    |   let obj = match self.headers {
    |     Some(h) => h
214 |     None => @js.Object::new()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   match self.method_ {
217 |     Some(v) => obj.set("method", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.host {
221 |     Some(v) => obj.set("host", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.port {
225 |     Some(v) => obj.set("port", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.path {
229 |     Some(v) => obj.set("path", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.agent {
233 |     Some(v) => obj.set("agent", v.to_any())
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.rejectUnauthorized {
237 |     Some(v) => obj.set("rejectUnauthorized", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   obj.to_any()
    | }
    …

    | pub fn request(
    |   options : RequestOptions,
    |   callback : (@js.Object) -> Unit,
    | ) -> ClientRequest {
259 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ffi_request(options.to_any(), cb)
    | }
    …

    | pub fn ClientRequest::write(self : ClientRequest, data : String) -> Unit {
266 |   self.call("write", [data]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ClientRequest::end(self : ClientRequest) -> Unit {
272 |   self.call0("end") |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn get(url : String, callback : (@js.Object) -> Unit) -> ClientRequest {
285 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ffi_get(url, cb)
    | }
    …

6 uncovered line(s) in src/node/inspector/inspector.mbt:

    | pub fn Session::connect_to_main_thread(self : Session) -> Unit {
 36 |   self.call("connectToMainThread", []) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Session::post(
    |   self : Session,
    |   method_ : String,
    |   params : @js.Object?,
    |   callback : (@js.Object?, @js.Object) -> Unit,
    | ) -> Unit {
 51 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match params {
    |     Some(p) => self.call("post", [method_, p.to_any(), cb]) |> ignore
    |     None => self.call("post", [method_, cb]) |> ignore
    |   }
    | }
    …

    | pub fn open(port : Int?, host : String?, wait : Bool?) -> @js.Object {
 61 |   match (port, host, wait) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(p), Some(h), Some(w)) => ffi_open_3(p, h, w)
    |     (Some(p), Some(h), None) => ffi_open_2(p, h)
    |     (Some(p), None, None) => ffi_open_1(p)
    |     _ => ffi_open_0()
    |   }
    | }
    …

    | pub fn close() -> Unit {
 87 |   ffi_close()
    |   ^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn url() -> String? {
    |   let result : @js.Any = ffi_url()
    |   let is_undef : Bool = @js.identity(@js.typeof_(result) == "undefined")
    |   if is_undef {
    |     None
    |   } else {
101 |     Some(@js.identity(result))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub fn wait_for_debugger() -> Unit {
111 |   ffi_wait_for_debugger()
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

10 uncovered line(s) in src/node/module/module.mbt:

    | #alias(enable_compile_cache)
    | pub fn enableCompileCache(cache_dir? : String) -> Unit {
    |   let mod = ffi_require_module()
    |   match cache_dir {
    |     Some(dir) =>
 63 |       mod.call("enableCompileCache", [
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         @js.from_entries_option_cast([("cacheDir", Some(dir))]),
    |       ])
 66 |       |> ignore
    |       ^^^^^^^^^ 	<-- UNCOVERED
    |     None => mod.call0("enableCompileCache") |> ignore
    |   }
    | }
    …

    | pub fn SourceMap::payload(self : Self) -> @js.Any {
132 |   self.get("payload")
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(find_entry)
    | pub fn SourceMap::findEntry(
    |   self : Self,
    |   line_number : Int,
    |   column_number : Int,
    | ) -> SourceMapEntry? {
144 |   self.call2("findEntry", line_number, column_number) |> @js.identity_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(original_line)
    | pub fn SourceMapEntry::originalLine(self : Self) -> Int {
161 |   self.get("originalLine").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(original_column)
    | pub fn SourceMapEntry::originalColumn(self : Self) -> Int {
168 |   self.get("originalColumn").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(original_source)
    | pub fn SourceMapEntry::originalSource(self : Self) -> String {
175 |   self.get("originalSource").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(generated_line)
    | pub fn SourceMapEntry::generatedLine(self : Self) -> Int {
182 |   self.get("generatedLine").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(generated_column)
    | pub fn SourceMapEntry::generatedColumn(self : Self) -> Int {
189 |   self.get("generatedColumn").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SourceMapEntry::name(self : Self) -> String? {
195 |   self.get("name") |> @js.identity_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

23 uncovered line(s) in src/node/net/net.mbt:

    | pub fn Socket::as_duplex(self : Socket) -> @stream.Duplex {
 22 |   @js.identity(self)
    |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Socket::connect(self : Socket, port : Int, host? : String) -> Socket {
 28 |   match host {
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(h) => self.call2("connect", port, h) |> @js.identity
    |     None => self.call("connect", [port]).cast()
    |   }
    | }
    …

    | pub fn Socket::write(self : Socket, data : String) -> Bool {
 37 |   self.call("write", [data]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Socket::end(self : Socket) -> Socket {
 43 |   self.call0("end") |> @js.identity
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Socket::pause(self : Socket) -> Socket {
 55 |   self.call0("pause") |> @js.identity
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Socket::resume_(self : Socket) -> Socket {
 61 |   self.call0("resume") |> @js.identity
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Socket::setEncoding(self : Socket, encoding : String) -> Socket {
 67 |   self.call("setEncoding", [encoding]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Socket::setKeepAlive(self : Socket, enable : Bool) -> Socket {
 73 |   self.call("setKeepAlive", [enable]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Socket::setNoDelay(self : Socket, noDelay : Bool) -> Socket {
 79 |   self.call("setNoDelay", [noDelay]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Socket::setTimeout(self : Socket, timeout : Int) -> Socket {
 85 |   self.call("setTimeout", [timeout]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Socket::remoteAddress(self : Socket) -> String? {
 91 |   self.get("remoteAddress") |> @js.identity_option
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Socket::remotePort(self : Socket) -> Int? {
 97 |   self.get("remotePort") |> @js.identity_option
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Socket::localAddress(self : Socket) -> String? {
103 |   self.get("localAddress") |> @js.identity_option
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Socket::localPort(self : Socket) -> Int? {
109 |   self.get("localPort") |> @js.identity_option
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Socket::bytesRead(self : Socket) -> Int {
121 |   self.get("bytesRead").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Socket::bytesWritten(self : Socket) -> Int {
127 |   self.get("bytesWritten").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Server::listen(
    |   self : Server,
    |   port : Int,
    |   host? : String,
    |   backlog? : Int,
    |   callback? : () -> Unit,
    | ) -> Server {
    |   // Register callback as 'listening' event listener if provided
    |   match callback {
    |     Some(cb) => self.once("listening", fn(_) { cb() })
    |     None => ()
    |   }
    | 
    |   // Call listen with port, host, and backlog
    |   match (host, backlog) {
159 |     (Some(h), Some(b)) => self.call("listen", [port, h, b]).cast()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(h), None) => self.call2("listen", port, h) |> @js.identity
161 |     (None, Some(b)) => self.call2("listen", port, b) |> @js.identity
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (None, None) => self.call("listen", [port]).cast()
    |   }
    | }
    …

    | pub fn Server::address(self : Server) -> @js.Any? {
175 |   self.call0("address") |> @js.identity_option
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Server::maxConnections(self : Server) -> Int? {
187 |   self.get("maxConnections") |> @js.identity_option
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Server::set_maxConnections(self : Server, max : Int) -> Unit {
193 |   self.set("maxConnections", max |> @js.any)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn createConnection(port : Int, host? : String) -> Socket {
    |   match host {
    |     Some(h) => net_module().call2("createConnection", port, h) |> @js.identity
203 |     None => net_module().call("createConnection", [port]).cast()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub fn connect(port : Int, host? : String) -> Socket {
210 |   createConnection(port, host?)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

3 uncovered line(s) in src/node/os/os.mbt:

    | #alias(userinfo_with_encoding)
    | pub fn userInfoWithEncoding(encoding : String) -> @js.Any {
149 |   os_module().call1("userInfo", @js.from_entries([("encoding", encoding)]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(get_priority)
    | pub fn getPriority(pid~ : Int?) -> Int {
    |   match pid {
175 |     Some(p) => @js.identity(os_module().call("getPriority", [p]))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => @js.identity(os_module().call0("getPriority"))
    |   }
    | }
    …

    | #alias(set_priority)
    | pub fn setPriority(priority : Int, pid~ : Int?) -> Unit {
184 |   match pid {
    |   ^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(p) => os_module().call2("setPriority", p, priority) |> ignore
    |     None => os_module().call("setPriority", [priority]) |> ignore
    |   }
    | }
    …

12 uncovered line(s) in src/node/process/process.mbt:

   | pub fn env() -> ProcessEnv {
16 |   @node.require("node:process").get("env").cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn argv() -> Array[String] {
24 |   @js.identity(process().get("argv"))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn version() -> String {
36 |   @js.identity(process().get("version"))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn versions() -> @js.Object {
42 |   @js.identity(process().get("version"))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn isTTY() -> Bool {
48 |   @js.identity(process().get("isTTY"))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn chdir(path : String) -> Unit {
54 |   @js.identity(process().get("chdir").call_self([path]))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn exit(code : Int) -> Unit {
60 |   process().get("exit").call_self([code]) |> ignore
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn exitCode() -> Int {
66 |   process().get("exitCode").cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn stdin() -> @stream.Stream {
71 |   @js.identity(process().get("stdin"))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn stdout() -> @stream.Stream {
76 |   @js.identity(process().get("stdout"))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn stderr() -> @stream.Stream {
81 |   @js.identity(process().get("stderr"))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn on(sig : String, listener : () -> Unit) -> Unit {
87 |   @js.identity(process().call2("on", sig, @js.from_fn0(listener)))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

9 uncovered line(s) in src/node/readline/readline.mbt:

    | pub fn InterfaceOptions::to_any(self : InterfaceOptions) -> @js.Object {
    |   let obj = @js.Object::new()
    |   obj.set("input", self.input)
    |   match self.output {
    |     Some(o) => obj.set("output", o)
 51 |     None => ()
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   match self.terminal {
 54 |     Some(t) => obj.set("terminal", t)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.history_size {
 58 |     Some(h) => obj.set("historySize", h)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.prompt {
 62 |     Some(p) => obj.set("prompt", p)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.cr_lf_delay {
 66 |     Some(d) => obj.set("crlfDelay", d)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.remove_history_duplicates {
 70 |     Some(r) => obj.set("removeHistoryDuplicates", r)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.escape_code_timeout {
 74 |     Some(e) => obj.set("escapeCodeTimeout", e)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.tab_size {
 78 |     Some(t) => obj.set("tabSize", t)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   obj
    | }
    …

    | pub fn create_interface(options : InterfaceOptions) -> Interface {
 87 |   create_interface_impl(options.to_any())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

9 uncovered line(s) in src/node/readline_promises/readline.mbt:

   | #alias(create_interface)
   | pub fn createInterface(
   |   input~ : @stream.Stream,
   |   output? : @stream.Stream,
   |   completer? : (String) -> Array[String],
   |   terminator? : String,
   |   history? : Array[String],
   |   removeHistoryDuplicates? : Bool,
   |   prompt? : String,
   |   crlfDelay? : Int,
   |   escapeCodeTimeout? : Int,
   |   tabSize? : Int,
   |   signal? : @js.AbortSignal,
   | ) -> Interface {
27 |   let opts = @js.from_entries_option([
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     ("input", Some(input.to_any())),
   |     ("output", output.map(x => x)),
   |     ("completer", completer.map(x => x |> @js.from_fn1)),
   |     ("terminator", terminator.map(x => x)),
   |     ("history", history.map(x => x |> @js.from_array)),
   |     ("removeHistoryDuplicates", removeHistoryDuplicates.map(x => x)),
   |     ("prompt", prompt.map(x => x)),
   |     ("crlfDelay", crlfDelay.map(x => x)),
   |     ("escapeCodeTimeout", escapeCodeTimeout.map(x => x)),
   |     ("tabSize", tabSize.map(x => x)),
   |     ("signal", signal.map(x => x)),
   |   ])
40 |   @js.identity(
   |   ^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     @node.require("node:readline/promises")
   |     .get("createInterface")
   |     .call_self([opts]),
   |   )
   | }
   …

   | pub fn Interface::question(self : Self, query : String) -> @js.Promise[String] {
49 |   self.call("question", [query]).cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Interface::commit(self : Self) -> @js.Promise[Unit] {
54 |   self.call0("commit").cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Interface::rollback(self : Self) -> Self {
59 |   self.call0("rollback").cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | #alias(cursor_to)
   | pub fn Interface::cursorTo(self : Self, x : Int, y? : Int) -> @js.Promise[Unit] {
65 |   self.call2("cursorTo", x, y).cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | #alias(move_cursor)
   | pub fn Interface::moveCursor(
   |   self : Self,
   |   dx : Int,
   |   dy? : Int,
   | ) -> @js.Promise[Unit] {
75 |   self.call2("moveCursor", dx, dy).cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | #alias(clear_line)
   | pub fn Interface::clearLine(self : Self, dir : Int) -> Self {
81 |   self.call("clearLine", [dir]).cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | #alias(clear_screen_down)
   | pub fn Interface::clearScreenDown(self : Self, dir : Int) -> Self {
87 |   self.call("clearScreenDown", [dir]).cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

71 uncovered line(s) in src/node/sqlite/sqlite.mbt:

    | pub fn[T, U] DatabaseSync::aggregate(
    |   self : Self,
    |   name : String,
    |   deterministic? : Bool,
    |   directOnly? : Bool,
    |   useBigIntArguments? : Bool,
    |   varargs? : Bool,
    |   start? : U,
    |   step? : (T, U) -> T,
    |   inverse? : (T, U) -> T,
    |   result? : (T) -> @js.Any,
    | ) -> Unit {
    |   let opts = @js.from_entries_option([
    |     ("deterministic", deterministic.map(x => x)),
    |     ("directOnly", directOnly.map(x => x)),
    |     ("useBigIntArguments", useBigIntArguments.map(x => x)),
    |     ("varargs", varargs.map(x => x)),
    |     ("start", start.map(fn(x) { x |> @js.unsafe_any })),
    |     ("step", step.map(fn(x) { x |> @js.unsafe_any })),
103 |     ("inverse", inverse.map(fn(x) { x |> @js.unsafe_any })),
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ("result", result.map(fn(x) { x |> @js.unsafe_any })),
    |   ])
    |   self.call2("aggregate", name, opts) |> ignore
    | }
    …

    | pub fn DatabaseSync::function(
    |   self : Self,
    |   name : String,
    |   func : (Array[@js.Any]) -> @js.Any,
    |   deterministic? : Bool,
    |   directOnly? : Bool,
    |   useBigIntArguments? : Bool,
    |   varargs? : Bool,
    | ) -> Unit {
119 |   let opts = @js.from_entries_option_cast([
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ("deterministic", deterministic),
    |     ("directOnly", directOnly),
    |     ("useBigIntArguments", useBigIntArguments),
    |     ("varargs", varargs),
    |   ])
125 |   self.call("function", [name, func |> @js.identity, opts]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(set_authorizer)
    | pub fn DatabaseSync::setAuthorizer(
    |   self : Self,
    |   callback : (Int, String?, String?, String?, String?) -> Int,
    | ) -> Unit {
134 |   self.call("setAuthorizer", [callback |> @js.unsafe_any]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DatabaseSync::location(self : Self, db_name? : String) -> String? {
    |   let args : Array[&@js.JsImpl] = if db_name is Some(name) {
140 |     [name]
    |     ^^^^^^ 	<-- UNCOVERED
    |   } else {
    |     []
    |   }
    |   let result = self.call("location", args)
    |   if @js.is_null(result) {
    |     None
    |   } else {
148 |     Some(@js.identity(result))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | #alias(load_extension)
    | pub fn DatabaseSync::loadExtension(self : Self, path : String) -> Unit {
155 |   self.call("loadExtension", [path]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DatabaseSync::open(self : Self) -> Unit {
178 |   self.call0("open") |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(create_tag_store)
    | pub fn DatabaseSync::createTagStore(
    |   self : Self,
    |   max_size? : Int,
    | ) -> SQLTagStore {
192 |   let args : Array[&@js.JsImpl] = if max_size is Some(size) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     [size]
    |   } else {
195 |     []
    |     ^^ 	<-- UNCOVERED
    |   }
197 |   self.call("createTagStore", args).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(apply_changeset)
    | pub fn DatabaseSync::applyChangeset(
    |   self : Self,
    |   changeset : @typedarray.Uint8Array,
    |   filter? : (@js.Any) -> Bool,
    |   onConflict? : (@js.Any?, @js.Any) -> Bool,
    | ) -> Bool {
    |   let opts = @js.from_entries_option_cast([
230 |     ("filter", filter.map(fn(f) { f |> @js.from_fn1 })),
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ("onConflict", onConflict.map(fn(oc) { oc |> @js.from_fn2 })),
    |   ])
    |   self.call2("applyChangeset", changeset, opts) |> @js.identity
    | }
    …

    | pub fn StatementSync::iterate(
    |   self : Self,
    |   named_parameters? : Map[String, &@js.JsImpl],
    |   anonymous_parameters? : Array[&@js.JsImpl],
    | ) -> @js.JsIterator[@js.Any] {
    |   let args : Array[&@js.JsImpl] = []
    |   if named_parameters is Some(params) {
332 |     let obj = @js.Object::new()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     for key, value in params {
334 |       obj.set(key, value.to_any())
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
336 |     args.push(obj)
    |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if anonymous_parameters is Some(params_arr) {
    |     for param in params_arr {
    |       args.push(param)
    |     }
    |   }
    |   self.call("iterate", args).cast()
    | }
    …

    | #alias(expanded_sql)
    | pub fn StatementSync::expandedSQL(self : Self) -> String {
349 |   self.get("expandedSQL").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SQLTagStore::capacity(self : Self) -> Int {
428 |   self.get("capacity").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SQLTagStore::size(self : Self) -> Int {
433 |   self.call0("size") |> @js.identity
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SQLTagStore::clear(self : Self) -> Unit {
438 |   self.call0("clear") |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SQLTagStore::db(self : Self) -> DatabaseSync {
443 |   self.get("db").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn backup(
    |   source_db : DatabaseSync,
    |   db_path : String,
    |   rate? : Int,
    |   source? : String,
    |   target? : String,
    |   progress? : (BackupProgress) -> Unit,
    | ) -> Unit {
461 |   let opts = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   if rate is Some(v) {
463 |     opts.set("rate", v)
    |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if source is Some(v) {
466 |     opts.set("source", v)
    |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if target is Some(v) {
469 |     opts.set("target", v)
    |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if progress is Some(f) {
472 |     opts.set("progress", f |> @js.from_fn1)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
474 |   let backup : @js.Any = @node.require("node:sqlite").get("backup")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   backup.call_self([source_db.to_any(), db_path, opts]) |> ignore
    | }
    …

    | fn get_constants() -> @js.Any {
481 |   let sqlite = @node.require("node:sqlite")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   sqlite.get("constants")
    | }
    …

    | pub fn sqlite_changeset_data() -> Int {
487 |   @js.identity(get_constants().get("SQLITE_CHANGESET_DATA"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_changeset_notfound() -> Int {
492 |   @js.identity(get_constants().get("SQLITE_CHANGESET_NOTFOUND"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_changeset_conflict() -> Int {
497 |   @js.identity(get_constants().get("SQLITE_CHANGESET_CONFLICT"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_changeset_foreign_key() -> Int {
502 |   @js.identity(get_constants().get("SQLITE_CHANGESET_FOREIGN_KEY"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_changeset_omit() -> Int {
507 |   @js.identity(get_constants().get("SQLITE_CHANGESET_OMIT"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_changeset_replace() -> Int {
512 |   @js.identity(get_constants().get("SQLITE_CHANGESET_REPLACE"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_changeset_abort() -> Int {
517 |   @js.identity(get_constants().get("SQLITE_CHANGESET_ABORT"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_deny() -> Int {
522 |   @js.identity(get_constants().get("SQLITE_DENY"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_ignore() -> Int {
527 |   @js.identity(get_constants().get("SQLITE_IGNORE"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_ok() -> Int {
532 |   @js.identity(get_constants().get("SQLITE_OK"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_create_index() -> Int {
537 |   @js.identity(get_constants().get("SQLITE_CREATE_INDEX"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_create_table() -> Int {
542 |   @js.identity(get_constants().get("SQLITE_CREATE_TABLE"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_create_temp_index() -> Int {
547 |   @js.identity(get_constants().get("SQLITE_CREATE_TEMP_INDEX"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_create_temp_table() -> Int {
552 |   @js.identity(get_constants().get("SQLITE_CREATE_TEMP_TABLE"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_create_temp_trigger() -> Int {
557 |   @js.identity(get_constants().get("SQLITE_CREATE_TEMP_TRIGGER"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_create_temp_view() -> Int {
562 |   @js.identity(get_constants().get("SQLITE_CREATE_TEMP_VIEW"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_create_trigger() -> Int {
567 |   @js.identity(get_constants().get("SQLITE_CREATE_TRIGGER"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_create_view() -> Int {
572 |   @js.identity(get_constants().get("SQLITE_CREATE_VIEW"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_delete() -> Int {
577 |   @js.identity(get_constants().get("SQLITE_DELETE"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_drop_index() -> Int {
582 |   @js.identity(get_constants().get("SQLITE_DROP_INDEX"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_drop_table() -> Int {
587 |   @js.identity(get_constants().get("SQLITE_DROP_TABLE"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_drop_temp_index() -> Int {
592 |   @js.identity(get_constants().get("SQLITE_DROP_TEMP_INDEX"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_drop_temp_table() -> Int {
597 |   @js.identity(get_constants().get("SQLITE_DROP_TEMP_TABLE"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_drop_temp_trigger() -> Int {
602 |   @js.identity(get_constants().get("SQLITE_DROP_TEMP_TRIGGER"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_drop_temp_view() -> Int {
607 |   @js.identity(get_constants().get("SQLITE_DROP_TEMP_VIEW"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_drop_trigger() -> Int {
612 |   @js.identity(get_constants().get("SQLITE_DROP_TRIGGER"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_drop_view() -> Int {
617 |   @js.identity(get_constants().get("SQLITE_DROP_VIEW"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_insert() -> Int {
622 |   @js.identity(get_constants().get("SQLITE_INSERT"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_pragma() -> Int {
627 |   @js.identity(get_constants().get("SQLITE_PRAGMA"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_read() -> Int {
632 |   @js.identity(get_constants().get("SQLITE_READ"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_select() -> Int {
637 |   @js.identity(get_constants().get("SQLITE_SELECT"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_transaction() -> Int {
642 |   @js.identity(get_constants().get("SQLITE_TRANSACTION"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_update() -> Int {
647 |   @js.identity(get_constants().get("SQLITE_UPDATE"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_attach() -> Int {
652 |   @js.identity(get_constants().get("SQLITE_ATTACH"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_detach() -> Int {
657 |   @js.identity(get_constants().get("SQLITE_DETACH"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_alter_table() -> Int {
662 |   @js.identity(get_constants().get("SQLITE_ALTER_TABLE"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_reindex() -> Int {
667 |   @js.identity(get_constants().get("SQLITE_REINDEX"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_analyze() -> Int {
672 |   @js.identity(get_constants().get("SQLITE_ANALYZE"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_create_vtable() -> Int {
677 |   @js.identity(get_constants().get("SQLITE_CREATE_VTABLE"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_drop_vtable() -> Int {
682 |   @js.identity(get_constants().get("SQLITE_DROP_VTABLE"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_function() -> Int {
687 |   @js.identity(get_constants().get("SQLITE_FUNCTION"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_savepoint() -> Int {
692 |   @js.identity(get_constants().get("SQLITE_SAVEPOINT"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_copy() -> Int {
697 |   @js.identity(get_constants().get("SQLITE_COPY"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_recursive() -> Int {
702 |   @js.identity(get_constants().get("SQLITE_RECURSIVE"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

35 uncovered line(s) in src/node/stream/stream.mbt:

    | fn stream_module() -> @js.Any {
  8 |   @node.require("node:stream")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Readable::destroy(self : Readable, error? : @js.Any) -> Readable {
 80 |   self.call("destroy", [error]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Readable::unshift(
    |   self : Readable,
    |   chunk : @js.Any,
    |   encoding? : String,
    | ) -> Unit {
 89 |   ignore(self.call2("unshift", chunk, encoding))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Readable::readableEncoding(self : Readable) -> @js.Any {
100 |   self.get("readableEncoding")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Readable::readableEnded(self : Readable) -> Bool {
105 |   self.get("readableEnded").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Readable::readableFlowing(self : Readable) -> @js.Any {
110 |   self.get("readableFlowing")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Readable::readableHighWaterMark(self : Readable) -> Int {
115 |   self.get("readableHighWaterMark").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Readable::readableLength(self : Readable) -> Int {
120 |   self.get("readableLength").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Readable::closed(self : Readable) -> Bool {
130 |   self.get("closed").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Readable::errored(self : Readable) -> @js.Any {
135 |   self.get("errored")
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Readable::toWeb(self : Readable) -> @web.ReadableStream {
141 |   stream_module().get("Readable").call("toWeb", [self]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Readable::fromWeb(s : @web.ReadableStream) -> Readable {
146 |   stream_module().get("Readable").call("fromWeb", [s]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Readable::from(iterable : @js.Any) -> Readable {
151 |   stream_module().get("Readable").call("from", [iterable]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Writable::end(
    |   self : Writable,
    |   chunk? : @js.Any,
    |   encoding? : String,
    |   callback? : @js.Any,
    | ) -> Writable {
185 |   self.call("end", [chunk, encoding, callback]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Writable::destroy(self : Writable, error? : @js.Any) -> Writable {
200 |   self.call("destroy", [error]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Writable::setDefaultEncoding(
    |   self : Writable,
    |   encoding : String,
    | ) -> Writable {
208 |   self.call("setDefaultEncoding", [encoding]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Writable::writableEnded(self : Writable) -> Bool {
219 |   self.get("writableEnded").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Writable::writableFinished(self : Writable) -> Bool {
224 |   self.get("writableFinished").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Writable::writableHighWaterMark(self : Writable) -> Int {
229 |   self.get("writableHighWaterMark").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Writable::writableLength(self : Writable) -> Int {
234 |   self.get("writableLength").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Writable::closed(self : Writable) -> Bool {
249 |   self.get("closed").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Writable::errored(self : Writable) -> @js.Any {
254 |   self.get("errored")
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Writable::toWeb(self : Self) -> @web.WritableStream {
260 |   stream_module().get("Writable").call("toWeb", [self]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Writable::fromWeb(s : @web.WritableStream) -> Writable {
265 |   stream_module().get("Writable").call("fromWeb", [s]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Duplex::allowHalfOpen(self : Duplex) -> Bool {
284 |   self.get("allowHalfOpen").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Duplex::toWeb(self : Duplex) -> @js.Any {
290 |   stream_module().get("Duplex").call("toWeb", [self])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Duplex::fromWeb(pair : @js.Any) -> Duplex {
295 |   stream_module().get("Duplex").call("fromWeb", [pair]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Duplex::from(src : @js.Any) -> Duplex {
300 |   stream_module().get("Duplex").call("from", [src]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn compose(streams : Array[@js.Any]) -> @js.Any {
373 |   ffi_compose(@js.identity(streams))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn addAbortSignal(signal : @js.Any, stream : @js.Any) -> @js.Any {
378 |   stream_module().call2("addAbortSignal", signal, stream)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn isErrored(stream : @js.Any) -> Bool {
383 |   stream_module().call("isErrored", [stream]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn isReadable(stream : @js.Any) -> Bool {
388 |   stream_module().call("isReadable", [stream]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn isWritable(stream : @js.Any) -> Bool {
393 |   stream_module().call("isWritable", [stream]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn getDefaultHighWaterMark(objectMode : Bool) -> Int {
398 |   stream_module().call("getDefaultHighWaterMark", [objectMode]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn setDefaultHighWaterMark(objectMode : Bool, value : Int) -> Unit {
403 |   ignore(stream_module().call2("setDefaultHighWaterMark", objectMode, value))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

15 uncovered line(s) in src/node/test/mock.mbt:

    | pub fn MockTracker::fn_(
    |   self : MockTracker,
    |   original? : @js.Any,
    |   implementation? : @js.Any,
    | ) -> @js.Any {
    |   match (original, implementation) {
    |     (Some(orig), Some(imp)) => self.call2("fn", orig, imp)
 37 |     (Some(orig), None) => self.call("fn", [orig])
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (None, Some(imp)) => self.call("fn", [imp])
    |     (None, None) => self.call0("fn")
    |   }
    | }
    …

    | pub fn MockTracker::getter_(
    |   self : MockTracker,
    |   object : @js.Any,
    |   methodName : String,
    |   implementation? : @js.Any,
    | ) -> @js.Any {
 67 |   match implementation {
    |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(imp) => self.call("getter", [object, methodName, imp])
    |     None => self.call2("getter", object, methodName)
    |   }
    | }
    …

    | pub fn MockTracker::setter_(
    |   self : MockTracker,
    |   object : @js.Any,
    |   methodName : String,
    |   implementation? : @js.Any,
    | ) -> @js.Any {
 82 |   match implementation {
    |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(imp) => self.call("setter", [object, methodName, imp])
    |     None => self.call2("setter", object, methodName)
    |   }
    | }
    …

    | pub fn MockTracker::module_(
    |   self : MockTracker,
    |   specifier : String,
    |   defaultExport? : @js.Any,
    |   namedExports? : @js.Any,
    | ) -> Unit {
 97 |   let options = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   if defaultExport is Some(exp) {
 99 |     options.set("defaultExport", exp)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if namedExports is Some(exp) {
102 |     options.set("namedExports", exp)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
104 |   self.call2("module", @js.any(specifier), options) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MockTracker::property_(
    |   self : MockTracker,
    |   object : @js.Any,
    |   propertyName : String,
    |   value? : @js.Any,
    | ) -> @js.Any {
116 |   match value {
    |   ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(val) => self.call("property", [object, propertyName, val])
    |     None => self.call2("property", object, propertyName)
    |   }
    | }
    …

    | pub fn MockTracker::reset(self : MockTracker) -> Unit {
125 |   self.call0("reset") |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MockFunctionContext::calls(self : MockFunctionContext) -> Array[@js.Any] {
140 |   self.get("calls").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MockFunctionContext::mockImplementation(
    |   self : MockFunctionContext,
    |   implementation : @js.Any,
    | ) -> Unit {
155 |   self.call("mockImplementation", [implementation]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MockFunctionContext::mockImplementationOnce(
    |   self : MockFunctionContext,
    |   implementation : @js.Any,
    |   onCall? : Int,
    | ) -> Unit {
165 |   match onCall {
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(call) =>
167 |       self.call2("mockImplementationOnce", implementation, call) |> ignore
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => self.call("mockImplementationOnce", [implementation]) |> ignore
    |   }
    | }
    …

    | pub fn MockFunctionContext::resetCalls(self : MockFunctionContext) -> Unit {
175 |   self.call0("resetCalls") |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MockFunctionContext::restore(self : MockFunctionContext) -> Unit {
181 |   self.call0("restore") |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

60 uncovered line(s) in src/node/test/nodetest.mbt:

    | pub fn TestContext::skip(self : Self, message? : String) -> Unit {
 24 |   match message {
    |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(msg) => self.call("skip", [@js.any(msg)]) |> ignore
    |     None => self.call0("skip") |> ignore
    |   }
    | }
    …

    | pub fn TestContext::todo(self : Self, message? : String) -> Unit {
 32 |   match message {
    |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(msg) => self.call("todo", [@js.any(msg)]) |> ignore
    |     None => self.call0("todo") |> ignore
    |   }
    | }
    …

    | pub fn TestContext::diagnostic(self : Self, message : String) -> Unit {
 40 |   self.call("diagnostic", [@js.any(message)]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn TestContext::plan(self : Self, count : Int) -> Unit {
 45 |   self.call("plan", [@js.any(count)]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn TestContext::runOnly(self : Self, shouldRunOnlyTests : Bool) -> Unit {
 50 |   self.call("runOnly", [@js.any(shouldRunOnlyTests)]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | fn TestContext::assert_obj(self : Self) -> @js.Any {
 58 |   self.get("assert")
    |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn TestContext::assert_ok(
    |   self : Self,
    |   value : Bool,
    |   message? : String,
    | ) -> Unit {
 68 |   let assert_obj = self.assert_obj()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match message {
    |     Some(msg) => assert_obj.call2("ok", value, msg) |> ignore
    |     None => assert_obj.call1("ok", value) |> ignore
    |   }
    | }
    …

    | pub fn[T : @js.JsImpl] TestContext::assert_strict_equal(
    |   self : Self,
    |   actual : T,
    |   expected : T,
    |   message? : String,
    | ) -> Unit {
 83 |   let assert_obj = self.assert_obj()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match message {
    |     Some(msg) =>
 86 |       assert_obj.call("strictEqual", [actual, expected, msg]) |> ignore
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => assert_obj.call2("strictEqual", actual, expected) |> ignore
    |   }
    | }
    …

    | pub fn[T : @js.JsImpl] TestContext::assert_not_strict_equal(
    |   self : Self,
    |   actual : T,
    |   expected : T,
    |   message? : String,
    | ) -> Unit {
 99 |   let assert_obj = self.assert_obj()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match message {
    |     Some(msg) =>
102 |       assert_obj.call("notStrictEqual", [actual, expected, msg]) |> ignore
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => assert_obj.call2("notStrictEqual", actual, expected) |> ignore
    |   }
    | }
    …

    | pub fn[T : @js.JsImpl] TestContext::assert_deep_strict_equal(
    |   self : Self,
    |   actual : T,
    |   expected : T,
    |   message? : String,
    | ) -> Unit {
115 |   let assert_obj = self.assert_obj()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match message {
    |     Some(msg) =>
118 |       assert_obj.call("deepStrictEqual", [actual, expected, msg]) |> ignore
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => assert_obj.call2("deepStrictEqual", actual, expected) |> ignore
    |   }
    | }
    …

    | pub fn[T : @js.JsImpl] TestContext::assert_not_deep_strict_equal(
    |   self : Self,
    |   actual : T,
    |   expected : T,
    |   message? : String,
    | ) -> Unit {
131 |   let assert_obj = self.assert_obj()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match message {
    |     Some(msg) =>
134 |       assert_obj.call("notDeepStrictEqual", [actual, expected, msg]) |> ignore
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => assert_obj.call2("notDeepStrictEqual", actual, expected) |> ignore
    |   }
    | }
    …

    | pub fn TestContext::assert_match(
    |   self : Self,
    |   string : String,
    |   regexp : @regexp.RegExp,
    |   message? : String,
    | ) -> Unit {
147 |   let assert_obj = self.assert_obj()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match message {
    |     Some(msg) => assert_obj.call("match", [string, regexp, msg]) |> ignore
    |     None => assert_obj.call2("match", string, regexp) |> ignore
    |   }
    | }
    …

    | pub fn TestContext::assert_does_not_match(
    |   self : Self,
    |   string : String,
    |   regexp : @regexp.RegExp,
    |   message? : String,
    | ) -> Unit {
162 |   let assert_obj = self.assert_obj()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match message {
    |     Some(msg) =>
165 |       assert_obj.call("doesNotMatch", [string, regexp, msg]) |> ignore
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => assert_obj.call2("doesNotMatch", string, regexp) |> ignore
    |   }
    | }
    …

    | pub fn TestContext::assert_throws(
    |   self : Self,
    |   fn_ : () -> Unit,
    |   error? : @js.Any,
    |   message? : String,
    | ) -> Unit {
178 |   let assert_obj = self.assert_obj()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let fn_js = @js.from_fn0(fn_)
    |   match (error, message) {
    |     (Some(err), Some(msg)) =>
182 |       assert_obj.call("throws", [fn_js, err, msg]) |> ignore
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(err), None) => assert_obj.call2("throws", fn_js, err) |> ignore
    |     (None, Some(msg)) => assert_obj.call2("throws", fn_js, msg) |> ignore
    |     (None, None) => assert_obj.call1("throws", fn_js) |> ignore
    |   }
    | }
    …

    | pub fn TestContext::assert_does_not_throw(
    |   self : Self,
    |   fn_ : () -> Unit,
    |   error? : @js.Any,
    |   message? : String,
    | ) -> Unit {
197 |   let assert_obj = self.assert_obj()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let fn_js = @js.from_fn0(fn_)
    |   match (error, message) {
    |     (Some(err), Some(msg)) =>
201 |       assert_obj.call("doesNotThrow", [fn_js, err, msg]) |> ignore
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(err), None) => assert_obj.call2("doesNotThrow", fn_js, err) |> ignore
    |     (None, Some(msg)) => assert_obj.call2("doesNotThrow", fn_js, msg) |> ignore
    |     (None, None) => assert_obj.call1("doesNotThrow", fn_js) |> ignore
    |   }
    | }
    …

    | pub fn TestContext::assert_rejects(
    |   self : Self,
    |   asyncFn : async () -> Unit,
    |   error? : @js.Any,
    |   message? : String,
    | ) -> Unit {
217 |   let assert_obj = self.assert_obj()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let promise_js : @js.Any = @js.promisify0(asyncFn)() |> @js.identity
    |   match (error, message) {
    |     (Some(err), Some(msg)) =>
221 |       assert_obj.call("rejects", [promise_js, err, msg]) |> ignore
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(err), None) => assert_obj.call2("rejects", promise_js, err) |> ignore
    |     (None, Some(msg)) => assert_obj.call2("rejects", promise_js, msg) |> ignore
    |     (None, None) => assert_obj.call1("rejects", promise_js) |> ignore
    |   }
    | }
    …

    | pub fn TestContext::assert_does_not_reject(
    |   self : Self,
    |   asyncFn : async () -> Unit,
    |   error? : @js.Any,
    |   message? : String,
    | ) -> Unit {
236 |   let assert_obj = self.assert_obj()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let promise_js : @js.Any = @js.promisify0(asyncFn)() |> @js.identity
    |   match (error, message) {
    |     (Some(err), Some(msg)) =>
240 |       assert_obj.call("doesNotReject", [promise_js, err, msg]) |> ignore
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(err), None) =>
242 |       assert_obj.call2("doesNotReject", promise_js, err) |> ignore
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (None, Some(msg)) =>
244 |       assert_obj.call2("doesNotReject", promise_js, msg) |> ignore
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (None, None) => assert_obj.call1("doesNotReject", promise_js) |> ignore
    |   }
    | }
    …

    | pub fn test_(
    |   name : String,
    |   skip? : Bool,
    |   todo? : Bool,
    |   only? : Bool,
    |   timeout? : Int,
    |   f : async (TestContext) -> Unit,
    | ) -> Unit {
261 |   let options = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   if skip is Some(true) {
263 |     options.set("skip", true)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if todo is Some(true) {
266 |     options.set("todo", true)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if only is Some(true) {
269 |     options.set("only", true)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if timeout is Some(t) {
272 |     options.set("timeout", t)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
274 |   nodetest().call("test", [name, options, @js.promisify1(f) |> @js.from_fn1])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   |> ignore
    | }
    …

    | pub fn it(
    |   name : String,
    |   skip? : String,
    |   todo? : String,
    |   only? : Bool,
    |   timeout? : Int,
    |   f : async (TestContext) -> Unit,
    | ) -> Unit {
288 |   let options = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   if skip is Some(s) {
290 |     options.set("skip", s)
    |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if todo is Some(t) {
293 |     options.set("todo", t)
    |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if only is Some(true) {
296 |     options.set("only", true)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if timeout is Some(t) {
299 |     options.set("timeout", t)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
301 |   nodetest().call("it", [name, options, @js.promisify1(f) |> @js.from_fn1])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   |> ignore
    | }
    …

    | pub fn describe(
    |   name : String,
    |   skip? : Bool,
    |   todo? : Bool,
    |   only? : Bool,
    |   timeout? : Int,
    |   f : async (SuiteContext) -> Unit,
    | ) -> Unit {
315 |   let options = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   if skip is Some(true) {
317 |     options.set("skip", true)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if todo is Some(true) {
320 |     options.set("todo", true)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if only is Some(true) {
323 |     options.set("only", true)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if timeout is Some(t) {
326 |     options.set("timeout", t)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
328 |   nodetest().call("describe", [name, options, @js.promisify1(f) |> @js.from_fn1])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   |> ignore
    | }
    …

    | pub fn before(f : async () -> Unit, timeout? : Int) -> Unit {
337 |   let options = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   if timeout is Some(t) {
339 |     options.set("timeout", t)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
341 |   nodetest().call2("before", @js.promisify0(f) |> @js.from_fn0, options)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   |> ignore
    | }
    …

    | pub fn after(f : async () -> Unit, timeout? : Int) -> Unit {
348 |   let options = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   if timeout is Some(t) {
350 |     options.set("timeout", t)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
352 |   nodetest().call2("after", @js.promisify0(f) |> @js.from_fn0, options)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   |> ignore
    | }
    …

    | pub fn beforeEach(f : async () -> Unit, timeout? : Int) -> Unit {
359 |   let options = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   if timeout is Some(t) {
361 |     options.set("timeout", t)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
363 |   nodetest().call2("beforeEach", @js.promisify0(f) |> @js.from_fn0, options)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   |> ignore
    | }
    …

    | pub fn afterEach(f : async () -> Unit, timeout? : Int) -> Unit {
370 |   let options = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   if timeout is Some(t) {
372 |     options.set("timeout", t)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
374 |   nodetest().call2("afterEach", @js.promisify0(f) |> @js.from_fn0, options)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   |> ignore
    | }
    …

    | #alias(before_all)
    | pub fn beforeAll(f : async () -> Unit) -> Unit {
382 |   before(f)
    |   ^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(after_all)
    | pub fn afterAll(f : async () -> Unit) -> Unit {
388 |   after(f)
    |   ^^^^^^^^ 	<-- UNCOVERED
    | }
    …

5 uncovered line(s) in src/node/test/run.mbt:

   | pub fn run(
   |   files? : Array[String],
   |   cwd? : String,
   |   forceExit? : Bool,
   |   inspectPort? : Int,
   |   only? : Bool,
   |   concurrency? : Int,
   |   globPatterns? : Array[String],
   |   isolation? : Bool,
   |   execArgv? : Array[String],
   |   argv? : Array[String],
   |   watch? : Bool,
   |   shard? : TestShard,
   |   signal? : @js.AbortSignal,
   |   testNamePatterns? : Array[String],
   |   testSkipPatterns? : Array[String],
   |   timeout? : Int,
   |   rerunFailuresFilePath? : String,
   |   setup? : () -> Unit,
   | 
   |   // coverage
   |   coverage? : Bool,
   |   lineCoverage? : Bool,
   |   functionCoverage? : Bool,
   |   branchCoverage? : Bool,
   |   coverageIncludeGlobs? : Array[String],
   |   coverageExcludeGlobs? : Array[String],
   | ) -> @stream.Stream {
41 |   let obj = @js.from_entries_option([
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     ("files", files.map(fn(x) { @js.from_array(x) })),
   |     ("cwd", cwd.map(x => x)),
   |     ("forceExit", forceExit.map(x => x)),
   |     ("only", only.map(x => x)),
   |     ("inspectPort", inspectPort.map(x => x)),
   |     ("concurrency", concurrency.map(x => x)),
   |     ("globPatterns", globPatterns.map(fn(x) { @js.from_array(x) })),
   |     ("isolation", isolation.map(x => x)),
   |     ("execArgv", execArgv.map(fn(x) { @js.from_array(x) })),
   |     ("argv", argv.map(fn(x) { @js.from_array(x) })),
   |     ("coverage", coverage.map(x => x)),
   |     ("lineCoverage", lineCoverage.map(x => x)),
   |     ("functionCoverage", functionCoverage.map(x => x)),
   |     ("branchCoverage", branchCoverage.map(x => x)),
   |     (
   |       "coverageIncludeGlobs",
58 |       coverageIncludeGlobs.map(fn(x) { @js.from_array(x) }),
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     ),
   |     (
   |       "coverageExcludeGlobs",
62 |       coverageExcludeGlobs.map(fn(x) { @js.from_array(x) }),
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     ),
64 |     ("watch", watch.map(x => x)),
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     ("signal", signal.map(x => x)),
   |     ("testNamePatterns", testNamePatterns.map(fn(x) { @js.from_array(x) })),
   |     ("testSkipPatterns", testSkipPatterns.map(fn(x) { @js.from_array(x) })),
   |     ("timeout", timeout.map(x => x)),
   |     ("shard", shard.map(x => x)),
   |     ("rerunFailuresFilePath", rerunFailuresFilePath.map(x => x)),
   |     ("setup", setup.map(fn(x) { @js.from_fn0(x) })),
   |   ])
73 |   nodetest().call("run", [obj]).cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

6 uncovered line(s) in src/node/test/snapshot.mbt:

   | pub fn TestContext::assert_snapshot(
   |   self : TestContext,
   |   value : &@js.JsImpl,
   |   message? : String,
   | ) -> Unit {
15 |   let assert_obj = self.get("assert")
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   match message {
   |     Some(msg) => assert_obj.call2("snapshot", value.to_any(), msg) |> ignore
   |     None => assert_obj.call("snapshot", [value.to_any()]) |> ignore
   |   }
   | }
   …

   | pub fn TestContext::assert_fileSnapshot(
   |   self : TestContext,
   |   value : &@js.JsImpl,
   |   path : String,
   |   message? : String,
   | ) -> Unit {
30 |   let assert_obj = self.get("assert")
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   match message {
   |     Some(msg) =>
33 |       assert_obj.call("fileSnapshot", [value.to_any(), path, msg]) |> ignore
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     None => assert_obj.call2("fileSnapshot", value.to_any(), path) |> ignore
   |   }
   | }
   …

   | fn snapshot_module() -> @js.Any {
43 |   nodetest().get("snapshot")
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn setDefaultSnapshotSerializers(serializers : Array[&@js.JsImpl]) -> Unit {
49 |   let s = snapshot_module()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   s.call("setDefaultSnapshotSerializers", [@js.from_array(serializers)])
   |   |> ignore
   | }
   …

   | pub fn setResolveSnapshotPath(fn_ : (String) -> String) -> Unit {
57 |   let s = snapshot_module()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   s.call("setResolveSnapshotPath", [@js.from_fn1(fn_)]) |> ignore
   | }
   …

2 uncovered line(s) in src/node/test/timers.mbt:

   | pub fn MockTimers::runAll(self : MockTimers) -> Unit {
47 |   self.call0("runAll") |> ignore
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn MockTimers::setTime(self : MockTimers, milliseconds : Int) -> Unit {
61 |   self.call("setTime", [@js.any(milliseconds)]) |> ignore
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

38 uncovered line(s) in src/node/tls/tls.mbt:

    | pub fn ServerOptions::to_any(self : ServerOptions) -> @js.Any {
    |   let obj = @js.Object::new()
    |   match self.key {
 60 |     Some(v) => obj.set("key", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.cert {
 64 |     Some(v) => obj.set("cert", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.ca {
 68 |     Some(v) => obj.set("ca", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.pfx {
 72 |     Some(v) => obj.set("pfx", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.passphrase {
 76 |     Some(v) => obj.set("passphrase", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.rejectUnauthorized {
 80 |     Some(v) => obj.set("rejectUnauthorized", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.requestCert {
 84 |     Some(v) => obj.set("requestCert", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.alpn_protocols {
 88 |     Some(v) => {
    |     ^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let arr = @js.JsArray::new()
    |       let mut i = 0
    |       while i < v.length() {
 92 |         arr.call("push", [v[i]]) |> ignore
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         i = i + 1
    |       }
 95 |       obj.set("ALPNProtocols", arr)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     None => ()
    |   }
    |   obj.to_any()
    | }
    …

    | pub fn create_server(
    |   options : ServerOptions,
    |   secureConnectionListener : (TLSSocket) -> Unit,
    | ) -> Server {
118 |   let cb : @js.Any = @js.identity(secureConnectionListener)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ffi_create_server(options.to_any(), cb)
    | }
    …

    | pub fn Server::listen(self : Server, port : Int, callback : () -> Unit) -> Unit {
125 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   self.call2("listen", port, cb) |> ignore
    | }
    …

    | pub fn Server::close(self : Server, callback : () -> Unit) -> Unit {
132 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   self.call("close", [cb]) |> ignore
    | }
    …

    | pub fn ConnectOptions::to_any(self : ConnectOptions) -> @js.Any {
    |   let obj = @js.Object::new()
    |   match self.host {
    |     Some(v) => obj.set("host", v)
172 |     None => ()
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   match self.port {
    |     Some(v) => obj.set("port", v)
176 |     None => ()
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   match self.servername {
179 |     Some(v) => obj.set("servername", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.key {
183 |     Some(v) => obj.set("key", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.cert {
187 |     Some(v) => obj.set("cert", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.ca {
191 |     Some(v) => obj.set("ca", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.rejectUnauthorized {
195 |     Some(v) => obj.set("rejectUnauthorized", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.alpn_protocols {
199 |     Some(v) => {
    |     ^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let arr = @js.JsArray::new()
    |       let mut i = 0
    |       while i < v.length() {
203 |         arr.call("push", [v[i]]) |> ignore
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         i = i + 1
    |       }
206 |       obj.set("ALPNProtocols", arr)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     None => ()
    |   }
    |   match self.session {
211 |     Some(v) => obj.set("session", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   obj.to_any()
    | }
    …

    | pub fn connect(options : ConnectOptions, callback : () -> Unit) -> TLSSocket {
227 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ffi_connect(options.to_any(), cb)
    | }
    …

    | pub fn TLSSocket::get_peer_certificate(
    |   self : TLSSocket,
    |   detailed : Bool,
    | ) -> @js.Object {
237 |   let val : @js.Any = self.call("getPeerCertificate", [detailed])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @js.identity(val)
    | }
    …

    | pub fn TLSSocket::get_cipher(self : TLSSocket) -> @js.Object {
244 |   let val : @js.Any = self.call0("getCipher")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @js.identity(val)
    | }
    …

    | pub fn TLSSocket::get_protocol(self : TLSSocket) -> String {
251 |   let val : @js.Any = self.call0("getProtocol")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @js.identity(val)
    | }
    …

    | pub fn TLSSocket::authorized(self : TLSSocket) -> Bool {
258 |   let val : @js.Any = self.get("authorized")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @js.identity(val)
    | }
    …

    | pub fn TLSSocket::authorization_error(self : TLSSocket) -> String? {
265 |   let val : @js.Any = self.get("authorizationError")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let is_null : Bool = @js.identity(@js.typeof_(val) == "undefined")
    |   if is_null {
268 |     None
    |     ^^^^ 	<-- UNCOVERED
    |   } else {
270 |     Some(@js.identity(val))
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub fn TLSSocket::write(self : TLSSocket, data : String) -> Unit {
277 |   self.call("write", [data]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn TLSSocket::end(self : TLSSocket) -> Unit {
283 |   self.call0("end") |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn TLSSocket::on_secure_connect(
    |   self : TLSSocket,
    |   callback : () -> Unit,
    | ) -> TLSSocket {
292 |   self.addEventListener("secureConnect", fn(_e : @js.Any) { callback() })
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   self
    | }
    …

    | pub fn TLSSocket::on_data(
    |   self : TLSSocket,
    |   callback : (@js.Object) -> Unit,
    | ) -> TLSSocket {
302 |   self.addEventListener("data", fn(e : @js.Any) { callback(@js.identity(e)) })
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   self
    | }
    …

    | pub fn TLSSocket::on_end(self : TLSSocket, callback : () -> Unit) -> TLSSocket {
309 |   self.addEventListener("end", fn(_e : @js.Any) { callback() })
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   self
    | }
    …

    | pub fn TLSSocket::on_error(
    |   self : TLSSocket,
    |   callback : (@js.Object) -> Unit,
    | ) -> TLSSocket {
319 |   self.addEventListener("error", fn(e : @js.Any) { callback(@js.identity(e)) })
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   self
    | }
    …

14 uncovered line(s) in src/node/tty/tty.mbt:

    | pub fn ReadStream::is_tty(self : ReadStream) -> Bool {
 18 |   let val : @js.Any = self.get("isTTY")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @js.identity(val)
    | }
    …

    | pub fn ReadStream::is_raw(self : ReadStream) -> Bool {
 25 |   let val : @js.Any = self.get("isRaw")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @js.identity(val)
    | }
    …

    | pub fn ReadStream::set_raw_mode(self : ReadStream, mode : Bool) -> Unit {
 33 |   self.call("setRawMode", [mode]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn WriteStream::is_tty(self : WriteStream) -> Bool {
 51 |   let val : @js.Any = self.get("isTTY")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @js.identity(val)
    | }
    …

    | pub fn WriteStream::columns(self : WriteStream) -> Int {
 58 |   let val : @js.Any = self.get("columns")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @js.identity(val)
    | }
    …

    | pub fn WriteStream::rows(self : WriteStream) -> Int {
 65 |   let val : @js.Any = self.get("rows")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @js.identity(val)
    | }
    …

    | pub fn WriteStream::clear_line(
    |   self : WriteStream,
    |   dir : Int,
    |   callback : () -> Unit,
    | ) -> Unit {
 77 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   self.call2("clearLine", dir, cb) |> ignore
    | }
    …

    | pub fn WriteStream::clear_screen_down(
    |   self : WriteStream,
    |   callback : () -> Unit,
    | ) -> Unit {
 87 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   self.call("clearScreenDown", [cb]) |> ignore
    | }
    …

    | pub fn WriteStream::cursor_to(
    |   self : WriteStream,
    |   x : Int,
    |   y : Int,
    |   callback : () -> Unit,
    | ) -> Unit {
 99 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   self.call("cursorTo", [x, y, cb]) |> ignore
    | }
    …

    | pub fn WriteStream::move_cursor(
    |   self : WriteStream,
    |   dx : Int,
    |   dy : Int,
    |   callback : () -> Unit,
    | ) -> Unit {
111 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   self.call("moveCursor", [dx, dy, cb]) |> ignore
    | }
    …

    | pub fn WriteStream::get_color_depth(self : WriteStream) -> Int {
119 |   let val : @js.Any = self.call0("getColorDepth")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @js.identity(val)
    | }
    …

    | pub fn WriteStream::has_colors(self : WriteStream, count : Int) -> Bool {
126 |   let val : @js.Any = self.call("hasColors", [count])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @js.identity(val)
    | }
    …

    | pub fn WriteStream::get_window_size(self : WriteStream) -> (Int, Int) {
133 |   let val : @js.Any = self.call0("getWindowSize")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let arr : @js.JsArray = @js.identity(val)
    |   let cols : Int = @js.identity(arr.get(0))
    |   let rows : Int = @js.identity(arr.get(1))
    |   (cols, rows)
    | }
    …

    | pub fn WriteStream::on_resize(
    |   self : WriteStream,
    |   callback : () -> Unit,
    | ) -> WriteStream {
146 |   self.addEventListener("resize", fn(_e : @js.Any) { callback() })
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   self
    | }
    …

10 uncovered line(s) in src/node/url/url.mbt:

   | #alias(file_url_to_path)
   | pub fn fileURLToPath(url : String, windows? : Bool) -> String {
   |   let url_module = @node.require("node:url")
   |   match windows {
   |     Some(w) =>
 8 |       url_module
   |       ^^^^^^^^^^ 	<-- UNCOVERED
   |       .call2(
   |         "fileURLToPath",
   |         url,
12 |         @js.from_entries_option_cast([("windows", Some(w))]),
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       )
14 |       .cast()
   |       ^^^^^^^ 	<-- UNCOVERED
   |     None => url_module.call1("fileURLToPath", url).cast()
   |   }
   | }
   …

   | #alias(file_url_to_path_from_url)
   | pub fn fileURLToPathFromURL(url : @weburl.URL, windows? : Bool) -> String {
   |   let url_module = @node.require("node:url")
   |   match windows {
   |     Some(w) =>
26 |       url_module
   |       ^^^^^^^^^^ 	<-- UNCOVERED
   |       .call2(
   |         "fileURLToPath",
   |         url,
30 |         @js.from_entries_option_cast([("windows", Some(w))]),
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       )
32 |       .cast()
   |       ^^^^^^^ 	<-- UNCOVERED
   |     None => url_module.call1("fileURLToPath", url).cast()
   |   }
   | }
   …

   | #alias(path_to_file_url)
   | pub fn pathToFileURL(path : String, windows? : Bool) -> @weburl.URL {
   |   let url_module = @node.require("node:url")
   |   match windows {
   |     Some(w) =>
44 |       url_module
   |       ^^^^^^^^^^ 	<-- UNCOVERED
   |       .call2(
   |         "pathToFileURL",
   |         path,
48 |         @js.from_entries_option_cast([("windows", Some(w))]),
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       )
50 |       .cast()
   |       ^^^^^^^ 	<-- UNCOVERED
   |     None => url_module.call1("pathToFileURL", path).cast()
   |   }
   | }
   …

   | pub fn format(url : @weburl.URL) -> String {
66 |   let url_module = @node.require("node:url")
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   url_module.call1("format", url).cast()
   | }
   …

5 uncovered line(s) in src/node/vm/vm.mbt:

    | pub fn Script::new(
    |   code : String,
    |   filename? : String,
    |   lineOffset? : Int,
    |   columnOffset? : Int,
    |   cachedData? : @buffer.Buffer,
    |   produceCachedData? : Bool,
    | ) -> Script {
    |   let vm = vm_module()
    |   let script_constructor = vm.get("Script")
    |   let options = @js.from_entries_option([
    |     ("filename", filename.map(fn(x) { x })),
    |     ("lineOffset", lineOffset.map(fn(x) { x })),
    |     ("columnOffset", columnOffset.map(fn(x) { x })),
 38 |     ("cachedData", cachedData.map(fn(x) { x.to_any() })),
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ("produceCachedData", produceCachedData.map(fn(x) { x })),
    |   ])
    |   @js.new_(script_constructor, [code, options]) |> @js.identity
    | }
    …

    | pub fn Script::runInNewContext(
    |   self : Script,
    |   contextObject? : @js.Any,
    |   filename? : String,
    |   lineOffset? : Int,
    |   columnOffset? : Int,
    |   displayErrors? : Bool,
    |   timeout? : Int,
    |   breakOnSigint? : Bool,
    |   contextName? : String,
    |   contextOrigin? : String,
    |   microtaskMode? : String,
    | ) -> @js.Any {
    |   let options = @js.from_entries_option([
    |     ("filename", filename.map(fn(x) { x })),
    |     ("lineOffset", lineOffset.map(fn(x) { x })),
    |     ("columnOffset", columnOffset.map(fn(x) { x })),
    |     ("displayErrors", displayErrors.map(fn(x) { x })),
    |     ("timeout", timeout.map(fn(x) { x })),
    |     ("breakOnSigint", breakOnSigint.map(fn(x) { x })),
    |     ("contextName", contextName.map(fn(x) { x })),
    |     ("contextOrigin", contextOrigin.map(fn(x) { x })),
    |     ("microtaskMode", microtaskMode.map(fn(x) { x })),
    |   ])
    |   match contextObject {
    |     Some(ctx) => self.call2("runInNewContext", ctx, options)
 94 |     None => self.call1("runInNewContext", options)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub fn Script::createCachedData(self : Script) -> @buffer.Buffer {
124 |   self.call0("createCachedData") |> @js.identity
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn compileFunction(
    |   code : String,
    |   params? : Array[String],
    |   filename? : String,
    |   lineOffset? : Int,
    |   columnOffset? : Int,
    |   cachedData? : @buffer.Buffer,
    |   produceCachedData? : Bool,
    |   parsingContext? : @js.Any,
    |   contextExtensions? : Array[@js.Any],
    | ) -> @js.Any {
    |   let vm = vm_module()
    |   let options = @js.from_entries_option([
    |     ("filename", filename.map(fn(x) { x })),
    |     ("lineOffset", lineOffset.map(fn(x) { x })),
    |     ("columnOffset", columnOffset.map(fn(x) { x })),
266 |     ("cachedData", cachedData.map(fn(x) { x.to_any() })),
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ("produceCachedData", produceCachedData.map(fn(x) { x })),
    |     ("parsingContext", parsingContext.map(fn(x) { x })),
    |     ("contextExtensions", contextExtensions.map(fn(x) { @js.from_array(x) })),
    |   ])
    |   match params {
    |     Some(p) => {
    |       let params_js = @js.from_array(p.map(fn(s) { s }))
    |       vm.call("compileFunction", [code, params_js, options])
    |     }
276 |     None => vm.call2("compileFunction", code, options)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

2 uncovered line(s) in src/node/wasi/wasi.mbt:

    | pub fn WASI::start(
    |   self : Self,
    |   instance : @webassembly.WebAssemblyInstance,
    | ) -> Unit {
104 |   self.call1("start", instance.to_any()) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn WASI::initialize(
    |   self : WASI,
    |   instance : @webassembly.WebAssemblyInstance,
    | ) -> Unit {
113 |   self.call1("initialize", instance.to_any()) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

17 uncovered line(s) in src/node/worker_threads/worker_threads.mbt:

    | pub fn Worker::new(
    |   filename : String,
    |   workerData? : @js.Any,
    |   env? : @js.Any,
    |   stdin? : Bool,
    |   stdout? : Bool,
    |   stderr? : Bool,
    |   execArgv? : Array[String],
    |   resourceLimits? : @js.Any,
    | ) -> Worker {
 49 |   let wt = ffi_require_worker_threads()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let worker_class = wt.get("Worker")
    |   let js_opts = @js.from_entries_option([
    |     ("workerData", workerData.map(fn(x) { x })),
    |     ("env", env.map(fn(x) { x })),
    |     ("stdin", stdin.map(fn(x) { x })),
    |     ("stdout", stdout.map(fn(x) { x })),
    |     ("stderr", stderr.map(fn(x) { x })),
    |     ("execArgv", execArgv.map(fn(x) { @js.from_array(x) })),
    |     ("resourceLimits", resourceLimits.map(fn(x) { x })),
    |   ])
 60 |   @js.identity(@js.new_(worker_class, [filename, js_opts]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Worker::postMessage(
    |   self : Worker,
    |   value : &@js.JsImpl,
    |   transferList? : Array[@js.Any],
    | ) -> Unit {
 71 |   match transferList {
    |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(list) =>
 73 |       self.call2("postMessage", value.to_any(), @js.from_array(list)) |> ignore
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => self.call("postMessage", [value.to_any()]) |> ignore
    |   }
    | }
    …

    | pub fn Worker::terminate(self : Worker) -> Unit {
 82 |   self.call0("terminate") |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Worker::unref(self : Worker) -> Unit {
 88 |   self.call0("unref") |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Worker::ref_(self : Worker) -> Unit {
 94 |   self.call0("ref") |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Worker::threadId(self : Worker) -> Int {
100 |   self.get("threadId").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Worker::stdin(self : Worker) -> @streams.WritableStream? {
106 |   self.get("stdin") |> @js.identity_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Worker::stdout(self : Worker) -> @streams.ReadableStream? {
112 |   self.get("stdout") |> @js.identity_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Worker::stderr(self : Worker) -> @streams.ReadableStream? {
118 |   self.get("stderr") |> @js.identity_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MessagePort::postMessage(
    |   self : MessagePort,
    |   value : &@js.JsImpl,
    |   transferList? : Array[@js.Any],
    | ) -> Unit {
128 |   match transferList {
    |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(list) =>
130 |       self.call2("postMessage", value.to_any(), @js.from_array(list)) |> ignore
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => self.call("postMessage", [value.to_any()]) |> ignore
    |   }
    | }
    …

    | pub fn MessagePort::start(self : MessagePort) -> Unit {
138 |   self.call0("start") |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MessagePort::close(self : MessagePort) -> Unit {
144 |   self.call0("close") |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn workerData() -> @js.Any? {
165 |   ffi_require_worker_threads().get("workerData") |> @js.identity_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn threadId() -> Int {
172 |   ffi_get_thread_id()
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

15 uncovered line(s) in src/node/zlib/zlib.mbt:

    | pub fn ZlibOptions::to_any(self : ZlibOptions) -> @js.Any {
    |   let obj = @js.Object::new()
    |   match self.level {
 30 |     Some(v) => obj.set("level", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.chunk_size {
 34 |     Some(v) => obj.set("chunkSize", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.mem_level {
 38 |     Some(v) => obj.set("memLevel", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.strategy {
 42 |     Some(v) => obj.set("strategy", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   match self.window_bits {
 46 |     Some(v) => obj.set("windowBits", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   obj.to_any()
    | }
    …

    | pub fn gzip(
    |   buffer : @js.Object,
    |   options : ZlibOptions,
    |   callback : (@js.Object?, @js.Object) -> Unit,
    | ) -> Unit {
 70 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ffi_gzip(buffer.to_any(), options.to_any(), cb)
    | }
    …

    | pub fn gunzip(
    |   buffer : @js.Object,
    |   options : ZlibOptions,
    |   callback : (@js.Object?, @js.Object) -> Unit,
    | ) -> Unit {
 92 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ffi_gunzip(buffer.to_any(), options.to_any(), cb)
    | }
    …

    | pub fn deflate(
    |   buffer : @js.Object,
    |   options : ZlibOptions,
    |   callback : (@js.Object?, @js.Object) -> Unit,
    | ) -> Unit {
114 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ffi_deflate(buffer.to_any(), options.to_any(), cb)
    | }
    …

    | pub fn inflate(
    |   buffer : @js.Object,
    |   options : ZlibOptions,
    |   callback : (@js.Object?, @js.Object) -> Unit,
    | ) -> Unit {
136 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ffi_inflate(buffer.to_any(), options.to_any(), cb)
    | }
    …

    | pub fn brotli_compress(
    |   buffer : @js.Object,
    |   options : ZlibOptions,
    |   callback : (@js.Object?, @js.Object) -> Unit,
    | ) -> Unit {
158 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ffi_brotli_compress(buffer.to_any(), options.to_any(), cb)
    | }
    …

    | pub fn brotli_decompress(
    |   buffer : @js.Object,
    |   options : ZlibOptions,
    |   callback : (@js.Object?, @js.Object) -> Unit,
    | ) -> Unit {
180 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ffi_brotli_decompress(buffer.to_any(), options.to_any(), cb)
    | }
    …

    | pub fn unzip(
    |   buffer : @js.Object,
    |   options : ZlibOptions,
    |   callback : (@js.Object?, @js.Object) -> Unit,
    | ) -> Unit {
202 |   let cb : @js.Any = @js.identity(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ffi_unzip(buffer.to_any(), options.to_any(), cb)
    | }
    …

    | pub fn create_gunzip(options : ZlibOptions) -> Gunzip {
245 |   ffi_create_gunzip(options.to_any())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn create_inflate(options : ZlibOptions) -> Inflate {
287 |   ffi_create_inflate(options.to_any())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn create_brotli_decompress(options : ZlibOptions) -> BrotliDecompress {
331 |   ffi_create_brotli_decompress(options.to_any())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

8 uncovered line(s) in src/npm/ai/ai.mbt:

   | pub impl @js.JsImpl for MessageContent with to_any(self) {
12 |   match self {
   |   ^^^^^^^^^^^^ 	<-- UNCOVERED
   |     Message(m) => m |> @js.any
   |   }
   | }
   …

   | pub impl @js.JsImpl for ModelMessage with to_any(self) {
26 |   match self {
   |   ^^^^^^^^^^^^ 	<-- UNCOVERED
   |     AssitantMessage(content~) =>
28 |       @js.from_map({
   |       ^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |         "type": "assitant" |> @js.any,
   |         "content": @js.JsImpl::to_any(content),
   |       })
   |     UserMessage(content~) =>
33 |       @js.from_map({
   |       ^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |         "role": "user" |> @js.any,
   |         "content": @js.JsImpl::to_any(content),
   |       })
   |     SystemMessage(content~) =>
38 |       @js.from_map({
   |       ^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |         "role": "system" |> @js.any,
   |         "content": @js.JsImpl::to_any(content),
   |       })
   |   }
   | }
   …

   | pub fn Ai::require() -> Self {
59 |   @node.require("ai") |> @js.identity
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Ai::generate_text(
   |   self : Self,
   |   model~ : Model,
   |   messages~ : Array[ModelMessage],
   |   // prompt?: String
   | ) -> @js.Promise[@js.Any] {
69 |   @js.identity(
   |   ^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     self
71 |     .to_any()
   |     ^^^^^^^^^ 	<-- UNCOVERED
   |     .get("generateText")
   |     .call_self([
   |       @js.from_map({
   |         "model": model |> @js.identity,
   |         "messages": messages.map(_.to_any()) |> @js.from_array,
   |       }),
   |     ]),
   |   )
   | }
   …

20 uncovered line(s) in src/npm/chokidar/_example/main.mbt:

   | fn main {
 4 |   println("=== Chokidar Example ===")
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | 
   |   // Create a watcher
   |   // Ignore dotfiles with regex pattern
 8 |   let watcher = @chokidar.watch(
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     @js.any("."),
   |     ignored?=Some(@js.any("/(^|[\/\\])\\../")),
   |     persistent?=Some(true),
   |     ignoreInitial?=Some(true),
   |   )
   | 
   |   // Set up event handlers
16 |   let _ = watcher.on(
   |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     "add",
18 |     @js.identity(fn(path : @js.Any) { println("File added: \{path}") }),
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   )
20 |   let _ = watcher.on(
   |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     "change",
22 |     @js.identity(fn(path : @js.Any) { println("File changed: \{path}") }),
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   )
24 |   let _ = watcher.on(
   |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     "unlink",
26 |     @js.identity(fn(path : @js.Any) { println("File removed: \{path}") }),
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   )
28 |   let _ = watcher.on(
   |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     "addDir",
30 |     @js.identity(fn(path : @js.Any) { println("Directory added: \{path}") }),
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   )
32 |   let _ = watcher.on(
   |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     "unlinkDir",
34 |     @js.identity(fn(path : @js.Any) { println("Directory removed: \{path}") }),
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   )
36 |   let _ = watcher.on(
   |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     "error",
38 |     @js.identity(fn(error : @js.Any) { println("Error: \{error}") }),
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   )
40 |   let _ = watcher.on(
   |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     "ready",
42 |     @js.identity(fn() { println("Initial scan complete. Ready for changes") }),
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   )
44 |   println("Watching for file changes...")
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   println("(This example would run continuously in a real application)")
   | 
   |   // In a real application, you would keep the process alive
   |   // For this example, we'll clean up after a short time
49 |   let _ = @js.set_timeout(
   |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     fn() {
51 |       @js.run_async(async fn() -> Unit noraise {
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |         println("Closing watcher...")
   |         watcher.close() catch {
   |           e => println("Failed to close watcher: \{e}")
   |         }
56 |         println("✓ Watcher closed")
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       })
   |     },
   |     3000,
   |   )
   | 
   | }
   …

21 uncovered line(s) in src/npm/chokidar/chokidar.mbt:

    | pub fn watch(
    |   paths : @js.Any,
    |   persistent? : Bool,
    |   ignored? : @js.Any,
    |   ignoreInitial? : Bool,
    |   followSymlinks? : Bool,
    |   cwd? : String,
    |   disableGlobbing? : Bool,
    |   usePolling? : Bool,
    |   interval? : Int,
    |   binaryInterval? : Int,
    |   alwaysStat? : Bool,
    |   depth? : Int,
    |   awaitWriteFinish? : @js.Any,
    |   ignorePermissionErrors? : Bool,
    |   atomic_? : Bool,
    | ) -> FSWatcher {
 65 |   let options = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match persistent {
    |     Some(v) => options.set("persistent", @js.any(v))
    |     None => ()
    |   }
 70 |   match ignored {
    |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => options.set("ignored", v)
    |     None => ()
    |   }
 74 |   match ignoreInitial {
    |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => options.set("ignoreInitial", @js.any(v))
    |     None => ()
    |   }
 78 |   match followSymlinks {
    |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => options.set("followSymlinks", @js.any(v))
    |     None => ()
    |   }
 82 |   match cwd {
    |   ^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => options.set("cwd", @js.any(v))
    |     None => ()
    |   }
 86 |   match disableGlobbing {
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => options.set("disableGlobbing", @js.any(v))
    |     None => ()
    |   }
 90 |   match usePolling {
    |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => options.set("usePolling", @js.any(v))
    |     None => ()
    |   }
 94 |   match interval {
    |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => options.set("interval", @js.any(v))
    |     None => ()
    |   }
 98 |   match binaryInterval {
    |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => options.set("binaryInterval", @js.any(v))
    |     None => ()
    |   }
102 |   match alwaysStat {
    |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => options.set("alwaysStat", @js.any(v))
    |     None => ()
    |   }
106 |   match depth {
    |   ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => options.set("depth", @js.any(v))
    |     None => ()
    |   }
110 |   match awaitWriteFinish {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => options.set("awaitWriteFinish", v)
    |     None => ()
    |   }
114 |   match ignorePermissionErrors {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => options.set("ignorePermissionErrors", @js.any(v))
    |     None => ()
    |   }
118 |   match atomic_ {
    |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => options.set("atomic", @js.any(v))
    |     None => ()
    |   }
122 |   @js.identity(ffi_watch(paths, options.to_any()))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn FSWatcher::add(self : FSWatcher, paths : @js.Any) -> FSWatcher {
131 |   @js.identity(self.call("add", [paths]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn FSWatcher::unwatch(self : FSWatcher, paths : @js.Any) -> FSWatcher {
138 |   @js.identity(self.call("unwatch", [paths]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn FSWatcher::close(self : FSWatcher) -> Unit {
145 |   let promise : @js.Promise[Unit] = @js.identity(self.call("close", []))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   promise.wait()
    | }
    …

    | pub fn FSWatcher::getWatched(self : FSWatcher) -> @js.Any {
153 |   self.call("getWatched", [])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn FSWatcher::on(
    |   self : FSWatcher,
    |   event : String,
    |   callback : @js.Any,
    | ) -> FSWatcher {
166 |   @js.identity(self.call("on", [@js.any(event), callback]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn FSWatcher::off(
    |   self : FSWatcher,
    |   event : String,
    |   callback : @js.Any,
    | ) -> FSWatcher {
177 |   @js.identity(self.call("off", [@js.any(event), callback]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

19 uncovered line(s) in src/npm/hono/context.mbt:

    | #alias(execution_ctx)
    | pub fn[Env, ExecutionContext] Context::executionCtx(
    |   self : Context[Env, ExecutionContext],
    | ) -> ExecutionContext {
 20 |   self.executionCtx
    |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[Env, ExecutionContext, T] Context::json(
    |   self : Context[Env, ExecutionContext],
    |   data : T,
    |   status? : Int,
    | ) -> @http.Response {
 31 |   let status_code = match status {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(s) => s
    |     None => 200
    |   }
 35 |   self.call("json", [@js.identity(data), status_code]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[Env, ExecutionContext] Context::text(
    |   self : Context[Env, ExecutionContext],
    |   text : String,
    |   status? : Int,
    | ) -> @http.Response {
 46 |   let status_code = match status {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(s) => s
    |     None => 200
    |   }
 50 |   self.call("text", [text, status_code]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[Env, ExecutionContext] Context::html(
    |   self : Context[Env, ExecutionContext],
    |   html : String,
    |   status? : Int,
    | ) -> @http.Response {
 61 |   let status_code = match status {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(s) => s
    |     None => 200
    |   }
 65 |   self.call("html", [html, status_code]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[Env, ExecutionContext] Context::redirect(
    |   self : Context[Env, ExecutionContext],
    |   url : String,
    |   status? : Int,
    | ) -> @http.Response {
 76 |   let status_code = match status {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(s) => s
    |     None => 302
    |   }
 80 |   self.call("redirect", [url, status_code]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(not_found)
    | pub fn[Env, ExecutionContext] Context::notFound(
    |   self : Context[Env, ExecutionContext],
    | ) -> @http.Response {
 90 |   self.call0("notFound") |> @js.identity
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[Env, ExecutionContext] Context::header(
    |   self : Context[Env, ExecutionContext],
    |   name : String,
    |   value : String,
    | ) -> Unit {
101 |   self.call("header", [name, value]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[Env, ExecutionContext] Context::status(
    |   self : Context[Env, ExecutionContext],
    |   code : Int,
    | ) -> Unit {
111 |   self.call("status", [code]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[Env, ExecutionContext] Context::set(
    |   self : Context[Env, ExecutionContext],
    |   key : String,
    |   value : @js.Any,
    | ) -> Unit {
122 |   self.call("set", [key, value]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(get_value)
    | pub fn[Env, ExecutionContext] Context::getValue(
    |   self : Context[Env, ExecutionContext],
    |   key : String,
    | ) -> @js.Any {
132 |   self.call("get", [key])
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[Env, ExecutionContext] Context::res(
    |   self : Context[Env, ExecutionContext],
    | ) -> @http.Response {
141 |   self.get("res").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[Env, ExecutionContext] Context::var_(
    |   self : Context[Env, ExecutionContext],
    |   key : String,
    | ) -> @js.Any {
151 |   self.get("var").get(key)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[Env, ExecutionContext] Context::body(
    |   self : Context[Env, ExecutionContext],
    |   body : String,
    |   status? : Int,
    |   headers? : @js.Any,
    | ) -> @http.Response {
163 |   match (status, headers) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(s), Some(h)) => self.call("body", [body, s, h]).cast()
    |     (Some(s), None) => self.call("body", [body, s]).cast()
    |     _ => self.call("body", [body]).cast()
    |   }
    | }
    …

    | #alias(set_renderer)
    | pub fn[Env, ExecutionContext] Context::setRenderer(
    |   self : Context[Env, ExecutionContext],
    |   renderer : (String) -> @http.Response,
    | ) -> Unit {
178 |   self.call("setRenderer", [@js.unsafe_any(renderer)]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[Env, ExecutionContext] Context::render(
    |   self : Context[Env, ExecutionContext],
    |   content : String,
    | ) -> @http.Response {
188 |   self.call("render", [content]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

9 uncovered line(s) in src/npm/hono/hono.mbt:

    | pub fn[Env, ExecutionContext] Hono::new(
    |   strict? : Bool,
    | ) -> Hono[Env, ExecutionContext] {
    |   match strict {
 49 |     Some(s) => @js.identity(ffi_new_hono_with_options(build_hono_options(s)))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => @js.identity(ffi_new_hono())
    |   }
    | }
    …

    | pub fn[Env, ExecutionContext] Hono::options(
    |   self : Hono[Env, ExecutionContext],
    |   path : String,
    |   handler : Handler[Env, ExecutionContext],
    | ) -> Hono[Env, ExecutionContext] {
123 |   self.call("options", [path, @js.unsafe_any(handler)]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[Env, ExecutionContext] Hono::use_(
    |   self : Hono[Env, ExecutionContext],
    |   path : String,
    |   middleware : Middleware[Env, ExecutionContext],
    | ) -> Hono[Env, ExecutionContext] {
144 |   self.call("use", [path, @js.unsafe_any(middleware)]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[Env, ExecutionContext] Hono::useall(
    |   self : Hono[Env, ExecutionContext],
    |   middleware : Middleware[Env, ExecutionContext],
    | ) -> Hono[Env, ExecutionContext] {
153 |   self.call("use", [@js.unsafe_any(middleware)]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[Env, ExecutionContext] Hono::fetch(
    |   self : Hono[Env, ExecutionContext],
    |   request : @http.Request,
    | ) -> @js.Promise[@http.Response] {
163 |   self.call("fetch", [request]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[Env, ExecutionContext] Hono::fire(
    |   self : Hono[Env, ExecutionContext],
    | ) -> Hono[Env, ExecutionContext] {
172 |   self.call0("fire").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(not_found)
    | pub fn[Env, ExecutionContext] Hono::notFound(
    |   self : Hono[Env, ExecutionContext],
    |   handler : Handler[Env, ExecutionContext],
    | ) -> Hono[Env, ExecutionContext] {
194 |   self.call("notFound", [@js.unsafe_any(handler)]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(on_error)
    | pub fn[Env, ExecutionContext] Hono::onError(
    |   self : Hono[Env, ExecutionContext],
    |   handler : (@js.Any, Context[Env, ExecutionContext]) -> @http.Response,
    | ) -> Hono[Env, ExecutionContext] {
205 |   self.call("onError", [@js.unsafe_any(handler)]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[Env, ExecutionContext] Hono::mount(
    |   self : Hono[Env, ExecutionContext],
    |   path : String,
    |   app : Hono[Env, ExecutionContext],
    | ) -> Hono[Env, ExecutionContext] {
216 |   self.call("mount", [path, app]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

32 uncovered line(s) in src/npm/hono/hono_client.mbt:

    | pub fn hc(base_url : String) -> HonoClient {
 24 |   ffi_hc(base_url).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ClientResponse::ok(self : ClientResponse) -> Bool {
 58 |   self.get("ok").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ClientResponse::status(self : ClientResponse) -> Int {
 64 |   self.get("status").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ClientResponse::json(self : ClientResponse) -> @js.Promise[@js.Any] {
 70 |   self.call0("json").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ClientResponse::text(self : ClientResponse) -> @js.Promise[String] {
 76 |   self.call0("text").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(array_buffer)
    | pub fn ClientResponse::arrayBuffer(
    |   self : ClientResponse,
    | ) -> @js.Promise[@js.ArrayBuffer] {
 85 |   self.call0("arrayBuffer").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ClientResponse::blob(self : ClientResponse) -> @js.Promise[@js.Any] {
 91 |   self.call0("blob").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ClientResponse::headers(self : ClientResponse) -> @js.Any {
 97 |   self.get("headers")
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ClientEndpoint::get_(
    |   self : ClientEndpoint,
    |   query? : @js.Any,
    |   form? : @js.Any,
    |   json? : @js.Any,
    |   param? : @js.Any,
    |   header? : @js.Any,
    |   init? : @js.Any,
    | ) -> @js.Promise[ClientResponse] {
133 |   let has_options = query is Some(_) ||
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     form is Some(_) ||
    |     json is Some(_) ||
    |     param is Some(_) ||
    |     header is Some(_) ||
    |     init is Some(_)
    |   if has_options {
140 |     let opts = build_request_options(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       query.unwrap_or(@js.undefined()),
    |       form.unwrap_or(@js.undefined()),
    |       json.unwrap_or(@js.undefined()),
    |       param.unwrap_or(@js.undefined()),
    |       header.unwrap_or(@js.undefined()),
    |       init.unwrap_or(@js.undefined()),
    |     )
148 |     ffi_call_dollar_get(@js.identity(self), opts).cast()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   } else {
150 |     ffi_call_dollar_get(@js.identity(self), @js.undefined()).cast()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub fn ClientEndpoint::post_(
    |   self : ClientEndpoint,
    |   query? : @js.Any,
    |   form? : @js.Any,
    |   json? : @js.Any,
    |   param? : @js.Any,
    |   header? : @js.Any,
    |   init? : @js.Any,
    | ) -> @js.Promise[ClientResponse] {
179 |   let has_options = query is Some(_) ||
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     form is Some(_) ||
    |     json is Some(_) ||
    |     param is Some(_) ||
    |     header is Some(_) ||
    |     init is Some(_)
    |   if has_options {
186 |     let opts = build_request_options(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       query.unwrap_or(@js.undefined()),
    |       form.unwrap_or(@js.undefined()),
    |       json.unwrap_or(@js.undefined()),
    |       param.unwrap_or(@js.undefined()),
    |       header.unwrap_or(@js.undefined()),
    |       init.unwrap_or(@js.undefined()),
    |     )
194 |     ffi_call_dollar_post(@js.identity(self), opts).cast()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   } else {
196 |     ffi_call_dollar_post(@js.identity(self), @js.undefined()).cast()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub fn ClientEndpoint::put_(
    |   self : ClientEndpoint,
    |   query? : @js.Any,
    |   form? : @js.Any,
    |   json? : @js.Any,
    |   param? : @js.Any,
    |   header? : @js.Any,
    |   init? : @js.Any,
    | ) -> @js.Promise[ClientResponse] {
225 |   let has_options = query is Some(_) ||
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     form is Some(_) ||
    |     json is Some(_) ||
    |     param is Some(_) ||
    |     header is Some(_) ||
    |     init is Some(_)
    |   if has_options {
232 |     let opts = build_request_options(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       query.unwrap_or(@js.undefined()),
    |       form.unwrap_or(@js.undefined()),
    |       json.unwrap_or(@js.undefined()),
    |       param.unwrap_or(@js.undefined()),
    |       header.unwrap_or(@js.undefined()),
    |       init.unwrap_or(@js.undefined()),
    |     )
240 |     ffi_call_dollar_put(@js.identity(self), opts).cast()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   } else {
242 |     ffi_call_dollar_put(@js.identity(self), @js.undefined()).cast()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub fn ClientEndpoint::delete_(
    |   self : ClientEndpoint,
    |   query? : @js.Any,
    |   form? : @js.Any,
    |   json? : @js.Any,
    |   param? : @js.Any,
    |   header? : @js.Any,
    |   init? : @js.Any,
    | ) -> @js.Promise[ClientResponse] {
271 |   let has_options = query is Some(_) ||
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     form is Some(_) ||
    |     json is Some(_) ||
    |     param is Some(_) ||
    |     header is Some(_) ||
    |     init is Some(_)
    |   if has_options {
278 |     let opts = build_request_options(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       query.unwrap_or(@js.undefined()),
    |       form.unwrap_or(@js.undefined()),
    |       json.unwrap_or(@js.undefined()),
    |       param.unwrap_or(@js.undefined()),
    |       header.unwrap_or(@js.undefined()),
    |       init.unwrap_or(@js.undefined()),
    |     )
286 |     ffi_call_dollar_delete(@js.identity(self), opts).cast()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   } else {
288 |     ffi_call_dollar_delete(@js.identity(self), @js.undefined()).cast()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub fn ClientEndpoint::patch_(
    |   self : ClientEndpoint,
    |   query? : @js.Any,
    |   form? : @js.Any,
    |   json? : @js.Any,
    |   param? : @js.Any,
    |   header? : @js.Any,
    |   init? : @js.Any,
    | ) -> @js.Promise[ClientResponse] {
317 |   let has_options = query is Some(_) ||
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     form is Some(_) ||
    |     json is Some(_) ||
    |     param is Some(_) ||
    |     header is Some(_) ||
    |     init is Some(_)
    |   if has_options {
324 |     let opts = build_request_options(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       query.unwrap_or(@js.undefined()),
    |       form.unwrap_or(@js.undefined()),
    |       json.unwrap_or(@js.undefined()),
    |       param.unwrap_or(@js.undefined()),
    |       header.unwrap_or(@js.undefined()),
    |       init.unwrap_or(@js.undefined()),
    |     )
332 |     ffi_call_dollar_patch(@js.identity(self), opts).cast()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   } else {
334 |     ffi_call_dollar_patch(@js.identity(self), @js.undefined()).cast()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub fn ClientEndpoint::url_(
    |   self : ClientEndpoint,
    |   query? : @js.Any,
    |   form? : @js.Any,
    |   json? : @js.Any,
    |   param? : @js.Any,
    |   header? : @js.Any,
    |   init? : @js.Any,
    | ) -> String {
363 |   let has_options = query is Some(_) ||
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     form is Some(_) ||
    |     json is Some(_) ||
    |     param is Some(_) ||
    |     header is Some(_) ||
    |     init is Some(_)
    |   if has_options {
370 |     let opts = build_request_options(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       query.unwrap_or(@js.undefined()),
    |       form.unwrap_or(@js.undefined()),
    |       json.unwrap_or(@js.undefined()),
    |       param.unwrap_or(@js.undefined()),
    |       header.unwrap_or(@js.undefined()),
    |       init.unwrap_or(@js.undefined()),
    |     )
378 |     ffi_call_dollar_url(@js.identity(self), opts).cast()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   } else {
380 |     ffi_call_dollar_url(@js.identity(self), @js.undefined()).cast()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

21 uncovered line(s) in src/npm/hono/request.mbt:

    | pub fn HonoRequest::query(self : Self, key : String) -> String? {
 13 |   let result : @js.Any = self.call("query", [key])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   if result == @js.undefined() {
 15 |     None
    |     ^^^^ 	<-- UNCOVERED
    |   } else {
 17 |     Some(@js.identity(result))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | #alias(query_all)
    | pub fn HonoRequest::queryAll(self : Self) -> @js.Any {
 25 |   self.call0("query")
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HonoRequest::param(self : Self, key : String) -> String? {
 32 |   let result : @js.Any = self.call("param", [key])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   if result == @js.undefined() {
 34 |     None
    |     ^^^^ 	<-- UNCOVERED
    |   } else {
 36 |     Some(@js.identity(result))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | #alias(param_all)
    | pub fn HonoRequest::paramAll(self : Self) -> @js.Any {
 44 |   self.call0("param")
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HonoRequest::header(self : Self, key : String) -> String? {
 51 |   let result : @js.Any = self.call("header", [key])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   if result == @js.undefined() {
 53 |     None
    |     ^^^^ 	<-- UNCOVERED
    |   } else {
 55 |     Some(@js.identity(result))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub fn HonoRequest::json(self : Self) -> @js.Promise[@js.Any] {
 63 |   self.call0("json").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HonoRequest::text(self : Self) -> @js.Promise[String] {
 70 |   self.call0("text").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(form_data)
    | pub fn HonoRequest::formData(self : Self) -> @js.Promise[@http.FormData] {
 78 |   self.call0("formData").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(array_buffer)
    | pub fn HonoRequest::arrayBuffer(self : Self) -> @js.Promise[@js.ArrayBuffer] {
 86 |   self.call0("arrayBuffer").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HonoRequest::blob(self : Self) -> @js.Promise[@js.Any] {
 93 |   self.call0("blob").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(parse_body)
    | pub fn HonoRequest::parseBody(
    |   self : Self,
    |   options? : @js.Any,
    | ) -> @js.Promise[@js.Any] {
104 |   match options {
    |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(opts) => self.call("parseBody", [opts]).cast()
    |     None => self.call0("parseBody").cast()
    |   }
    | }
    …

    | pub fn HonoRequest::url(self : Self) -> String {
113 |   self.get("url").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HonoRequest::method_(self : Self) -> String {
119 |   self.get("method").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HonoRequest::path(self : Self) -> String {
125 |   self.call0("path").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(body_used)
    | pub fn HonoRequest::bodyUsed(self : Self) -> Bool {
132 |   self.get("bodyUsed").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

4 uncovered line(s) in src/npm/modelcontextprotocol/client.mbt:

   | pub fn McpClient::new(endpoint : String) -> McpClient {
13 |   { server_info: None, request_id: 0, endpoint }
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | fn McpClient::next_id(self : McpClient) -> RequestId {
18 |   self.request_id = self.request_id + 1
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   Number(self.request_id)
   | }
   …

   | pub fn McpClient::create_request(
   |   self : McpClient,
   |   method_name : String,
   |   params : @js.Object?,
   | ) -> JsonRpcRequest {
29 |   let id = self.next_id()
   |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   { jsonrpc: "2.0", id, method_name, params }
   | }
   …

   | pub fn McpClient::get_server_info(self : McpClient) -> ServerInfo? {
36 |   self.server_info
   |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

20 uncovered line(s) in src/npm/modelcontextprotocol/protocol.mbt:

    | pub fn ContentType::to_string(self : ContentType) -> String {
 13 |   match self {
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Text => "text"
    |     Image => "image"
    |     Resource => "resource"
    |   }
    | }
    …

    | pub fn Content::to_any(self : Content) -> @js.Object {
 53 |   let obj = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   obj.set("type", self.type_.to_string())
    |   match self.text {
    |     Some(t) => obj.set("text", t)
    |     None => ()
    |   }
 59 |   match self.data {
    |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(d) => obj.set("data", d)
    |     None => ()
    |   }
 63 |   match self.mime_type {
    |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(m) => obj.set("mimeType", m)
    |     None => ()
    |   }
 67 |   match self.uri {
    |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(u) => obj.set("uri", u)
    |     None => ()
    |   }
    |   obj
    | }
    …

    | pub fn Tool::to_any(self : Tool) -> @js.Object {
 84 |   let obj = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   obj.set("name", self.name)
    |   obj.set("description", self.description)
    |   obj.set("inputSchema", self.input_schema)
    |   obj
    | }
    …

    | pub fn Resource::to_any(self : Resource) -> @js.Object {
102 |   let obj = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   obj.set("uri", self.uri)
    |   obj.set("name", self.name)
    |   match self.description {
    |     Some(d) => obj.set("description", d)
    |     None => ()
    |   }
109 |   match self.mime_type {
    |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(m) => obj.set("mimeType", m)
    |     None => ()
    |   }
    |   obj
    | }
    …

    | pub fn PromptArgument::to_any(self : PromptArgument) -> @js.Object {
133 |   let obj = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   obj.set("name", self.name)
    |   match self.description {
    |     Some(d) => obj.set("description", d)
    |     None => ()
    |   }
139 |   obj.set("required", self.required)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   obj
    | }
    …

    | pub fn Prompt::to_any(self : Prompt) -> @js.Object {
145 |   let obj = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   obj.set("name", self.name)
    |   match self.description {
    |     Some(d) => obj.set("description", d)
    |     None => ()
    |   }
151 |   let args_array = @js.JsArray::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   for i = 0; i < self.arguments.length(); i = i + 1 {
    |     args_array.push(self.arguments[i].to_any())
    |   }
155 |   obj.set("arguments", args_array)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   obj
    | }
    …

    | pub fn ServerCapabilities::to_any(self : ServerCapabilities) -> @js.Object {
169 |   let obj = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let capabilities = @js.Object::new()
    |   if self.tools {
172 |     capabilities.set("tools", @js.Object::new())
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if self.resources {
175 |     capabilities.set("resources", @js.Object::new())
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if self.prompts {
178 |     capabilities.set("prompts", @js.Object::new())
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
180 |   obj.set("capabilities", capabilities)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   obj
    | }
    …

    | pub fn ServerInfo::to_any(self : ServerInfo) -> @js.Object {
193 |   let obj = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   obj.set("name", self.name)
    |   obj.set("version", self.version)
    |   obj
    | }
    …

    | pub fn ClientInfo::from_js(js : @js.Any) -> ClientInfo? {
208 |   let obj : @js.Object = @js.identity(js)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let name : String? = obj.get("name") |> @js.identity_option()
    |   let version : String? = obj.get("version") |> @js.identity_option()
    |   match (name, version) {
    |     (Some(n), Some(v)) => Some({ name: n, version: v })
    |     _ => None
    |   }
    | }
    …

45 uncovered line(s) in src/npm/modelcontextprotocol/server.mbt:

    | pub fn McpServer::add_tool(
    |   self : McpServer,
    |   tool : Tool,
    |   handler : ToolHandler,
    | ) -> Unit {
 41 |   self.tools = self.tools.add(tool.name, (tool, handler))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn McpServer::add_resource(
    |   self : McpServer,
    |   resource : Resource,
    |   handler : ResourceHandler,
    | ) -> Unit {
 51 |   self.resources = self.resources.add(resource.uri, (resource, handler))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn McpServer::add_prompt(
    |   self : McpServer,
    |   prompt : Prompt,
    |   handler : PromptHandler,
    | ) -> Unit {
 61 |   self.prompts = self.prompts.add(prompt.name, (prompt, handler))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn McpServer::handle_request(
    |   self : McpServer,
    |   request : JsonRpcRequest,
    | ) -> @js.Promise[Result[JsonRpcResponse, JsonRpcErrorResponse]] {
 70 |   let id = request.id
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | 
    |   // Handle different methods
    |   if request.method_name == "initialize" {
 74 |     self.handle_initialize(id, request.params)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   } else if request.method_name == "tools/list" {
    |     self.handle_tools_list(id)
    |   } else if request.method_name == "tools/call" {
    |     self.handle_tools_call(id, request.params)
    |   } else if request.method_name == "resources/list" {
    |     self.handle_resources_list(id)
    |   } else if request.method_name == "resources/read" {
    |     self.handle_resources_read(id, request.params)
    |   } else if request.method_name == "prompts/list" {
    |     self.handle_prompts_list(id)
    |   } else if request.method_name == "prompts/get" {
    |     self.handle_prompts_get(id, request.params)
    |   } else {
 88 |     @js.Promise::resolve(
    |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       Err(self.method_not_found_error(id, request.method_name)),
    |     )
    |   }
    | }
    …

    | fn McpServer::handle_initialize(
    |   self : McpServer,
    |   id : RequestId,
    |   _params : @js.Object?,
    | ) -> @js.Promise[Result[JsonRpcResponse, JsonRpcErrorResponse]] {
100 |   let result = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   result.set("protocolVersion", "2024-11-05")
    |   result.set("serverInfo", self.info.to_any())
    | 
    |   // Build capabilities dynamically
    |   let capabilities : ServerCapabilities = {
106 |     tools: self.tools.length() > 0,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     resources: self.resources.length() > 0,
    |     prompts: self.prompts.length() > 0,
    |   }
110 |   result.set("capabilities", capabilities.to_any())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @js.Promise::resolve(Ok({ jsonrpc: "2.0", id, result: @js.identity(result) }))
    | }
    …

    | fn McpServer::handle_tools_list(
    |   self : McpServer,
    |   id : RequestId,
    | ) -> @js.Promise[Result[JsonRpcResponse, JsonRpcErrorResponse]] {
119 |   let tools_array = @js.JsArray::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   self.tools.each(fn(_, value) {
    |     let (tool, _) = value
    |     tools_array.push(tool.to_any())
    |   })
124 |   let result = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   result.set("tools", tools_array)
    |   @js.Promise::resolve(Ok({ jsonrpc: "2.0", id, result: @js.identity(result) }))
    | }
    …

    | fn McpServer::handle_tools_call(
    |   self : McpServer,
    |   id : RequestId,
    |   params : @js.Object?,
    | ) -> @js.Promise[Result[JsonRpcResponse, JsonRpcErrorResponse]] {
135 |   match params {
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None =>
137 |       @js.Promise::resolve(Err(self.invalid_params_error(id, "Missing params")))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(p) => {
    |       let name : String? = p.get("name") |> @js.identity_option()
    |       match name {
    |         None =>
142 |           @js.Promise::resolve(
    |           ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             Err(self.invalid_params_error(id, "Missing tool name")),
    |           )
    |         Some(tool_name) =>
146 |           match self.tools.get(tool_name) {
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             None =>
148 |               @js.Promise::resolve(
    |               ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                 Err(
150 |                   self.method_not_found_error(
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                     id,
    |                     "Tool not found: " + tool_name,
    |                   ),
    |                 ),
    |               )
156 |             Some((_, handler)) => {
    |             ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               let arguments : @js.Object = match
158 |                 (p.get("arguments") |> @js.identity_option()) {
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                 Some(args) => args
    |                 None => @js.Object::new()
    |               }
162 |               handler(arguments).then(fn(content) {
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                 let content_array = @js.JsArray::new()
    |                 for i = 0; i < content.length(); i = i + 1 {
    |                   content_array.push(content[i].to_any())
    |                 }
167 |                 let result = @js.Object::new()
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                 result.set("content", content_array)
    |                 @js.Promise::resolve(
    |                   Ok({ jsonrpc: "2.0", id, result: @js.identity(result) }),
    |                 )
    |               })
    |             }
    |           }
    |       }
    |     }
    |   }
    | }
    …

    | fn McpServer::handle_resources_list(
    |   self : McpServer,
    |   id : RequestId,
    | ) -> @js.Promise[Result[JsonRpcResponse, JsonRpcErrorResponse]] {
185 |   let resources_array = @js.JsArray::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   self.resources.each(fn(_, value) {
    |     let (resource, _) = value
    |     resources_array.push(resource.to_any())
    |   })
190 |   let result = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   result.set("resources", resources_array)
    |   @js.Promise::resolve(Ok({ jsonrpc: "2.0", id, result: @js.identity(result) }))
    | }
    …

    | fn McpServer::handle_resources_read(
    |   self : McpServer,
    |   id : RequestId,
    |   params : @js.Object?,
    | ) -> @js.Promise[Result[JsonRpcResponse, JsonRpcErrorResponse]] {
201 |   match params {
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None =>
203 |       @js.Promise::resolve(Err(self.invalid_params_error(id, "Missing params")))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(p) => {
    |       let uri : String? = p.get("uri") |> @js.identity_option()
    |       match uri {
    |         None =>
208 |           @js.Promise::resolve(
    |           ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             Err(self.invalid_params_error(id, "Missing resource URI")),
    |           )
    |         Some(resource_uri) =>
212 |           match self.resources.get(resource_uri) {
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             None =>
214 |               @js.Promise::resolve(
    |               ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                 Err(
216 |                   self.method_not_found_error(
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                     id,
    |                     "Resource not found: " + resource_uri,
    |                   ),
    |                 ),
    |               )
    |             Some((_, handler)) =>
223 |               handler(resource_uri).then(fn(content) {
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                 let content_array = @js.JsArray::new()
    |                 for i = 0; i < content.length(); i = i + 1 {
    |                   content_array.push(content[i].to_any())
    |                 }
228 |                 let result = @js.Object::new()
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                 result.set("contents", content_array)
    |                 @js.Promise::resolve(
    |                   Ok({ jsonrpc: "2.0", id, result: @js.identity(result) }),
    |                 )
    |               })
    |           }
    |       }
    |     }
    |   }
    | }
    …

    | fn McpServer::handle_prompts_list(
    |   self : McpServer,
    |   id : RequestId,
    | ) -> @js.Promise[Result[JsonRpcResponse, JsonRpcErrorResponse]] {
245 |   let prompts_array = @js.JsArray::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   self.prompts.each(fn(_, value) {
    |     let (prompt, _) = value
    |     prompts_array.push(prompt.to_any())
    |   })
250 |   let result = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   result.set("prompts", prompts_array)
    |   @js.Promise::resolve(Ok({ jsonrpc: "2.0", id, result: @js.identity(result) }))
    | }
    …

    | fn McpServer::handle_prompts_get(
    |   self : McpServer,
    |   id : RequestId,
    |   params : @js.Object?,
    | ) -> @js.Promise[Result[JsonRpcResponse, JsonRpcErrorResponse]] {
261 |   match params {
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None =>
263 |       @js.Promise::resolve(Err(self.invalid_params_error(id, "Missing params")))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(p) => {
    |       let name : String? = p.get("name") |> @js.identity_option()
    |       match name {
    |         None =>
268 |           @js.Promise::resolve(
    |           ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             Err(self.invalid_params_error(id, "Missing prompt name")),
    |           )
    |         Some(prompt_name) =>
272 |           match self.prompts.get(prompt_name) {
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             None =>
274 |               @js.Promise::resolve(
    |               ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                 Err(
276 |                   self.method_not_found_error(
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                     id,
    |                     "Prompt not found: " + prompt_name,
    |                   ),
    |                 ),
    |               )
282 |             Some((_, handler)) => {
    |             ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               let arguments : @js.Object = match
284 |                 (p.get("arguments") |> @js.identity_option()) {
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                 Some(args) => args
    |                 None => @js.Object::new()
    |               }
288 |               handler(arguments).then(fn(content) {
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                 let content_array = @js.JsArray::new()
    |                 for i = 0; i < content.length(); i = i + 1 {
    |                   content_array.push(content[i].to_any())
    |                 }
293 |                 let result = @js.Object::new()
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |                 result.set("messages", content_array)
    |                 @js.Promise::resolve(
    |                   Ok({ jsonrpc: "2.0", id, result: @js.identity(result) }),
    |                 )
    |               })
    |             }
    |           }
    |       }
    |     }
    |   }
    | }
    …

    | fn McpServer::method_not_found_error(
    |   _self : McpServer,
    |   id : RequestId,
    |   message : String,
    | ) -> JsonRpcErrorResponse {
312 |   { jsonrpc: "2.0", id, error: { code: method_not_found, message, data: None } }
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | fn McpServer::invalid_params_error(
    |   _self : McpServer,
    |   id : RequestId,
    |   message : String,
    | ) -> JsonRpcErrorResponse {
321 |   { jsonrpc: "2.0", id, error: { code: invalid_params, message, data: None } }
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

9 uncovered line(s) in src/npm/modelcontextprotocol/types.mbt:

    | pub fn RequestId::to_any(self : RequestId) -> @js.Any {
    |   match self {
    |     String(s) => @js.identity(s)
 14 |     Number(n) => @js.identity(n)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub fn RequestId::from_js(js : @js.Any) -> RequestId? {
    |   let ty = @js.typeof_(js)
    |   if ty == "string" {
    |     let s : String = @js.identity(js)
    |     Some(String(s))
    |   } else if ty == "number" {
    |     let n : Int = @js.identity(js)
    |     Some(Number(n))
    |   } else {
 28 |     None
    |     ^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub fn JsonRpcRequest::to_any(self : JsonRpcRequest) -> @js.Object {
    |   let obj = @js.Object::new()
    |   obj.set("jsonrpc", self.jsonrpc)
    |   obj.set("id", self.id.to_any())
    |   obj.set("method", self.method_name)
    |   match self.params {
 48 |     Some(p) => obj.set("params", p)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    |   obj
    | }
    …

    | pub fn JsonRpcRequest::from_js(js : @js.Any) -> JsonRpcRequest? {
    |   let obj : @js.Object = @js.identity(js)
    |   let jsonrpc : String? = obj.get("jsonrpc") |> @js.identity_option()
    |   let id_js = obj.get("id")
    |   let method_name : String? = obj.get("method") |> @js.identity_option()
    |   match (jsonrpc, method_name) {
    |     (Some(jrpc), Some(m)) =>
    |       match RequestId::from_js(id_js) {
    |         Some(id) =>
    |           Some({
    |             jsonrpc: jrpc,
    |             id,
    |             method_name: m,
    |             params: obj.get("params") |> @js.identity_option(),
    |           })
 70 |         None => None
    |         ^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
 72 |     _ => None
    |     ^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub fn JsonRpcResponse::to_any(self : JsonRpcResponse) -> @js.Object {
 86 |   let obj = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   obj.set("jsonrpc", self.jsonrpc)
    |   obj.set("id", self.id.to_any())
    |   obj.set("result", self.result)
    |   obj
    | }
    …

    | pub fn JsonRpcError::to_any(self : JsonRpcError) -> @js.Object {
103 |   let obj = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   obj.set("code", self.code)
    |   obj.set("message", self.message)
    |   match self.data {
    |     Some(d) => obj.set("data", d)
    |     None => ()
    |   }
    |   obj
    | }
    …

    | pub fn JsonRpcErrorResponse::to_any(self : JsonRpcErrorResponse) -> @js.Object {
122 |   let obj = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   obj.set("jsonrpc", self.jsonrpc)
    |   obj.set("id", self.id.to_any())
    |   obj.set("error", self.error.to_any())
    |   obj
    | }
    …

    | pub fn JsonRpcNotification::to_any(self : JsonRpcNotification) -> @js.Object {
139 |   let obj = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   obj.set("jsonrpc", self.jsonrpc)
    |   obj.set("method", self.method_name)
    |   match self.params {
    |     Some(p) => obj.set("params", p)
    |     None => ()
    |   }
    |   obj
    | }
    …

12 uncovered line(s) in src/npm/puppeteer/_example/cdp_example.mbt:

   | pub fn cdp_example() -> Unit {
 4 |   @js.run_async(async fn() -> Unit noraise {
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     println("\n=== CDP Session Example ===")
   |     let browser = @puppeteer.launch(headless=true) catch {
   |       e => {
   |         println("Failed to launch browser: \{e}")
   |         return
   |       }
   |     }
12 |     let page = browser.newPage() catch {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       e => {
   |         println("Failed to create page: \{e}")
   |         browser.close() catch {
   |           _ => ()
   |         }
   |         return
   |       }
   |     }
   | 
   |     // Create CDP session
23 |     let session = page.createCDPSession() catch {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       e => {
   |         println("Failed to create CDP session: \{e}")
   |         browser.close() catch {
   |           _ => ()
   |         }
   |         return
   |       }
   |     }
32 |     println("✓ Created CDP session")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | 
   |     // Get session ID
35 |     let sessionId = session.id()
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     println("Session ID: \{sessionId}")
   | 
   |     // Enable network tracking via CDP
39 |     session.send_simple("Network.enable") catch {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       e => {
   |         println("Failed to enable network: \{e}")
   |         browser.close() catch {
   |           _ => ()
   |         }
   |         return
   |       }
   |     }
48 |     println("✓ Enabled network tracking via CDP")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | 
   |     // Navigate to example.com
51 |     page.goto("https://example.com") catch {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       e => {
   |         println("Failed to navigate: \{e}")
   |         browser.close() catch {
   |           _ => ()
   |         }
   |         return
   |       }
   |     }
60 |     println("✓ Navigated to example.com")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | 
   |     // Detach session
63 |     session.detach() catch {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       e => {
   |         println("Failed to detach session: \{e}")
   |         browser.close() catch {
   |           _ => ()
   |         }
   |         return
   |       }
   |     }
72 |     println("✓ Detached CDP session")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     browser.close() catch {
   |       _ => ()
   |     }
76 |     println("✓ Browser closed")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   })
   | }
   …

15 uncovered line(s) in src/npm/puppeteer/_example/coverage_example.mbt:

   | pub fn coverage_example() -> Unit {
 4 |   @js.run_async(async fn() -> Unit noraise {
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     println("\n=== Code Coverage Example ===")
   |     let browser = @puppeteer.launch(headless=true) catch {
   |       e => {
   |         println("Failed to launch browser: \{e}")
   |         return
   |       }
   |     }
12 |     let page = browser.newPage() catch {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       e => {
   |         println("Failed to create page: \{e}")
   |         browser.close() catch {
   |           _ => ()
   |         }
   |         return
   |       }
   |     }
   | 
   |     // Get coverage instance
23 |     let coverage = page.coverage()
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     println("✓ Got coverage instance")
   | 
   |     // Start coverage tracking
27 |     coverage.startJSCoverage() catch {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       e => {
   |         println("Failed to start JS coverage: \{e}")
   |         browser.close() catch {
   |           _ => ()
   |         }
   |         return
   |       }
   |     }
36 |     coverage.startCSSCoverage() catch {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       e => {
   |         println("Failed to start CSS coverage: \{e}")
   |         browser.close() catch {
   |           _ => ()
   |         }
   |         return
   |       }
   |     }
45 |     println("✓ Started JS and CSS coverage tracking")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | 
   |     // Navigate to example.com
48 |     page.goto("https://example.com") catch {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       e => {
   |         println("Failed to navigate: \{e}")
   |         browser.close() catch {
   |           _ => ()
   |         }
   |         return
   |       }
   |     }
57 |     println("✓ Navigated to example.com")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | 
   |     // Stop coverage and get results
60 |     let jsCoverage = coverage.stopJSCoverage() catch {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       e => {
   |         println("Failed to stop JS coverage: \{e}")
   |         browser.close() catch {
   |           _ => ()
   |         }
   |         return
   |       }
   |     }
69 |     let cssCoverage = coverage.stopCSSCoverage() catch {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       e => {
   |         println("Failed to stop CSS coverage: \{e}")
   |         browser.close() catch {
   |           _ => ()
   |         }
   |         return
   |       }
   |     }
78 |     println("✓ Stopped coverage tracking")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     println("JS coverage entries: \{jsCoverage.length()}")
   |     println("CSS coverage entries: \{cssCoverage.length()}")
   | 
   |     // Display first entry info if available
   |     if jsCoverage.length() > 0 {
84 |       let first = jsCoverage[0]
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       let url : String = first.get("url").cast()
   |       println("First JS entry URL: \{url}")
   |     }
   |     if cssCoverage.length() > 0 {
89 |       let first = cssCoverage[0]
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       let url : String = first.get("url").cast()
   |       println("First CSS entry URL: \{url}")
   |     }
93 |     browser.close() catch {
   |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       _ => ()
   |     }
96 |     println("✓ Browser closed")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   })
   | }
   …

11 uncovered line(s) in src/npm/puppeteer/_example/element_example.mbt:

   | pub fn element_example() -> Unit {
 4 |   @js.run_async(async fn() -> Unit noraise {
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     println("\n=== Element Interaction Example ===")
   |     let browser = @puppeteer.launch(headless=true) catch {
   |       e => {
   |         println("Failed to launch browser: \{e}")
   |         return
   |       }
   |     }
12 |     let page = browser.newPage() catch {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       e => {
   |         println("Failed to create page: \{e}")
   |         browser.close() catch {
   |           _ => ()
   |         }
   |         return
   |       }
   |     }
   | 
   |     // Navigate to example.com
23 |     page.goto("https://example.com") catch {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       e => {
   |         println("Failed to navigate: \{e}")
   |         browser.close() catch {
   |           _ => ()
   |         }
   |         return
   |       }
   |     }
32 |     println("✓ Navigated to example.com")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | 
   |     // Query all paragraphs
35 |     let paragraphs = page.query_selector_all("p") catch {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       e => {
   |         println("Failed to query paragraphs: \{e}")
   |         browser.close() catch {
   |           _ => ()
   |         }
   |         return
   |       }
   |     }
44 |     println("✓ Found \{paragraphs.length()} paragraphs")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | 
   |     // Query single h1
47 |     let h1 = page.query_selector("h1") catch {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       e => {
   |         println("Failed to query h1: \{e}")
   |         browser.close() catch {
   |           _ => ()
   |         }
   |         return
   |       }
   |     }
56 |     match h1 {
   |     ^^^^^^^^^^ 	<-- UNCOVERED
   |       Some(_) => println("✓ Found h1 element")
   |       None => println("✗ No h1 element found")
   |     }
   | 
   |     // Evaluate JavaScript
62 |     let result = page.evaluate("document.title") catch {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       e => {
   |         println("Failed to evaluate: \{e}")
   |         browser.close() catch {
   |           _ => ()
   |         }
   |         return
   |       }
   |     }
71 |     println("✓ JavaScript evaluation result: \{result}")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     browser.close() catch {
   |       _ => ()
   |     }
75 |     println("✓ Browser closed")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   })
   | }
   …

15 uncovered line(s) in src/npm/puppeteer/_example/main.mbt:

   | fn main {
 4 |   basic_example()
   |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   screenshot_example()
   |   element_example()
   |   coverage_example()
   |   cdp_example()
   | }
   …

   | fn basic_example() -> Unit {
14 |   @js.run_async(async fn() -> Unit noraise {
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     println("=== Puppeteer Basic Example ===")
   | 
   |     // Launch browser
18 |     println("Launching browser...")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     let browser = @puppeteer.launch(headless=true) catch {
   |       e => {
   |         println("Failed to launch browser: \{e}")
   |         return
   |       }
   |     }
25 |     println("✓ Browser launched")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | 
   |     // Create new page
28 |     let page = browser.newPage() catch {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       e => {
   |         println("Failed to create page: \{e}")
   |         browser.close() catch {
   |           _ => ()
   |         }
   |         return
   |       }
   |     }
37 |     println("✓ New page created")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | 
   |     // Navigate to example.com
40 |     page.goto("https://example.com") catch {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       e => {
   |         println("Failed to navigate: \{e}")
   |         browser.close() catch {
   |           _ => ()
   |         }
   |         return
   |       }
   |     }
49 |     println("✓ Navigated to example.com")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | 
   |     // Get page title
52 |     let title = page.title() catch {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       e => {
   |         println("Failed to get title: \{e}")
   |         browser.close() catch {
   |           _ => ()
   |         }
   |         return
   |       }
   |     }
61 |     println("Page title: \{title}")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | 
   |     // Get page URL
64 |     let url = page.url()
   |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     println("Page URL: \{url}")
   | 
   |     // Get page content
68 |     let content = page.content() catch {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       e => {
   |         println("Failed to get content: \{e}")
   |         browser.close() catch {
   |           _ => ()
   |         }
   |         return
   |       }
   |     }
77 |     println("Content length: \{content.length()} characters")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | 
   |     // Close browser
80 |     browser.close() catch {
   |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       e => println("Failed to close browser: \{e}")
   |     }
83 |     println("✓ Browser closed")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     println("\n=== Example completed successfully ===")
   |   })
   | }
   …

9 uncovered line(s) in src/npm/puppeteer/_example/screenshot_example.mbt:

   | pub fn screenshot_example() -> Unit {
 4 |   @js.run_async(async fn() -> Unit noraise {
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     println("\n=== Screenshot Example ===")
   |     let browser = @puppeteer.launch(headless=true) catch {
   |       e => {
   |         println("Failed to launch browser: \{e}")
   |         return
   |       }
   |     }
12 |     let page = browser.newPage() catch {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       e => {
   |         println("Failed to create page: \{e}")
   |         browser.close() catch {
   |           _ => ()
   |         }
   |         return
   |       }
   |     }
   | 
   |     // Set viewport size
23 |     page.setViewport(1920, 1080) catch {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       e => {
   |         println("Failed to set viewport: \{e}")
   |         browser.close() catch {
   |           _ => ()
   |         }
   |         return
   |       }
   |     }
32 |     println("✓ Viewport set to 1920x1080")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | 
   |     // Navigate to example.com
35 |     page.goto("https://example.com") catch {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       e => {
   |         println("Failed to navigate: \{e}")
   |         browser.close() catch {
   |           _ => ()
   |         }
   |         return
   |       }
   |     }
44 |     println("✓ Navigated to example.com")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | 
   |     // Take screenshot
47 |     page.screenshot("/tmp/puppeteer-example.png") catch {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       e => {
   |         println("Failed to take screenshot: \{e}")
   |         browser.close() catch {
   |           _ => ()
   |         }
   |         return
   |       }
   |     }
56 |     println("✓ Screenshot saved to /tmp/puppeteer-example.png")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     browser.close() catch {
   |       _ => ()
   |     }
60 |     println("✓ Browser closed")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   })
   | }
   …

8 uncovered line(s) in src/npm/puppeteer/cdp.mbt:

   | pub async fn Page::createCDPSession(self : Page) -> CDPSession {
21 |   let promise : @js.Promise[CDPSession] = @js.identity(
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     self.call("createCDPSession", []),
   |   )
24 |   promise.wait()
   |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub async fn CDPSession::detach(self : CDPSession) -> Unit {
34 |   let promise : @js.Promise[Unit] = @js.identity(self.call("detach", []))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   promise.wait()
   | }
   …

   | pub fn CDPSession::id(self : CDPSession) -> String {
43 |   self.call("id", []).cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub async fn CDPSession::send(
   |   self : CDPSession,
   |   method_ : String,
   |   params : @js.Any,
   | ) -> @js.Any {
55 |   let promise : @js.Promise[@js.Any] = @js.identity(
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     self.call("send", [method_, params]),
   |   )
58 |   promise.wait()
   |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub async fn CDPSession::send_simple(
   |   self : CDPSession,
   |   method_ : String,
   | ) -> Unit {
68 |   let promise : @js.Promise[@js.Any] = @js.identity(
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     self.call("send", [method_]),
   |   )
71 |   let _ = promise.wait()
   |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | 
   | }
   …

13 uncovered line(s) in src/npm/puppeteer/coverage.mbt:

    | pub fn Page::coverage(self : Page) -> Coverage {
 44 |   self.get("coverage").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn Coverage::startJSCoverage(self : Coverage) -> Unit {
 54 |   let promise : @js.Promise[Unit] = @js.identity(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self.call("startJSCoverage", []),
    |   )
 57 |   promise.wait()
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn Coverage::startJSCoverage_with(
    |   self : Coverage,
    |   options : @js.Any,
    | ) -> Unit {
 67 |   let promise : @js.Promise[Unit] = @js.identity(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self.call("startJSCoverage", [options]),
    |   )
 70 |   promise.wait()
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn Coverage::stopJSCoverage(self : Coverage) -> Array[@js.Any] {
 79 |   let promise : @js.Promise[Array[@js.Any]] = @js.identity(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self.call("stopJSCoverage", []),
    |   )
 82 |   promise.wait()
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn Coverage::startCSSCoverage(self : Coverage) -> Unit {
 90 |   let promise : @js.Promise[Unit] = @js.identity(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self.call("startCSSCoverage", []),
    |   )
 93 |   promise.wait()
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn Coverage::startCSSCoverage_with(
    |   self : Coverage,
    |   options : @js.Any,
    | ) -> Unit {
103 |   let promise : @js.Promise[Unit] = @js.identity(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self.call("startCSSCoverage", [options]),
    |   )
106 |   promise.wait()
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn Coverage::stopCSSCoverage(self : Coverage) -> Array[@js.Any] {
115 |   let promise : @js.Promise[Array[@js.Any]] = @js.identity(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self.call("stopCSSCoverage", []),
    |   )
118 |   promise.wait()
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

31 uncovered line(s) in src/npm/puppeteer/network.mbt:

    | pub async fn Page::setRequestInterception(self : Page, value : Bool) -> Unit {
 30 |   let promise : @js.Promise[Unit] = @js.identity(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self.call("setRequestInterception", [value]),
    |   )
 33 |   promise.wait()
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn HTTPRequest::abort(self : HTTPRequest) -> Unit {
 42 |   let promise : @js.Promise[Unit] = @js.identity(self.call("abort", []))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   promise.wait()
    | }
    …

    | pub async fn HTTPRequest::continue_(self : HTTPRequest) -> Unit {
 50 |   let promise : @js.Promise[Unit] = @js.identity(self.call("continue", []))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   promise.wait()
    | }
    …

    | pub async fn HTTPRequest::continue_with(
    |   self : HTTPRequest,
    |   overrides : @js.Any,
    | ) -> Unit {
 61 |   let promise : @js.Promise[Unit] = @js.identity(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self.call("continue", [overrides]),
    |   )
 64 |   promise.wait()
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn HTTPRequest::respond(
    |   self : HTTPRequest,
    |   response : @js.Any,
    | ) -> Unit {
 74 |   let promise : @js.Promise[Unit] = @js.identity(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self.call("respond", [response]),
    |   )
 77 |   promise.wait()
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTTPRequest::isInterceptResolutionHandled(self : HTTPRequest) -> Bool {
 84 |   self.call("isInterceptResolutionHandled", []).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTTPRequest::url(self : HTTPRequest) -> String {
 91 |   self.call("url", []).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTTPRequest::method_(self : HTTPRequest) -> String {
 98 |   self.call("method", []).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTTPRequest::headers(self : HTTPRequest) -> @js.Any {
105 |   self.call("headers", [])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTTPRequest::resourceType(self : HTTPRequest) -> String {
112 |   self.call("resourceType", []).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTTPRequest::isNavigationRequest(self : HTTPRequest) -> Bool {
119 |   self.call("isNavigationRequest", []).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTTPRequest::response(self : HTTPRequest) -> HTTPResponse? {
126 |   self.call("response", []).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTTPRequest::redirectChain(self : HTTPRequest) -> Array[HTTPRequest] {
133 |   self.call("redirectChain", []).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTTPRequest::hasPostData(self : HTTPRequest) -> Bool {
140 |   self.call("hasPostData", []).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn HTTPRequest::fetchPostData(self : HTTPRequest) -> String {
147 |   let promise : @js.Promise[String] = @js.identity(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self.call("fetchPostData", []),
    |   )
150 |   promise.wait()
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTTPResponse::url(self : HTTPResponse) -> String {
159 |   self.call("url", []).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTTPResponse::status(self : HTTPResponse) -> Int {
166 |   self.call("status", []).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTTPResponse::statusText(self : HTTPResponse) -> String {
173 |   self.call("statusText", []).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTTPResponse::ok(self : HTTPResponse) -> Bool {
180 |   self.call("ok", []).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTTPResponse::headers(self : HTTPResponse) -> @js.Any {
187 |   self.call("headers", [])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn HTTPResponse::text(self : HTTPResponse) -> String {
194 |   let promise : @js.Promise[String] = @js.identity(self.call("text", []))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   promise.wait()
    | }
    …

    | pub async fn HTTPResponse::json(self : HTTPResponse) -> @js.Any {
202 |   let promise : @js.Promise[@js.Any] = @js.identity(self.call("json", []))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   promise.wait()
    | }
    …

    | pub async fn HTTPResponse::buffer(self : HTTPResponse) -> @js.Any {
210 |   let promise : @js.Promise[@js.Any] = @js.identity(self.call("buffer", []))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   promise.wait()
    | }
    …

    | pub fn HTTPResponse::fromCache(self : HTTPResponse) -> Bool {
218 |   self.call("fromCache", []).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTTPResponse::fromServiceWorker(self : HTTPResponse) -> Bool {
225 |   self.call("fromServiceWorker", []).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTTPResponse::request(self : HTTPResponse) -> HTTPRequest {
232 |   self.call("request", []).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTTPResponse::remoteAddress(self : HTTPResponse) -> String {
239 |   self.call("remoteAddress", []).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

54 uncovered line(s) in src/npm/puppeteer/page.mbt:

    | pub async fn Page::goto(self : Page, url : String) -> Unit {
 22 |   let promise : @js.Promise[Unit] = @js.identity(self.call("goto", [url]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   promise.wait()
    | }
    …

    | pub async fn Page::content(self : Page) -> String {
 29 |   let promise : @js.Promise[String] = @js.identity(self.call("content", []))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   promise.wait()
    | }
    …

    | pub async fn Page::screenshot(self : Page, path : String) -> Unit {
 36 |   let opts = @js.from_entries([("path", path)])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let promise : @js.Promise[Unit] = @js.identity(
    |     self.call("screenshot", [opts]),
    |   )
 40 |   promise.wait()
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn Page::click(self : Page, selector : String) -> Unit {
 48 |   let promise : @js.Promise[Unit] = @js.identity(self.call("click", [selector]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   promise.wait()
    | }
    …

    | pub async fn Page::type_(self : Page, selector : String, text : String) -> Unit {
 55 |   let promise : @js.Promise[Unit] = @js.identity(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self.call("type", [selector, text]),
    |   )
 58 |   promise.wait()
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn Page::waitForSelector(
    |   self : Page,
    |   selector : String,
    | ) -> ElementHandle? {
 68 |   let promise : @js.Promise[ElementHandle?] = @js.identity(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self.call("waitForSelector", [selector]),
    |   )
 71 |   promise.wait()
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn Page::query_selector(
    |   self : Page,
    |   selector : String,
    | ) -> ElementHandle? {
 81 |   let promise : @js.Promise[ElementHandle?] = @js.identity(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self.call("$", [selector]),
    |   )
 84 |   promise.wait()
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn Page::query_selector_all(
    |   self : Page,
    |   selector : String,
    | ) -> Array[ElementHandle] {
 94 |   let promise : @js.Promise[Array[ElementHandle]] = @js.identity(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self.call("$$", [selector]),
    |   )
 97 |   promise.wait()
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn Page::evaluate(self : Page, script : String) -> @js.Any {
103 |   let promise : @js.Promise[@js.Any] = @js.identity(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self.call("evaluate", [script]),
    |   )
106 |   promise.wait()
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn Page::setViewport(self : Page, width : Int, height : Int) -> Unit {
113 |   let viewport = @js.from_entries([("width", width), ("height", height)])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let promise : @js.Promise[Unit] = @js.identity(
    |     self.call("setViewport", [viewport]),
    |   )
117 |   promise.wait()
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn Page::setUserAgent(self : Page, userAgent : String) -> Unit {
123 |   let promise : @js.Promise[Unit] = @js.identity(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self.call("setUserAgent", [userAgent]),
    |   )
126 |   promise.wait()
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn Page::reload(self : Page) -> Unit {
132 |   let promise : @js.Promise[Unit] = @js.identity(self.call("reload", []))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   promise.wait()
    | }
    …

    | pub async fn Page::title(self : Page) -> String {
139 |   let promise : @js.Promise[String] = @js.identity(self.call("title", []))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   promise.wait()
    | }
    …

    | pub fn Page::url(self : Page) -> String {
146 |   self.call("url", []).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn Page::focus(
    |   self : Page,
    |   selector : String,
    | ) -> Unit raise @js.ThrowError {
155 |   let promise : @js.Promise[Unit] = @js.identity(self.call("focus", [selector]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   promise.wait() catch {
    |     e => raise @js.ThrowError::from_js(@js.unsafe_any(e))
    |   }
    | }
    …

    | pub async fn Page::hover(
    |   self : Page,
    |   selector : String,
    | ) -> Unit raise @js.ThrowError {
167 |   let promise : @js.Promise[Unit] = @js.identity(self.call("hover", [selector]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   promise.wait() catch {
    |     e => raise @js.ThrowError::from_js(@js.unsafe_any(e))
    |   }
    | }
    …

    | pub async fn Page::select(
    |   self : Page,
    |   selector : String,
    |   values : Array[String],
    | ) -> Array[String] raise @js.ThrowError {
181 |   let js_values = @js.from_array(values)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let promise : @js.Promise[Array[String]] = @js.identity(
    |     self.call("select", [selector, js_values]),
    |   )
185 |   promise.wait() catch {
    |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     e => raise @js.ThrowError::from_js(@js.unsafe_any(e))
    |   }
    | }
    …

    | pub async fn Page::tap(self : Page, selector : String) -> Unit {
193 |   let promise : @js.Promise[Unit] = @js.identity(self.call("tap", [selector]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   promise.wait()
    | }
    …

    | pub async fn Page::waitForNavigation(self : Page) -> Unit {
203 |   let promise : @js.Promise[Unit] = @js.identity(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self.call("waitForNavigation", []),
    |   )
206 |   promise.wait()
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn Page::waitForFunction(self : Page, fn_str : String) -> @js.Any {
213 |   let promise : @js.Promise[@js.Any] = @js.identity(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self.call("waitForFunction", [fn_str]),
    |   )
216 |   promise.wait()
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn Page::waitForTimeout(self : Page, ms : Int) -> Unit {
223 |   let promise : @js.Promise[Unit] = @js.identity(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self.call("waitForTimeout", [ms]),
    |   )
226 |   promise.wait()
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn Page::cookies(self : Page) -> Array[@js.Any] raise @js.ThrowError {
248 |   let promise : @js.Promise[Array[@js.Any]] = @js.identity(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self.call("cookies", []),
    |   )
251 |   promise.wait() catch {
    |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     e => raise @js.ThrowError::from_js(@js.unsafe_any(e))
    |   }
    | }
    …

    | pub async fn Page::setCookie(self : Page, cookies : Array[@js.Any]) -> Unit {
260 |   let js_cookies = @js.from_array(cookies)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let promise : @js.Promise[Unit] = @js.identity(
    |     self.call("setCookie", [js_cookies]),
    |   )
264 |   promise.wait()
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn Page::deleteCookie(self : Page, cookies : Array[@js.Any]) -> Unit {
271 |   let js_cookies = @js.from_array(cookies)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let promise : @js.Promise[Unit] = @js.identity(
    |     self.call("deleteCookie", [js_cookies]),
    |   )
275 |   promise.wait()
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn Page::pdf(self : Page, path : String) -> Unit raise @js.ThrowError {
284 |   let opts = @js.from_entries([("path", path)])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let promise : @js.Promise[Unit] = @js.identity(self.call("pdf", [opts]))
    |   promise.wait() catch {
    |     e => raise @js.ThrowError::from_js(@js.unsafe_any(e))
    |   }
    | }
    …

    | pub async fn Page::goBack(self : Page) -> Unit {
297 |   let promise : @js.Promise[Unit] = @js.identity(self.call("goBack", []))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   promise.wait()
    | }
    …

    | pub async fn Page::goForward(self : Page) -> Unit {
305 |   let promise : @js.Promise[Unit] = @js.identity(self.call("goForward", []))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   promise.wait()
    | }
    …

    | pub async fn Page::setContent(self : Page, html : String) -> Unit {
315 |   let promise : @js.Promise[Unit] = @js.identity(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self.call("setContent", [html]),
    |   )
318 |   promise.wait()
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn ElementHandle::click(self : ElementHandle) -> Unit {
326 |   let promise : @js.Promise[Unit] = @js.identity(self.call("click", []))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   promise.wait()
    | }
    …

    | pub async fn ElementHandle::type_(self : ElementHandle, text : String) -> Unit {
333 |   let promise : @js.Promise[Unit] = @js.identity(self.call("type", [text]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   promise.wait()
    | }
    …

    | pub async fn ElementHandle::getProperty(
    |   self : ElementHandle,
    |   propertyName : String,
    | ) -> @js.Any {
344 |   let promise : @js.Promise[@js.Any] = @js.identity(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self.call("getProperty", [propertyName]),
    |   )
347 |   promise.wait()
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn ElementHandle::query_selector(
    |   self : ElementHandle,
    |   selector : String,
    | ) -> ElementHandle? {
357 |   let promise : @js.Promise[ElementHandle?] = @js.identity(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self.call("$", [selector]),
    |   )
360 |   promise.wait()
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn ElementHandle::query_selector_all(
    |   self : ElementHandle,
    |   selector : String,
    | ) -> Array[ElementHandle] {
370 |   let promise : @js.Promise[Array[ElementHandle]] = @js.identity(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self.call("$$", [selector]),
    |   )
373 |   promise.wait()
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn ElementHandle::focus(self : ElementHandle) -> Unit {
379 |   let promise : @js.Promise[Unit] = @js.identity(self.call("focus", []))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   promise.wait()
    | }
    …

    | pub async fn ElementHandle::hover(self : ElementHandle) -> Unit {
386 |   let promise : @js.Promise[Unit] = @js.identity(self.call("hover", []))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   promise.wait()
    | }
    …

21 uncovered line(s) in src/npm/puppeteer/puppeteer.mbt:

    | pub async fn launch(
    |   headless? : Bool,
    |   args? : Array[String],
    |   executablePath? : String,
    |   devtools? : Bool,
    |   timeout? : Int,
    |   userDataDir? : String,
    |   dumpio? : Bool,
    |   env? : @js.Any,
    |   pipe? : Bool,
    |   ignoreDefaultArgs? : Bool,
    |   waitForInitialPage? : Bool,
    |   debuggingPort? : Int,
    |   handleSIGHUP? : Bool,
    |   handleSIGINT? : Bool,
    |   handleSIGTERM? : Bool,
    | ) -> Browser {
 45 |   let js_opts = @js.from_entries([])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match headless {
    |     Some(h) => js_opts.set("headless", @js.any(h))
    |     None => ()
    |   }
 50 |   match args {
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(a) => js_opts.set("args", @js.from_array(a))
    |     None => ()
    |   }
 54 |   match executablePath {
    |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(p) => js_opts.set("executablePath", @js.any(p))
    |     None => ()
    |   }
 58 |   match devtools {
    |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(d) => js_opts.set("devtools", @js.any(d))
    |     None => ()
    |   }
 62 |   match timeout {
    |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(t) => js_opts.set("timeout", @js.any(t))
    |     None => ()
    |   }
 66 |   match userDataDir {
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(u) => js_opts.set("userDataDir", @js.any(u))
    |     None => ()
    |   }
 70 |   match dumpio {
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(d) => js_opts.set("dumpio", @js.any(d))
    |     None => ()
    |   }
 74 |   match env {
    |   ^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(e) => js_opts.set("env", e)
    |     None => ()
    |   }
 78 |   match pipe {
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(p) => js_opts.set("pipe", @js.any(p))
    |     None => ()
    |   }
 82 |   match ignoreDefaultArgs {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(i) => js_opts.set("ignoreDefaultArgs", @js.any(i))
    |     None => ()
    |   }
 86 |   match waitForInitialPage {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(w) => js_opts.set("waitForInitialPage", @js.any(w))
    |     None => ()
    |   }
 90 |   match debuggingPort {
    |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(d) => js_opts.set("debuggingPort", @js.any(d))
    |     None => ()
    |   }
 94 |   match handleSIGHUP {
    |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(h) => js_opts.set("handleSIGHUP", @js.any(h))
    |     None => ()
    |   }
 98 |   match handleSIGINT {
    |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(h) => js_opts.set("handleSIGINT", @js.any(h))
    |     None => ()
    |   }
102 |   match handleSIGTERM {
    |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(h) => js_opts.set("handleSIGTERM", @js.any(h))
    |     None => ()
    |   }
106 |   let promise : @js.Promise[Browser] = @js.identity(ffi_launch(js_opts))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   promise.wait()
    | }
    …

    | pub async fn Browser::newPage(self : Browser) -> Page {
115 |   let promise : @js.Promise[Page] = @js.identity(self.call("newPage", []))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   promise.wait()
    | }
    …

    | pub async fn Browser::close(self : Browser) -> Unit {
122 |   let promise : @js.Promise[Unit] = @js.identity(self.call("close", []))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   promise.wait()
    | }
    …

    | pub async fn Browser::pages(self : Browser) -> Array[Page] {
129 |   let promise : @js.Promise[Array[Page]] = @js.identity(self.call("pages", []))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   promise.wait()
    | }
    …

    | pub async fn Browser::version(self : Browser) -> String {
136 |   let promise : @js.Promise[String] = @js.identity(self.call("version", []))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   promise.wait()
    | }
    …

    | pub async fn Browser::userAgent(self : Browser) -> String {
143 |   let promise : @js.Promise[String] = @js.identity(self.call("userAgent", []))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   promise.wait()
    | }
    …

1 uncovered line(s) in src/npm/react/component.mbt:

   | pub fn strict_mode(children : Array[&ReactNode]) -> Element {
29 |   let tag = @js.identity(get_strict_mode())
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   let children = children.map(_.to_react_node()) |> @js.from_array
   |   ffi_create_element(tag, @js.undefined(), children) |> @js.identity
   | }
   …

15 uncovered line(s) in src/npm/react/hooks.mbt:

    | pub fn[T] ReactRef::set_current(self : ReactRef[T], value : T?) -> Unit {
    |   let js_val : @js.Any = match value {
    |     Some(v) => @js.identity(v)
 96 |     None => @js.undefined()
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   // Direct assignment to JS field
    |   ffi_set_ref_current(self |> @js.identity, js_val)
    | }
    …

    | #alias(usePromise)
    | pub fn[T] use_promise(promise : @js.Promise[T]) -> T {
134 |   @js.identity(ffi_react_use(promise |> @js.identity))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(useDeferredValue)
    | pub fn[T] use_deferred_value(value : T, initial_value? : T) -> T {
    |   let initial = match initial_value {
234 |     Some(v) => v |> @js.unsafe_any
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => @js.undefined()
    |   }
    |   ffi_use_deferred_value(value |> @js.unsafe_any, initial) |> @js.identity
    | }
    …

    | #alias(useDebugValue)
    | pub fn[T, R] use_debug_value(value : T, format? : (T) -> R) -> Unit {
253 |   match format {
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(f) => ffi_use_debug_value(value |> @js.unsafe_any, f |> @js.unsafe_any)
    |     None => ffi_use_debug_value(value |> @js.unsafe_any, @js.undefined())
    |   }
    | }
    …

    | #alias(useInsertionEffect)
    | pub fn use_insertion_effect(
    |   f : () -> () -> Unit,
    |   keys : Array[&@js.JsImpl],
    | ) -> Unit {
325 |   let deps = keys.map(_.to_any()) |> @js.from_array
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ffi_use_insertion_effect(f |> @js.unsafe_any, deps)
    | }
    …

    | #alias(useSyncExternalStore)
    | pub fn[Snapshot] use_sync_external_store(
    |   subscribe : (() -> Unit) -> () -> Unit,
    |   get_snapshot : () -> Snapshot,
    |   get_server_snapshot? : () -> Snapshot,
    | ) -> Snapshot {
347 |   let server_snapshot = match get_server_snapshot {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(f) => f |> @js.unsafe_any
    |     None => @js.undefined()
    |   }
351 |   ffi_use_sync_external_store(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     subscribe |> @js.unsafe_any,
    |     get_snapshot |> @js.unsafe_any,
    |     server_snapshot,
    |   )
356 |   |> @js.identity
    |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(captureOwnerStack)
    | pub fn capture_owner_stack() -> @js.Any? {
394 |   let result = ffi_capture_owner_stack()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   if @js.is_nullish(result) {
396 |     None
    |     ^^^^ 	<-- UNCOVERED
    |   } else {
398 |     Some(result)
    |     ^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | #alias(cacheSignal)
    | pub fn cache_signal() -> @js.Any {
411 |   ffi_cache_signal()
    |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(reactCache)
    | pub fn[T, R] react_cache(f : (T) -> R) -> (T) -> R {
424 |   ffi_react_cache(f |> @js.unsafe_any) |> @js.identity
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn act(callback : () -> Unit) -> @js.Promise[Unit] {
435 |   ffi_act(callback |> @js.unsafe_any) |> @js.identity
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(actAsync)
    | pub async fn act_async(callback : async () -> Unit) -> Unit {
447 |   let promise_fn = @js.promisify0(callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ffi_act_async(promise_fn |> @js.unsafe_any).wait()
    | }
    …

2 uncovered line(s) in src/npm/react/init.mbt:

   | pub async fn dynamic_import_async() -> Unit {
27 |   if @js.is_nullish(@js.global_this().get("__ReactApi")) {
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     let react : @js.Any = import_react().wait()
   |     @js.global_this().set("__ReactApi", react)
   |   }
   | }
   …

   | #alias(initReactAsync)
   | pub async fn init_react_async() -> Unit {
37 |   dynamic_import_async()
   |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

3 uncovered line(s) in src/npm/react_dom_client/client.mbt:

   | pub async fn dynamic_import_async() -> ReactDOMClient {
27 |   import_react_dom_client_internal().wait()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | #alias(create_root)
   | pub fn ReactDOMClient::createRoot(
   |   self : Self,
   |   container : &@dom.ElementImpl,
   | ) -> ReactDOMRoot {
41 |   self.call("createRoot", [container.to_any()]).cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn ReactDOMRoot::render(self : ReactDOMRoot, vdom : @react.Element) -> Unit {
46 |   self.call("render", [vdom]) |> ignore
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

21 uncovered line(s) in src/npm/react_element/element_bench.mbt:

    | fn init_minimal_react_api() -> Unit {
 18 |   @react.init_react_api(ffi_create_minimal_react_api())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | fn create_complex_component() -> @react.Element {
 24 |   div(id="app", [
    |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     // Header section
 26 |     header([
    |     ^^^^^^^^ 	<-- UNCOVERED
    |       nav([
    |         ul([
    |           li([a(href="/", ["Home"])]),
    |           li([a(href="/about", ["About"])]),
    |           li([a(href="/products", ["Products"])]),
    |           li([a(href="/contact", ["Contact"])]),
    |         ]),
    |       ]),
 35 |       h1(["Welcome to Our Store"]),
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ]),
    |     // Main content section
 38 |     main_([
    |     ^^^^^^^ 	<-- UNCOVERED
    |       article([
    |         h2(["Featured Products"]),
    |         div(class="product-grid", [
    |           // Product cards
 43 |           div(class="product-card", [
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             img(src="/product1.jpg", alt="Product 1", []),
    |             h3(["Product 1"]),
    |             p(["Description of product 1 with some details."]),
    |             button(type_="button", ["Add to Cart"]),
    |           ]),
 49 |           div(class="product-card", [
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             img(src="/product2.jpg", alt="Product 2", []),
    |             h3(["Product 2"]),
    |             p(["Description of product 2 with some details."]),
    |             button(type_="button", ["Add to Cart"]),
    |           ]),
 55 |           div(class="product-card", [
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             img(src="/product3.jpg", alt="Product 3", []),
    |             h3(["Product 3"]),
    |             p(["Description of product 3 with some details."]),
    |             button(type_="button", ["Add to Cart"]),
    |           ]),
    |         ]),
    |       ]),
 63 |       aside([
    |       ^^^^^^^ 	<-- UNCOVERED
    |         h3(["Categories"]),
    |         ul([
    |           li([a(href="/category/electronics", ["Electronics"])]),
    |           li([a(href="/category/clothing", ["Clothing"])]),
    |           li([a(href="/category/books", ["Books"])]),
    |           li([a(href="/category/home", ["Home & Garden"])]),
    |         ]),
    |       ]),
    |     ]),
    |     // Footer section
 74 |     footer([
    |     ^^^^^^^^ 	<-- UNCOVERED
    |       div([
    |         section([h4(["About Us"]), p(["We are a leading online retailer."])]),
    |         section([
    |           h4(["Contact"]),
    |           p(["Email: info@example.com"]),
    |           p(["Phone: 123-456-7890"]),
    |         ]),
 82 |         section([
    |         ^^^^^^^^^ 	<-- UNCOVERED
    |           h4(["Follow Us"]),
    |           ul([
    |             li([a(href="https://facebook.com", ["Facebook"])]),
    |             li([a(href="https://twitter.com", ["Twitter"])]),
    |             li([a(href="https://instagram.com", ["Instagram"])]),
    |           ]),
    |         ]),
    |       ]),
    |     ]),
    |   ])
    | }
    …

    | fn create_form_component() -> @react.Element {
105 |   form([
    |   ^^^^^^ 	<-- UNCOVERED
    |     div([
    |       label(["First Name:"], "firstName"),
    |       input(
    |         type_="text",
    |         id="firstName",
    |         name="firstName",
    |         placeholder="Enter first name",
    |       ),
    |     ]),
115 |     div([
    |     ^^^^^ 	<-- UNCOVERED
    |       label(["Last Name:"], "lastName"),
    |       input(
    |         type_="text",
    |         id="lastName",
    |         name="lastName",
    |         placeholder="Enter last name",
    |       ),
    |     ]),
124 |     div([
    |     ^^^^^ 	<-- UNCOVERED
    |       label(["Email:"], "email"),
    |       input(type_="email", id="email", name="email", placeholder="Enter email"),
    |     ]),
128 |     div([
    |     ^^^^^ 	<-- UNCOVERED
    |       label(["Message:"], "message"),
    |       textarea(id="message", placeholder="Enter your message", []),
    |     ]),
132 |     div([
    |     ^^^^^ 	<-- UNCOVERED
    |       label(["Country:"], "country"),
    |       select(id="country", name="country", [
    |         option(value="us", ["USA"]),
    |         option(value="ca", ["Canada"]),
    |         option(value="uk", ["UK"]),
    |         option(value="jp", ["Japan"]),
    |       ]),
    |     ]),
141 |     button(type_="submit", ["Submit"]),
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ])
    | }
    …

    | fn create_svg_chart() -> @react.Element {
158 |   svg(width=400, height=300, [
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     // Background
160 |     rect(x=0, y=0, width=400, height=300, fill="white", stroke="black"),
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     // Data bars
162 |     rect(x=50, y=250, width=40, height=50, fill="blue"),
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     rect(x=100, y=200, width=40, height=100, fill="blue"),
    |     rect(x=150, y=150, width=40, height=150, fill="blue"),
    |     rect(x=200, y=180, width=40, height=120, fill="blue"),
    |     rect(x=250, y=220, width=40, height=80, fill="blue"),
    |     // Labels
168 |     text(x=200, y=30, ["Chart Title"]),
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     text(x=70, y=280, ["2020"]),
    |     text(x=120, y=280, ["2021"]),
    |     text(x=170, y=280, ["2022"]),
    |     text(x=220, y=280, ["2023"]),
    |     text(x=270, y=280, ["2024"]),
    |   ])
    | }
    …

57 uncovered line(s) in src/npm/react_element/html.mbt:

     | fn[T] common_node(
     |   tag_name : String,
     |   props : @js.Object,
     |   children~ : Array[&@react.ReactNode],
     |   id~ : String?,
     |   class~ : String?,
     |   style~ : Map[String, String]?,
     |   tab_index~ : Int?,
     |   ref_~ : @react.ReactRef[T]?,
     |   key~ : String?,
     |   on_click~ : @react.MouseEventHandler[T]?,
     |   on_change~ : @react.ChangeEventHandler[T]?,
     |   on_keydown~ : @react.KeyboardEventHandler[T]?,
     |   on_keyup~ : @react.KeyboardEventHandler[T]?,
     |   on_focus~ : @react.FocusEventHandler[T]?,
     |   on_blur~ : @react.FocusEventHandler[T]?,
     |   on_drag~ : @react.DragEventHandler[T]?,
     |   on_dragstart~ : @react.DragEventHandler[T]?,
     |   on_dragend~ : @react.DragEventHandler[T]?,
     |   on_dragleave~ : @react.DragEventHandler[T]?,
     |   on_dragenter~ : @react.DragEventHandler[T]?,
     |   on_dragover~ : @react.DragEventHandler[T]?,
     |   on_drop~ : @react.DragEventHandler[T]?,
     | ) -> @react.Element {
     |   if id is Some(id) {
     |     props.set("id", id)
     |   }
     |   if class is Some(class) {
     |     props.set("className", class)
     |   }
     |   if tab_index is Some(tab_index) {
     |     props.set("tabIndex", tab_index)
     |   }
     |   if style is Some(style) {
     |     let style_obj = @js.Object::new()
     |     for k, v in style {
     |       style_obj.set(k, v)
     |     }
     |     props.set("style", style_obj.to_any())
     |   }
     |   if ref_ is Some(ref_) {
     |     props.set("ref", ref_ |> @js.any)
     |   }
     |   if key is Some(key) {
     |     props.set("key", key)
     |   }
     |   if on_click is Some(f) {
     |     props.set("onClick", f |> @js.from_fn1)
     |   }
     |   if on_change is Some(f) {
     |     props.set("onChange", f |> @js.from_fn1)
     |   }
     |   if on_keydown is Some(f) {
     |     props.set("onKeyDown", f |> @js.from_fn1)
     |   }
     |   if on_keyup is Some(f) {
     |     props.set("onKeyUp", f |> @js.from_fn1)
     |   }
     |   if on_focus is Some(f) {
     |     props.set("onFocus", f |> @js.from_fn1)
     |   }
     |   if on_blur is Some(f) {
     |     props.set("onBlur", f |> @js.from_fn1)
     |   }
     |   // Optimize: avoid array allocation, handle drag handlers directly
     |   if on_drag is Some(f) {
     |     props.set("onDrag", f |> @js.from_fn1)
     |   }
     |   if on_dragstart is Some(f) {
     |     props.set("onDragStart", f |> @js.from_fn1)
     |   }
     |   if on_dragend is Some(f) {
     |     props.set("onDragEnd", f |> @js.from_fn1)
     |   }
     |   if on_dragleave is Some(f) {
  79 |     props.set("onDragLeave", f |> @js.from_fn1)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if on_dragenter is Some(f) {
  82 |     props.set("onDragEnter", f |> @js.from_fn1)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if on_dragover is Some(f) {
  85 |     props.set("onDragOver", f |> @js.from_fn1)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if on_drop is Some(f) {
     |     props.set("onDrop", f |> @js.from_fn1)
     |   }
     |   let children_js = children.map(_.to_react_node()) |> @js.from_array
     |   @react.createElementDirect(tag_name, props.to_any(), children_js)
     | }
     …

     | pub fn pre(
     |   // common props
     |   children : Array[&@react.ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     |   // react
     |   ref_? : @react.ReactRef[@dom.Element],
     |   key? : String,
     |   // event handlers
     |   on_click? : @react.MouseEventHandler[@dom.Element],
     |   on_change? : @react.ChangeEventHandler[@dom.Element],
     |   on_keydown? : @react.KeyboardEventHandler[@dom.Element],
     |   on_keyup? : @react.KeyboardEventHandler[@dom.Element],
     |   on_focus? : @react.FocusEventHandler[@dom.Element],
     |   on_blur? : @react.FocusEventHandler[@dom.Element],
     |   on_drag? : @react.DragEventHandler[@dom.Element],
     |   on_dragstart? : @react.DragEventHandler[@dom.Element],
     |   on_dragend? : @react.DragEventHandler[@dom.Element],
     |   on_dragleave? : @react.DragEventHandler[@dom.Element],
     |   on_dragenter? : @react.DragEventHandler[@dom.Element],
     |   on_dragover? : @react.DragEventHandler[@dom.Element],
     |   on_drop? : @react.DragEventHandler[@dom.Element],
     | ) -> @react.Element {
     |   common_node(
     |     "pre",
     |     match props {
 182 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     tab_index~,
     |     class~,
     |     style~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn blockquote(
     |   // common props
     |   children : Array[&@react.ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     |   // react
     |   ref_? : @react.ReactRef[@dom.Element],
     |   key? : String,
     |   // event handlers
     |   on_click? : @react.MouseEventHandler[@dom.Element],
     |   on_change? : @react.ChangeEventHandler[@dom.Element],
     |   on_keydown? : @react.KeyboardEventHandler[@dom.Element],
     |   on_keyup? : @react.KeyboardEventHandler[@dom.Element],
     |   on_focus? : @react.FocusEventHandler[@dom.Element],
     |   on_blur? : @react.FocusEventHandler[@dom.Element],
     |   on_drag? : @react.DragEventHandler[@dom.Element],
     |   on_dragstart? : @react.DragEventHandler[@dom.Element],
     |   on_dragend? : @react.DragEventHandler[@dom.Element],
     |   on_dragleave? : @react.DragEventHandler[@dom.Element],
     |   on_dragenter? : @react.DragEventHandler[@dom.Element],
     |   on_dragover? : @react.DragEventHandler[@dom.Element],
     |   on_drop? : @react.DragEventHandler[@dom.Element],
     | ) -> @react.Element {
     |   common_node(
     |     "blockquote",
     |     match props {
 239 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn span(
     |   children : Array[&@react.ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     |   // react
     |   ref_? : @react.ReactRef[@dom.HTMLSpanElement],
     |   key? : String,
     |   // event handlers
     |   on_click? : @react.MouseEventHandler[@dom.HTMLSpanElement],
     |   on_change? : @react.ChangeEventHandler[@dom.HTMLSpanElement],
     |   on_keydown? : @react.KeyboardEventHandler[@dom.HTMLSpanElement],
     |   on_keyup? : @react.KeyboardEventHandler[@dom.HTMLSpanElement],
     |   on_focus? : @react.FocusEventHandler[@dom.HTMLSpanElement],
     |   on_blur? : @react.FocusEventHandler[@dom.HTMLSpanElement],
     |   on_drag? : @react.DragEventHandler[@dom.HTMLSpanElement],
     |   on_dragstart? : @react.DragEventHandler[@dom.HTMLSpanElement],
     |   on_dragend? : @react.DragEventHandler[@dom.HTMLSpanElement],
     |   on_dragleave? : @react.DragEventHandler[@dom.HTMLSpanElement],
     |   on_dragenter? : @react.DragEventHandler[@dom.HTMLSpanElement],
     |   on_dragover? : @react.DragEventHandler[@dom.HTMLSpanElement],
     |   on_drop? : @react.DragEventHandler[@dom.HTMLSpanElement],
     | ) -> @react.Element {
     |   common_node(
     |     "span",
     |     match props {
 295 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     ref_~,
     |     tab_index~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn nav(
     |   children : Array[&@react.ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     |   // react
     |   ref_? : @react.ReactRef[@dom.Element],
     |   key? : String,
     |   // event handlers
     |   on_click? : @react.MouseEventHandler[@dom.Element],
     |   on_change? : @react.ChangeEventHandler[@dom.Element],
     |   on_keydown? : @react.KeyboardEventHandler[@dom.Element],
     |   on_keyup? : @react.KeyboardEventHandler[@dom.Element],
     |   on_focus? : @react.FocusEventHandler[@dom.Element],
     |   on_blur? : @react.FocusEventHandler[@dom.Element],
     |   on_drag? : @react.DragEventHandler[@dom.Element],
     |   on_dragstart? : @react.DragEventHandler[@dom.Element],
     |   on_dragend? : @react.DragEventHandler[@dom.Element],
     |   on_dragleave? : @react.DragEventHandler[@dom.Element],
     |   on_dragenter? : @react.DragEventHandler[@dom.Element],
     |   on_dragover? : @react.DragEventHandler[@dom.Element],
     |   on_drop? : @react.DragEventHandler[@dom.Element],
     | ) -> @react.Element {
     |   common_node(
     |     "nav",
     |     match props {
 351 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     ref_~,
     |     tab_index~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn textarea(
     |   children : Array[&@react.ReactNode],
     |   rows? : Int,
     |   columns? : Int,
     |   spellcheck? : Bool,
     |   value? : String,
     |   default_value? : String,
     |   placeholder? : String,
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     |   // react
     |   ref_? : @react.ReactRef[@dom.HTMLTextAreaElement],
     |   key? : String,
     |   // event handlers
     |   on_click? : @react.MouseEventHandler[@dom.HTMLTextAreaElement],
     |   on_change? : @react.ChangeEventHandler[@dom.HTMLTextAreaElement],
     |   on_keydown? : @react.KeyboardEventHandler[@dom.HTMLTextAreaElement],
     |   on_keyup? : @react.KeyboardEventHandler[@dom.HTMLTextAreaElement],
     |   on_focus? : @react.FocusEventHandler[@dom.HTMLTextAreaElement],
     |   on_blur? : @react.FocusEventHandler[@dom.HTMLTextAreaElement],
     |   on_drag? : @react.DragEventHandler[@dom.HTMLTextAreaElement],
     |   on_dragstart? : @react.DragEventHandler[@dom.HTMLTextAreaElement],
     |   on_dragend? : @react.DragEventHandler[@dom.HTMLTextAreaElement],
     |   on_dragleave? : @react.DragEventHandler[@dom.HTMLTextAreaElement],
     |   on_dragenter? : @react.DragEventHandler[@dom.HTMLTextAreaElement],
     |   on_dragover? : @react.DragEventHandler[@dom.HTMLTextAreaElement],
     |   on_drop? : @react.DragEventHandler[@dom.HTMLTextAreaElement],
     | ) -> @react.Element {
     |   let custom_props : @js.Object = match props {
     |     Some(p) => @js.Object::assign(@js.Object::new(), p).cast()
     |     None => @js.Object::new()
     |   }
     |   if rows is Some(r) {
     |     custom_props.set("rows", r)
     |   }
     |   if columns is Some(c) {
     |     custom_props.set("cols", c)
     |   }
     |   if spellcheck is Some(s) {
     |     custom_props.set("spellCheck", s)
     |   }
     |   if value is Some(v) {
 480 |     custom_props.set("value", v)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if default_value is Some(dv) {
     |     custom_props.set("defaultValue", dv)
     |   }
     |   if placeholder is Some(ph) {
     |     custom_props.set("placeholder", ph)
     |   }
     |   common_node(
     |     "textarea",
     |     custom_props,
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn main_(
     |   children : Array[&@react.ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     |   // react
     |   ref_? : @react.ReactRef[@dom.Element],
     |   key? : String,
     |   // event handlers
     |   on_click? : @react.MouseEventHandler[@dom.Element],
     |   on_change? : @react.ChangeEventHandler[@dom.Element],
     |   on_keydown? : @react.KeyboardEventHandler[@dom.Element],
     |   on_keyup? : @react.KeyboardEventHandler[@dom.Element],
     |   on_focus? : @react.FocusEventHandler[@dom.Element],
     |   on_blur? : @react.FocusEventHandler[@dom.Element],
     |   on_drag? : @react.DragEventHandler[@dom.Element],
     |   on_dragstart? : @react.DragEventHandler[@dom.Element],
     |   on_dragend? : @react.DragEventHandler[@dom.Element],
     |   on_dragleave? : @react.DragEventHandler[@dom.Element],
     |   on_dragenter? : @react.DragEventHandler[@dom.Element],
     |   on_dragover? : @react.DragEventHandler[@dom.Element],
     |   on_drop? : @react.DragEventHandler[@dom.Element],
     | ) -> @react.Element {
     |   common_node(
     |     "main",
     |     match props {
 620 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn header(
     |   children : Array[&@react.ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : @react.ReactRef[@dom.Element],
     |   key? : String,
     |   // event handlers
     |   on_click? : @react.MouseEventHandler[@dom.Element],
     |   on_change? : @react.ChangeEventHandler[@dom.Element],
     |   on_keydown? : @react.KeyboardEventHandler[@dom.Element],
     |   on_keyup? : @react.KeyboardEventHandler[@dom.Element],
     |   on_focus? : @react.FocusEventHandler[@dom.Element],
     |   on_blur? : @react.FocusEventHandler[@dom.Element],
     |   on_drag? : @react.DragEventHandler[@dom.Element],
     |   on_dragstart? : @react.DragEventHandler[@dom.Element],
     |   on_dragend? : @react.DragEventHandler[@dom.Element],
     |   on_dragleave? : @react.DragEventHandler[@dom.Element],
     |   on_dragenter? : @react.DragEventHandler[@dom.Element],
     |   on_dragover? : @react.DragEventHandler[@dom.Element],
     |   on_drop? : @react.DragEventHandler[@dom.Element],
     | ) -> @react.Element {
     |   common_node(
     |     "header",
     |     match props {
 677 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn footer(
     |   children : Array[&@react.ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : @react.ReactRef[@dom.Element],
     |   key? : String,
     |   // event handlers
     |   on_click? : @react.MouseEventHandler[@dom.Element],
     |   on_change? : @react.ChangeEventHandler[@dom.Element],
     |   on_keydown? : @react.KeyboardEventHandler[@dom.Element],
     |   on_keyup? : @react.KeyboardEventHandler[@dom.Element],
     |   on_focus? : @react.FocusEventHandler[@dom.Element],
     |   on_blur? : @react.FocusEventHandler[@dom.Element],
     |   on_drag? : @react.DragEventHandler[@dom.Element],
     |   on_dragstart? : @react.DragEventHandler[@dom.Element],
     |   on_dragend? : @react.DragEventHandler[@dom.Element],
     |   on_dragleave? : @react.DragEventHandler[@dom.Element],
     |   on_dragenter? : @react.DragEventHandler[@dom.Element],
     |   on_dragover? : @react.DragEventHandler[@dom.Element],
     |   on_drop? : @react.DragEventHandler[@dom.Element],
     | ) -> @react.Element {
     |   common_node(
     |     "footer",
     |     match props {
 734 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn ol(
     |   children : Array[&@react.ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : @react.ReactRef[@dom.HTMLOListElement],
     |   key? : String,
     |   // event handlers
     |   on_click? : @react.MouseEventHandler[@dom.HTMLOListElement],
     |   on_change? : @react.ChangeEventHandler[@dom.HTMLOListElement],
     |   on_keydown? : @react.KeyboardEventHandler[@dom.HTMLOListElement],
     |   on_keyup? : @react.KeyboardEventHandler[@dom.HTMLOListElement],
     |   on_focus? : @react.FocusEventHandler[@dom.HTMLOListElement],
     |   on_blur? : @react.FocusEventHandler[@dom.HTMLOListElement],
     |   on_drag? : @react.DragEventHandler[@dom.HTMLOListElement],
     |   on_dragstart? : @react.DragEventHandler[@dom.HTMLOListElement],
     |   on_dragend? : @react.DragEventHandler[@dom.HTMLOListElement],
     |   on_dragleave? : @react.DragEventHandler[@dom.HTMLOListElement],
     |   on_dragenter? : @react.DragEventHandler[@dom.HTMLOListElement],
     |   on_dragover? : @react.DragEventHandler[@dom.HTMLOListElement],
     |   on_drop? : @react.DragEventHandler[@dom.HTMLOListElement],
     | ) -> @react.Element {
     |   common_node(
     |     "ol",
     |     match props {
 848 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn article(
     |   children : Array[&@react.ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     |   // react
     |   ref_? : @react.ReactRef[@dom.Element],
     |   key? : String,
     |   // event handlers
     |   on_click? : @react.MouseEventHandler[@dom.Element],
     |   on_change? : @react.ChangeEventHandler[@dom.Element],
     |   on_keydown? : @react.KeyboardEventHandler[@dom.Element],
     |   on_keyup? : @react.KeyboardEventHandler[@dom.Element],
     |   on_focus? : @react.FocusEventHandler[@dom.Element],
     |   on_blur? : @react.FocusEventHandler[@dom.Element],
     |   on_drag? : @react.DragEventHandler[@dom.Element],
     |   on_dragstart? : @react.DragEventHandler[@dom.Element],
     |   on_dragend? : @react.DragEventHandler[@dom.Element],
     |   on_dragleave? : @react.DragEventHandler[@dom.Element],
     |   on_dragenter? : @react.DragEventHandler[@dom.Element],
     |   on_dragover? : @react.DragEventHandler[@dom.Element],
     |   on_drop? : @react.DragEventHandler[@dom.Element],
     | ) -> @react.Element {
     |   common_node(
     |     "article",
     |     match props {
 904 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn aside(
     |   children : Array[&@react.ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     |   // react
     |   ref_? : @react.ReactRef[@dom.Element],
     |   key? : String,
     |   // event handlers
     |   on_click? : @react.MouseEventHandler[@dom.Element],
     |   on_change? : @react.ChangeEventHandler[@dom.Element],
     |   on_keydown? : @react.KeyboardEventHandler[@dom.Element],
     |   on_keyup? : @react.KeyboardEventHandler[@dom.Element],
     |   on_focus? : @react.FocusEventHandler[@dom.Element],
     |   on_blur? : @react.FocusEventHandler[@dom.Element],
     |   on_drag? : @react.DragEventHandler[@dom.Element],
     |   on_dragstart? : @react.DragEventHandler[@dom.Element],
     |   on_dragend? : @react.DragEventHandler[@dom.Element],
     |   on_dragleave? : @react.DragEventHandler[@dom.Element],
     |   on_dragenter? : @react.DragEventHandler[@dom.Element],
     |   on_dragover? : @react.DragEventHandler[@dom.Element],
     |   on_drop? : @react.DragEventHandler[@dom.Element],
     | ) -> @react.Element {
     |   common_node(
     |     "aside",
     |     match props {
 960 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn section(
     |   children : Array[&@react.ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     |   // react
     |   ref_? : @react.ReactRef[@dom.Element],
     |   key? : String,
     |   // event handlers
     |   on_click? : @react.MouseEventHandler[@dom.Element],
     |   on_change? : @react.ChangeEventHandler[@dom.Element],
     |   on_keydown? : @react.KeyboardEventHandler[@dom.Element],
     |   on_keyup? : @react.KeyboardEventHandler[@dom.Element],
     |   on_focus? : @react.FocusEventHandler[@dom.Element],
     |   on_blur? : @react.FocusEventHandler[@dom.Element],
     |   on_drag? : @react.DragEventHandler[@dom.Element],
     |   on_dragstart? : @react.DragEventHandler[@dom.Element],
     |   on_dragend? : @react.DragEventHandler[@dom.Element],
     |   on_dragleave? : @react.DragEventHandler[@dom.Element],
     |   on_dragenter? : @react.DragEventHandler[@dom.Element],
     |   on_dragover? : @react.DragEventHandler[@dom.Element],
     |   on_drop? : @react.DragEventHandler[@dom.Element],
     | ) -> @react.Element {
     |   common_node(
     |     "section",
     |     match props {
1016 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn form(
     |   children : Array[&@react.ReactNode],
     | 
     |   // xxx
     |   method_? : String,
     |   disabled? : Bool,
     |   name? : String,
     |   enc_type? : String,
     |   action? : (@http.FormData) -> Unit,
     |   on_submit? : (@dom.FormEvent) -> Unit,
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : @react.ReactRef[@dom.HTMLFormElement],
     |   key? : String,
     |   // event handlers
     |   on_click? : @react.MouseEventHandler[@dom.HTMLFormElement],
     |   on_change? : @react.ChangeEventHandler[@dom.HTMLFormElement],
     |   on_keydown? : @react.KeyboardEventHandler[@dom.HTMLFormElement],
     |   on_keyup? : @react.KeyboardEventHandler[@dom.HTMLFormElement],
     |   on_focus? : @react.FocusEventHandler[@dom.HTMLFormElement],
     |   on_blur? : @react.FocusEventHandler[@dom.HTMLFormElement],
     |   on_drag? : @react.DragEventHandler[@dom.HTMLFormElement],
     |   on_dragstart? : @react.DragEventHandler[@dom.HTMLFormElement],
     |   on_dragend? : @react.DragEventHandler[@dom.HTMLFormElement],
     |   on_dragleave? : @react.DragEventHandler[@dom.HTMLFormElement],
     |   on_dragenter? : @react.DragEventHandler[@dom.HTMLFormElement],
     |   on_dragover? : @react.DragEventHandler[@dom.HTMLFormElement],
     |   on_drop? : @react.DragEventHandler[@dom.HTMLFormElement],
     | ) -> @react.Element {
     |   let custom_props : @js.Object = match props {
1079 |     Some(p) => @js.Object::assign(@js.Object::new(), p).cast()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => @js.Object::new()
     |   }
     |   if disabled is Some(d) {
1083 |     custom_props.set("disabled", d)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if name is Some(n) {
1086 |     custom_props.set("name", n)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if method_ is Some(m) {
     |     custom_props.set("method", m)
     |   }
     |   if on_submit is Some(f) {
     |     let fn_value : @js.Any = f |> @js.from_fn1
     |     custom_props.set("onSubmit", fn_value)
     |   }
     |   if action is Some(f) {
1096 |     let fn_value : @js.Any = f |> @js.from_fn1
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     custom_props.set("action", fn_value)
     |   }
     |   if enc_type is Some(e) {
1100 |     custom_props.set("encType", e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   common_node(
     |     "form",
     |     custom_props,
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn select(
     |   children : Array[&@react.ReactNode],
     |   // xxx
     |   multiple? : Bool,
     |   disabled? : Bool,
     |   name? : String,
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     |   // react
     |   ref_? : @react.ReactRef[@dom.HTMLSelectElement],
     |   key? : String,
     |   // event handlers
     |   on_click? : @react.MouseEventHandler[@dom.HTMLSelectElement],
     |   on_change? : @react.ChangeEventHandler[@dom.HTMLSelectElement],
     |   on_keydown? : @react.KeyboardEventHandler[@dom.HTMLSelectElement],
     |   on_keyup? : @react.KeyboardEventHandler[@dom.HTMLSelectElement],
     |   on_focus? : @react.FocusEventHandler[@dom.HTMLSelectElement],
     |   on_blur? : @react.FocusEventHandler[@dom.HTMLSelectElement],
     |   on_drag? : @react.DragEventHandler[@dom.HTMLSelectElement],
     |   on_dragstart? : @react.DragEventHandler[@dom.HTMLSelectElement],
     |   on_dragend? : @react.DragEventHandler[@dom.HTMLSelectElement],
     |   on_dragleave? : @react.DragEventHandler[@dom.HTMLSelectElement],
     |   on_dragenter? : @react.DragEventHandler[@dom.HTMLSelectElement],
     |   on_dragover? : @react.DragEventHandler[@dom.HTMLSelectElement],
     |   on_drop? : @react.DragEventHandler[@dom.HTMLSelectElement],
     | ) -> @react.Element {
     |   let custom_props : @js.Object = match props {
1160 |     Some(p) => @js.Object::assign(@js.Object::new(), p).cast()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => @js.Object::new()
     |   }
     |   if multiple is Some(m) {
1164 |     custom_props.set("multiple", m)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if disabled is Some(d) {
1167 |     custom_props.set("disabled", d)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if name is Some(n) {
1170 |     custom_props.set("name", n)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   common_node(
     |     "select",
     |     custom_props,
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn option(
     |   children : Array[&@react.ReactNode],
     |   value~ : String,
     |   selected? : Bool,
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : @react.ReactRef[@dom.HTMLOptionElement],
     |   key? : String,
     |   // event handlers
     |   on_click? : @react.MouseEventHandler[@dom.HTMLOptionElement],
     |   on_change? : @react.ChangeEventHandler[@dom.HTMLOptionElement],
     |   on_keydown? : @react.KeyboardEventHandler[@dom.HTMLOptionElement],
     |   on_keyup? : @react.KeyboardEventHandler[@dom.HTMLOptionElement],
     |   on_focus? : @react.FocusEventHandler[@dom.HTMLOptionElement],
     |   on_blur? : @react.FocusEventHandler[@dom.HTMLOptionElement],
     |   on_drag? : @react.DragEventHandler[@dom.HTMLOptionElement],
     |   on_dragstart? : @react.DragEventHandler[@dom.HTMLOptionElement],
     |   on_dragend? : @react.DragEventHandler[@dom.HTMLOptionElement],
     |   on_dragleave? : @react.DragEventHandler[@dom.HTMLOptionElement],
     |   on_dragenter? : @react.DragEventHandler[@dom.HTMLOptionElement],
     |   on_dragover? : @react.DragEventHandler[@dom.HTMLOptionElement],
     |   on_drop? : @react.DragEventHandler[@dom.HTMLOptionElement],
     | ) -> @react.Element {
     |   let custom_props : @js.Object = match props {
1229 |     Some(p) => @js.Object::assign(@js.Object::new(), p).cast()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => @js.Object::new()
     |   }
     |   custom_props.set("value", value)
     |   if selected is Some(s) {
1234 |     custom_props.set("selected", s)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   common_node(
     |     "option",
     |     custom_props,
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn label(
     |   children : Array[&@react.ReactNode],
     |   htmlFor : String,
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : @react.ReactRef[@dom.HTMLLabelElement],
     |   key? : String,
     |   // event handlers
     |   on_click? : @react.MouseEventHandler[@dom.HTMLLabelElement],
     |   on_change? : @react.ChangeEventHandler[@dom.HTMLLabelElement],
     |   on_keydown? : @react.KeyboardEventHandler[@dom.HTMLLabelElement],
     |   on_keyup? : @react.KeyboardEventHandler[@dom.HTMLLabelElement],
     |   on_focus? : @react.FocusEventHandler[@dom.HTMLLabelElement],
     |   on_blur? : @react.FocusEventHandler[@dom.HTMLLabelElement],
     |   on_drag? : @react.DragEventHandler[@dom.HTMLLabelElement],
     |   on_dragstart? : @react.DragEventHandler[@dom.HTMLLabelElement],
     |   on_dragend? : @react.DragEventHandler[@dom.HTMLLabelElement],
     |   on_dragleave? : @react.DragEventHandler[@dom.HTMLLabelElement],
     |   on_dragenter? : @react.DragEventHandler[@dom.HTMLLabelElement],
     |   on_dragover? : @react.DragEventHandler[@dom.HTMLLabelElement],
     |   on_drop? : @react.DragEventHandler[@dom.HTMLLabelElement],
     | ) -> @react.Element {
     |   let custom_props : @js.Object = match props {
1292 |     Some(p) => @js.Object::assign(@js.Object::new(), p).cast()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => @js.Object::new()
     |   }
     |   custom_props.set("htmlFor", htmlFor)
     |   common_node(
     |     "label",
     |     custom_props,
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn li(
     |   children : Array[&@react.ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : @react.ReactRef[@dom.HTMLLIElement],
     |   key? : String,
     |   // event handlers
     |   on_click? : @react.MouseEventHandler[@dom.HTMLLIElement],
     |   on_change? : @react.ChangeEventHandler[@dom.HTMLLIElement],
     |   on_keydown? : @react.KeyboardEventHandler[@dom.HTMLLIElement],
     |   on_keyup? : @react.KeyboardEventHandler[@dom.HTMLLIElement],
     |   on_focus? : @react.FocusEventHandler[@dom.HTMLLIElement],
     |   on_blur? : @react.FocusEventHandler[@dom.HTMLLIElement],
     |   on_drag? : @react.DragEventHandler[@dom.HTMLLIElement],
     |   on_dragstart? : @react.DragEventHandler[@dom.HTMLLIElement],
     |   on_dragend? : @react.DragEventHandler[@dom.HTMLLIElement],
     |   on_dragleave? : @react.DragEventHandler[@dom.HTMLLIElement],
     |   on_dragenter? : @react.DragEventHandler[@dom.HTMLLIElement],
     |   on_dragover? : @react.DragEventHandler[@dom.HTMLLIElement],
     |   on_drop? : @react.DragEventHandler[@dom.HTMLLIElement],
     | ) -> @react.Element {
     |   common_node(
     |     "li",
     |     match props {
1353 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn code(
     |   children : Array[&@react.ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : @react.ReactRef[@dom.Element],
     |   key? : String,
     |   // event handlers
     |   on_click? : @react.MouseEventHandler[@dom.Element],
     |   on_change? : @react.ChangeEventHandler[@dom.Element],
     |   on_keydown? : @react.KeyboardEventHandler[@dom.Element],
     |   on_keyup? : @react.KeyboardEventHandler[@dom.Element],
     |   on_focus? : @react.FocusEventHandler[@dom.Element],
     |   on_blur? : @react.FocusEventHandler[@dom.Element],
     |   on_drag? : @react.DragEventHandler[@dom.Element],
     |   on_dragstart? : @react.DragEventHandler[@dom.Element],
     |   on_dragend? : @react.DragEventHandler[@dom.Element],
     |   on_dragleave? : @react.DragEventHandler[@dom.Element],
     |   on_dragenter? : @react.DragEventHandler[@dom.Element],
     |   on_dragover? : @react.DragEventHandler[@dom.Element],
     |   on_drop? : @react.DragEventHandler[@dom.Element],
     | ) -> @react.Element {
     |   common_node(
     |     "code",
     |     match props {
1410 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn details(
     |   children : Array[&@react.ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : @react.ReactRef[@dom.Element],
     |   key? : String,
     |   // event handlers
     |   on_click? : @react.MouseEventHandler[@dom.Element],
     |   on_change? : @react.ChangeEventHandler[@dom.Element],
     |   on_keydown? : @react.KeyboardEventHandler[@dom.Element],
     |   on_keyup? : @react.KeyboardEventHandler[@dom.Element],
     |   on_focus? : @react.FocusEventHandler[@dom.Element],
     |   on_blur? : @react.FocusEventHandler[@dom.Element],
     |   on_drag? : @react.DragEventHandler[@dom.Element],
     |   on_dragstart? : @react.DragEventHandler[@dom.Element],
     |   on_dragend? : @react.DragEventHandler[@dom.Element],
     |   on_dragleave? : @react.DragEventHandler[@dom.Element],
     |   on_dragenter? : @react.DragEventHandler[@dom.Element],
     |   on_dragover? : @react.DragEventHandler[@dom.Element],
     |   on_drop? : @react.DragEventHandler[@dom.Element],
     | ) -> @react.Element {
     |   common_node(
     |     "details",
     |     match props {
1467 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn summary(
     |   children : Array[&@react.ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : @react.ReactRef[@dom.Element],
     |   key? : String,
     |   // event handlers
     |   on_click? : @react.MouseEventHandler[@dom.Element],
     |   on_change? : @react.ChangeEventHandler[@dom.Element],
     |   on_keydown? : @react.KeyboardEventHandler[@dom.Element],
     |   on_keyup? : @react.KeyboardEventHandler[@dom.Element],
     |   on_focus? : @react.FocusEventHandler[@dom.Element],
     |   on_blur? : @react.FocusEventHandler[@dom.Element],
     |   on_drag? : @react.DragEventHandler[@dom.Element],
     |   on_dragstart? : @react.DragEventHandler[@dom.Element],
     |   on_dragend? : @react.DragEventHandler[@dom.Element],
     |   on_dragleave? : @react.DragEventHandler[@dom.Element],
     |   on_dragenter? : @react.DragEventHandler[@dom.Element],
     |   on_dragover? : @react.DragEventHandler[@dom.Element],
     |   on_drop? : @react.DragEventHandler[@dom.Element],
     | ) -> @react.Element {
     |   common_node(
     |     "summary",
     |     match props {
1524 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn a(
     |   children : Array[&@react.ReactNode],
     | 
     |   // a specific
     |   href~ : String,
     |   download? : String,
     |   target? : String,
     | 
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : @react.ReactRef[@dom.HTMLAnchorElement],
     |   key? : String,
     |   // event handlers
     |   on_click? : @react.MouseEventHandler[@dom.HTMLAnchorElement],
     |   on_change? : @react.ChangeEventHandler[@dom.HTMLAnchorElement],
     |   on_keydown? : @react.KeyboardEventHandler[@dom.HTMLAnchorElement],
     |   on_keyup? : @react.KeyboardEventHandler[@dom.HTMLAnchorElement],
     |   on_focus? : @react.FocusEventHandler[@dom.HTMLAnchorElement],
     |   on_blur? : @react.FocusEventHandler[@dom.HTMLAnchorElement],
     |   on_drag? : @react.DragEventHandler[@dom.HTMLAnchorElement],
     |   on_dragstart? : @react.DragEventHandler[@dom.HTMLAnchorElement],
     |   on_dragend? : @react.DragEventHandler[@dom.HTMLAnchorElement],
     |   on_dragleave? : @react.DragEventHandler[@dom.HTMLAnchorElement],
     |   on_dragenter? : @react.DragEventHandler[@dom.HTMLAnchorElement],
     |   on_dragover? : @react.DragEventHandler[@dom.HTMLAnchorElement],
     |   on_drop? : @react.DragEventHandler[@dom.HTMLAnchorElement],
     | ) -> @react.Element {
     |   let custom_props : @js.Object = match props {
1585 |     Some(p) => @js.Object::assign(@js.Object::new(), p).cast()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => @js.Object::new()
     |   }
     |   custom_props.set("href", href)
     |   if download is Some(d) {
1590 |     custom_props.set("download", d)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if target is Some(t) {
     |     custom_props.set("target", t)
     |   }
     |   common_node(
     |     "a",
     |     custom_props,
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn iframe(
     |   children : Array[&@react.ReactNode],
     | 
     |   // a specific
     |   src~ : String,
     |   width? : Int,
     |   height? : Int,
     |   frameborder? : String,
     |   sandbox? : String,
     |   tab_index? : Int,
     |   allowfullscreen? : Bool,
     |   loading? : String,
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   // react
     |   ref_? : @react.ReactRef[@dom.Element],
     |   key? : String,
     |   // event handlers
     |   on_click? : @react.MouseEventHandler[@dom.Element],
     |   on_change? : @react.ChangeEventHandler[@dom.Element],
     |   on_keydown? : @react.KeyboardEventHandler[@dom.Element],
     |   on_keyup? : @react.KeyboardEventHandler[@dom.Element],
     |   on_focus? : @react.FocusEventHandler[@dom.Element],
     |   on_blur? : @react.FocusEventHandler[@dom.Element],
     |   on_drag? : @react.DragEventHandler[@dom.Element],
     |   on_dragstart? : @react.DragEventHandler[@dom.Element],
     |   on_dragend? : @react.DragEventHandler[@dom.Element],
     |   on_dragleave? : @react.DragEventHandler[@dom.Element],
     |   on_dragenter? : @react.DragEventHandler[@dom.Element],
     |   on_dragover? : @react.DragEventHandler[@dom.Element],
     |   on_drop? : @react.DragEventHandler[@dom.Element],
     | ) -> @react.Element {
     |   let custom_props : @js.Object = match props {
1658 |     Some(p) => @js.Object::assign(@js.Object::new(), p).cast()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => @js.Object::new()
     |   }
     |   custom_props.set("src", src)
     |   if width is Some(d) {
     |     custom_props.set("width", d)
     |   }
     |   if height is Some(d) {
     |     custom_props.set("height", d)
     |   }
     |   if frameborder is Some(d) {
1669 |     custom_props.set("frameborder", d)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if sandbox is Some(d) {
1672 |     custom_props.set("sandbox", d)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if allowfullscreen is Some(d) {
1675 |     custom_props.set("allowfullscreen", d)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if loading is Some(d) {
1678 |     custom_props.set("loading", d)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   common_node(
     |     "iframe",
     |     custom_props,
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn img(
     |   children : Array[&@react.ReactNode],
     | 
     |   // a specific
     |   src~ : String,
     |   srcset? : String,
     |   alt? : String,
     |   crossorigin? : String,
     |   decoding? : String,
     |   width? : Int,
     |   height? : Int,
     |   fetchpriority? : String,
     |   loading? : String,
     |   sizes? : String,
     | 
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : @react.ReactRef[@dom.HTMLImageElement],
     |   key? : String,
     |   // event handlers
     |   on_click? : @react.MouseEventHandler[@dom.HTMLImageElement],
     |   on_change? : @react.ChangeEventHandler[@dom.HTMLImageElement],
     |   on_keydown? : @react.KeyboardEventHandler[@dom.HTMLImageElement],
     |   on_keyup? : @react.KeyboardEventHandler[@dom.HTMLImageElement],
     |   on_focus? : @react.FocusEventHandler[@dom.HTMLImageElement],
     |   on_blur? : @react.FocusEventHandler[@dom.HTMLImageElement],
     |   on_drag? : @react.DragEventHandler[@dom.HTMLImageElement],
     |   on_dragstart? : @react.DragEventHandler[@dom.HTMLImageElement],
     |   on_dragend? : @react.DragEventHandler[@dom.HTMLImageElement],
     |   on_dragleave? : @react.DragEventHandler[@dom.HTMLImageElement],
     |   on_dragenter? : @react.DragEventHandler[@dom.HTMLImageElement],
     |   on_dragover? : @react.DragEventHandler[@dom.HTMLImageElement],
     |   on_drop? : @react.DragEventHandler[@dom.HTMLImageElement],
     | ) -> @react.Element {
     |   let custom_props : @js.Object = match props {
1748 |     Some(p) => @js.Object::assign(@js.Object::new(), p).cast()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => @js.Object::new()
     |   }
     |   custom_props.set("src", src)
     |   if alt is Some(d) {
     |     custom_props.set("alt", d)
     |   }
     |   if crossorigin is Some(d) {
1756 |     custom_props.set("crossorigin", d)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if decoding is Some(d) {
1759 |     custom_props.set("decoding", d)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if width is Some(d) {
     |     custom_props.set("width", d)
     |   }
     |   if height is Some(d) {
     |     custom_props.set("height", d)
     |   }
     |   if fetchpriority is Some(d) {
1768 |     custom_props.set("fetchpriority", d)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if loading is Some(d) {
1771 |     custom_props.set("loading", d)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if sizes is Some(d) {
1774 |     custom_props.set("sizes", d)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if srcset is Some(d) {
1777 |     custom_props.set("srcset", d)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   common_node(
     |     "img",
     |     custom_props,
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn video(
     |   children : Array[&@react.ReactNode],
     | 
     |   // a specific
     |   controls? : Bool,
     | 
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : @react.ReactRef[@dom.Element],
     |   key? : String,
     |   // event handlers
     |   on_click? : @react.MouseEventHandler[@dom.Element],
     |   on_change? : @react.ChangeEventHandler[@dom.Element],
     |   on_keydown? : @react.KeyboardEventHandler[@dom.Element],
     |   on_keyup? : @react.KeyboardEventHandler[@dom.Element],
     |   on_focus? : @react.FocusEventHandler[@dom.Element],
     |   on_blur? : @react.FocusEventHandler[@dom.Element],
     |   on_drag? : @react.DragEventHandler[@dom.Element],
     |   on_dragstart? : @react.DragEventHandler[@dom.Element],
     |   on_dragend? : @react.DragEventHandler[@dom.Element],
     |   on_dragleave? : @react.DragEventHandler[@dom.Element],
     |   on_dragenter? : @react.DragEventHandler[@dom.Element],
     |   on_dragover? : @react.DragEventHandler[@dom.Element],
     |   on_drop? : @react.DragEventHandler[@dom.Element],
     | ) -> @react.Element {
     |   let custom_props : @js.Object = match props {
1838 |     Some(p) => @js.Object::assign(@js.Object::new(), p).cast()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => @js.Object::new()
     |   }
     |   if controls is Some(c) {
     |     custom_props.set("controls", c |> @js.unsafe_any)
     |   }
     |   common_node(
     |     "video",
     |     custom_props,
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn source(
     |   // a specific
     |   src~ : String,
     |   type_? : String,
     | 
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : @react.ReactRef[@dom.Element],
     |   key? : String,
     |   // event handlers
     |   on_click? : @react.MouseEventHandler[@dom.Element],
     |   on_change? : @react.ChangeEventHandler[@dom.Element],
     |   on_keydown? : @react.KeyboardEventHandler[@dom.Element],
     |   on_keyup? : @react.KeyboardEventHandler[@dom.Element],
     |   on_focus? : @react.FocusEventHandler[@dom.Element],
     |   on_blur? : @react.FocusEventHandler[@dom.Element],
     |   on_drag? : @react.DragEventHandler[@dom.Element],
     |   on_dragstart? : @react.DragEventHandler[@dom.Element],
     |   on_dragend? : @react.DragEventHandler[@dom.Element],
     |   on_dragleave? : @react.DragEventHandler[@dom.Element],
     |   on_dragenter? : @react.DragEventHandler[@dom.Element],
     |   on_dragover? : @react.DragEventHandler[@dom.Element],
     |   on_drop? : @react.DragEventHandler[@dom.Element],
     | ) -> @react.Element {
     |   let custom_props : @js.Object = match props {
1902 |     Some(p) => @js.Object::assign(@js.Object::new(), p).cast()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => @js.Object::new()
     |   }
     |   custom_props.set("src", src |> @js.unsafe_any)
     |   if type_ is Some(t) {
     |     custom_props.set("type", t |> @js.unsafe_any)
     |   }
     |   common_node(
     |     "video",
     |     custom_props,
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children=[],
     |   )
     | }
     …

     | pub fn hr(
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : @react.ReactRef[@dom.Element],
     |   key? : String,
     |   // event handlers
     |   on_click? : @react.MouseEventHandler[@dom.Element],
     |   on_change? : @react.ChangeEventHandler[@dom.Element],
     |   on_keydown? : @react.KeyboardEventHandler[@dom.Element],
     |   on_keyup? : @react.KeyboardEventHandler[@dom.Element],
     |   on_focus? : @react.FocusEventHandler[@dom.Element],
     |   on_blur? : @react.FocusEventHandler[@dom.Element],
     |   on_drag? : @react.DragEventHandler[@dom.Element],
     |   on_dragstart? : @react.DragEventHandler[@dom.Element],
     |   on_dragend? : @react.DragEventHandler[@dom.Element],
     |   on_dragleave? : @react.DragEventHandler[@dom.Element],
     |   on_dragenter? : @react.DragEventHandler[@dom.Element],
     |   on_dragover? : @react.DragEventHandler[@dom.Element],
     |   on_drop? : @react.DragEventHandler[@dom.Element],
     | ) -> @react.Element {
1962 |   common_node(
     |   ^^^^^^^^^^^^ 	<-- UNCOVERED
     |     "hr",
1964 |     match props {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Some(p) => p
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children=[],
     |   )
     | }
     …

     | pub fn h1(
     |   children : Array[&@react.ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : @react.ReactRef[@dom.HTMLHeadingElement],
     |   key? : String,
     |   // event handlers
     |   on_click? : @react.MouseEventHandler[@dom.HTMLHeadingElement],
     |   on_change? : @react.ChangeEventHandler[@dom.HTMLHeadingElement],
     |   on_keydown? : @react.KeyboardEventHandler[@dom.HTMLHeadingElement],
     |   on_keyup? : @react.KeyboardEventHandler[@dom.HTMLHeadingElement],
     |   on_focus? : @react.FocusEventHandler[@dom.HTMLHeadingElement],
     |   on_blur? : @react.FocusEventHandler[@dom.HTMLHeadingElement],
     |   on_drag? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     |   on_dragstart? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     |   on_dragend? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     |   on_dragleave? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     |   on_dragenter? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     |   on_dragover? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     |   on_drop? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     | ) -> @react.Element {
     |   common_node(
     |     "h1",
     |     match props {
2022 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn h2(
     |   children : Array[&@react.ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : @react.ReactRef[@dom.HTMLHeadingElement],
     |   key? : String,
     |   // event handlers
     |   on_click? : @react.MouseEventHandler[@dom.HTMLHeadingElement],
     |   on_change? : @react.ChangeEventHandler[@dom.HTMLHeadingElement],
     |   on_keydown? : @react.KeyboardEventHandler[@dom.HTMLHeadingElement],
     |   on_keyup? : @react.KeyboardEventHandler[@dom.HTMLHeadingElement],
     |   on_focus? : @react.FocusEventHandler[@dom.HTMLHeadingElement],
     |   on_blur? : @react.FocusEventHandler[@dom.HTMLHeadingElement],
     |   on_drag? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     |   on_dragstart? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     |   on_dragend? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     |   on_dragleave? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     |   on_dragenter? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     |   on_dragover? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     |   on_drop? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     | ) -> @react.Element {
2076 |   common_node(
     |   ^^^^^^^^^^^^ 	<-- UNCOVERED
     |     "h2",
2078 |     match props {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Some(p) => p
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn h3(
     |   children : Array[&@react.ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : @react.ReactRef[@dom.HTMLHeadingElement],
     |   key? : String,
     |   // event handlers
     |   on_click? : @react.MouseEventHandler[@dom.HTMLHeadingElement],
     |   on_change? : @react.ChangeEventHandler[@dom.HTMLHeadingElement],
     |   on_keydown? : @react.KeyboardEventHandler[@dom.HTMLHeadingElement],
     |   on_keyup? : @react.KeyboardEventHandler[@dom.HTMLHeadingElement],
     |   on_focus? : @react.FocusEventHandler[@dom.HTMLHeadingElement],
     |   on_blur? : @react.FocusEventHandler[@dom.HTMLHeadingElement],
     |   on_drag? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     |   on_dragstart? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     |   on_dragend? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     |   on_dragleave? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     |   on_dragenter? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     |   on_dragover? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     |   on_drop? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     | ) -> @react.Element {
2133 |   common_node(
     |   ^^^^^^^^^^^^ 	<-- UNCOVERED
     |     "h3",
2135 |     match props {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Some(p) => p
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn h4(
     |   children : Array[&@react.ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : @react.ReactRef[@dom.HTMLHeadingElement],
     |   key? : String,
     |   // event handlers
     |   on_click? : @react.MouseEventHandler[@dom.HTMLHeadingElement],
     |   on_change? : @react.ChangeEventHandler[@dom.HTMLHeadingElement],
     |   on_keydown? : @react.KeyboardEventHandler[@dom.HTMLHeadingElement],
     |   on_keyup? : @react.KeyboardEventHandler[@dom.HTMLHeadingElement],
     |   on_focus? : @react.FocusEventHandler[@dom.HTMLHeadingElement],
     |   on_blur? : @react.FocusEventHandler[@dom.HTMLHeadingElement],
     |   on_drag? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     |   on_dragstart? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     |   on_dragend? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     |   on_dragleave? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     |   on_dragenter? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     |   on_dragover? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     |   on_drop? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     | ) -> @react.Element {
     |   common_node(
     |     "h4",
     |     match props {
2193 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn h5(
     |   children : Array[&@react.ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : @react.ReactRef[@dom.HTMLHeadingElement],
     |   key? : String,
     |   // event handlers
     |   on_click? : @react.MouseEventHandler[@dom.HTMLHeadingElement],
     |   on_change? : @react.ChangeEventHandler[@dom.HTMLHeadingElement],
     |   on_keydown? : @react.KeyboardEventHandler[@dom.HTMLHeadingElement],
     |   on_keyup? : @react.KeyboardEventHandler[@dom.HTMLHeadingElement],
     |   on_focus? : @react.FocusEventHandler[@dom.HTMLHeadingElement],
     |   on_blur? : @react.FocusEventHandler[@dom.HTMLHeadingElement],
     |   on_drag? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     |   on_dragstart? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     |   on_dragend? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     |   on_dragleave? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     |   on_dragenter? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     |   on_dragover? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     |   on_drop? : @react.DragEventHandler[@dom.HTMLHeadingElement],
     | ) -> @react.Element {
     |   common_node(
     |     "h5",
     |     match props {
2250 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn button(
     |   children : Array[&@react.ReactNode],
     |   type_? : String,
     |   disabled? : Bool,
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     |   ref_? : @react.ReactRef[@dom.HTMLButtonElement],
     |   key? : String,
     |   on_click? : @react.MouseEventHandler[@dom.HTMLButtonElement],
     |   on_change? : @react.ChangeEventHandler[@dom.HTMLButtonElement],
     |   on_keydown? : @react.KeyboardEventHandler[@dom.HTMLButtonElement],
     |   on_keyup? : @react.KeyboardEventHandler[@dom.HTMLButtonElement],
     |   on_focus? : @react.FocusEventHandler[@dom.HTMLButtonElement],
     |   on_blur? : @react.FocusEventHandler[@dom.HTMLButtonElement],
     |   on_drag? : @react.DragEventHandler[@dom.HTMLButtonElement],
     |   on_dragstart? : @react.DragEventHandler[@dom.HTMLButtonElement],
     |   on_dragend? : @react.DragEventHandler[@dom.HTMLButtonElement],
     |   on_dragleave? : @react.DragEventHandler[@dom.HTMLButtonElement],
     |   on_dragenter? : @react.DragEventHandler[@dom.HTMLButtonElement],
     |   on_dragover? : @react.DragEventHandler[@dom.HTMLButtonElement],
     |   on_drop? : @react.DragEventHandler[@dom.HTMLButtonElement],
     | ) -> @react.Element {
     |   let custom_props : @js.Object = match props {
2303 |     Some(p) => @js.Object::assign(@js.Object::new(), p).cast()
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => @js.Object::new()
     |   }
     |   if type_ is Some(t) {
     |     custom_props.set("type", t)
     |   }
     |   if disabled is Some(d) {
     |     custom_props.set("disabled", d)
     |   }
     |   common_node(
     |     "button",
     |     custom_props,
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

61 uncovered line(s) in src/npm/react_element/svg.mbt:

    | pub fn svg(
    |   // common props
    |   children : Array[&@react.ReactNode],
    |   width~ : Double,
    |   height~ : Double,
    |   view_box? : String,
    |   // shared
    |   props? : @js.Object,
    |   id? : String,
    |   class? : String,
    |   style? : Map[String, String],
    |   tab_index? : Int,
    |   // react
    |   ref_? : @react.ReactRef[@dom.Element],
    |   key? : String,
    |   // event handlers
    |   on_click? : @react.MouseEventHandler[@dom.Element],
    |   on_change? : @react.ChangeEventHandler[@dom.Element],
    |   on_keydown? : @react.KeyboardEventHandler[@dom.Element],
    |   on_keyup? : @react.KeyboardEventHandler[@dom.Element],
    |   on_focus? : @react.FocusEventHandler[@dom.Element],
    |   on_blur? : @react.FocusEventHandler[@dom.Element],
    |   on_drag? : @react.DragEventHandler[@dom.Element],
    |   on_dragstart? : @react.DragEventHandler[@dom.Element],
    |   on_dragend? : @react.DragEventHandler[@dom.Element],
    |   on_dragleave? : @react.DragEventHandler[@dom.Element],
    |   on_dragenter? : @react.DragEventHandler[@dom.Element],
    |   on_dragover? : @react.DragEventHandler[@dom.Element],
    |   on_drop? : @react.DragEventHandler[@dom.Element],
    | ) -> @react.Element {
    |   // Optimize: avoid Object.assign when props is provided but reuse if empty
    |   let attrs : @js.Object = match props {
    |     Some(p) =>
 35 |       if @js.Object::keys(p).length() > 0 {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         @js.Object::assign(@js.Object::new(), p) |> @js.identity
    |       } else {
 38 |         p
    |         ^ 	<-- UNCOVERED
    |       }
    |     None => @js.Object::new()
    |   }
    |   attrs.set("width", width)
    |   attrs.set("height", height)
    |   if view_box is Some(view_box) {
 45 |     attrs.set("viewBox", view_box)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   common_node(
    |     "svg",
    |     attrs,
    |     id~,
    |     class~,
    |     style~,
    |     tab_index~,
    |     ref_~,
    |     key~,
    |     on_click~,
    |     on_change~,
    |     on_keydown~,
    |     on_keyup~,
    |     on_focus~,
    |     on_blur~,
    |     on_drag~,
    |     on_dragend~,
    |     on_dragenter~,
    |     on_dragleave~,
    |     on_dragover~,
    |     on_dragstart~,
    |     on_drop~,
    |     children~,
    |   )
    | }
    …

    | pub fn circle(
    |   // common props
    |   cx~ : Double,
    |   cy~ : Double,
    |   r~ : Double,
    |   stroke? : String,
    |   stroke_width? : Double,
    |   fill? : String,
    | 
    |   // shared
    |   props? : @js.Object,
    |   id? : String,
    |   class? : String,
    |   style? : Map[String, String],
    |   tab_index? : Int,
    |   // react
    |   ref_? : @react.ReactRef[@dom.Element],
    |   key? : String,
    |   // event handlers
    |   on_click? : @react.MouseEventHandler[@dom.Element],
    |   on_drag? : @react.DragEventHandler[@dom.Element],
    |   on_dragstart? : @react.DragEventHandler[@dom.Element],
    |   on_dragend? : @react.DragEventHandler[@dom.Element],
    |   on_dragleave? : @react.DragEventHandler[@dom.Element],
    |   on_dragenter? : @react.DragEventHandler[@dom.Element],
    |   on_dragover? : @react.DragEventHandler[@dom.Element],
    |   on_drop? : @react.DragEventHandler[@dom.Element],
    | ) -> @react.Element {
    |   let attrs : @js.Object = match props {
    |     Some(p) =>
104 |       if @js.Object::keys(p).length() > 0 {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         @js.Object::assign(@js.Object::new(), p) |> @js.identity
    |       } else {
107 |         p
    |         ^ 	<-- UNCOVERED
    |       }
    |     None => @js.Object::new()
    |   }
    |   attrs.set("cx", cx)
    |   attrs.set("cy", cy)
    |   attrs.set("r", r)
    |   if stroke is Some(stroke) {
115 |     attrs.set("stroke", stroke)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if stroke_width is Some(stroke_width) {
118 |     attrs.set("strokeWidth", stroke_width)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if fill is Some(fill) {
    |     attrs.set("fill", fill)
    |   }
    |   common_node(
    |     "circle",
    |     attrs,
    |     id~,
    |     class~,
    |     style~,
    |     tab_index~,
    |     ref_~,
    |     key~,
    |     on_click~,
    |     on_change=None,
    |     on_keydown=None,
    |     on_keyup=None,
    |     on_focus=None,
    |     on_blur=None,
    |     on_drag~,
    |     on_dragend~,
    |     on_dragenter~,
    |     on_dragleave~,
    |     on_dragover~,
    |     on_dragstart~,
    |     on_drop~,
    |     children=[],
    |   )
    | }
    …

    | pub fn ellipse(
    |   // common props
    |   cx~ : Double,
    |   cy~ : Double,
    |   rx~ : Double,
    |   ry~ : Double,
    |   stroke? : String,
    |   stroke_width? : Double,
    |   fill? : String,
    | 
    |   // shared
    |   props? : @js.Object,
    |   id? : String,
    |   class? : String,
    |   style? : Map[String, String],
    |   tab_index? : Int,
    |   // react
    |   ref_? : @react.ReactRef[@dom.Element],
    |   key? : String,
    |   // event handlers
    |   on_click? : @react.MouseEventHandler[@dom.Element],
    |   on_change? : @react.ChangeEventHandler[@dom.Element],
    |   on_keydown? : @react.KeyboardEventHandler[@dom.Element],
    |   on_keyup? : @react.KeyboardEventHandler[@dom.Element],
    |   on_focus? : @react.FocusEventHandler[@dom.Element],
    |   on_blur? : @react.FocusEventHandler[@dom.Element],
    |   on_drag? : @react.DragEventHandler[@dom.Element],
    |   on_dragstart? : @react.DragEventHandler[@dom.Element],
    |   on_dragend? : @react.DragEventHandler[@dom.Element],
    |   on_dragleave? : @react.DragEventHandler[@dom.Element],
    |   on_dragenter? : @react.DragEventHandler[@dom.Element],
    |   on_dragover? : @react.DragEventHandler[@dom.Element],
    |   on_drop? : @react.DragEventHandler[@dom.Element],
    | ) -> @react.Element {
    |   let attrs : @js.Object = match props {
    |     Some(p) =>
186 |       if @js.Object::keys(p).length() > 0 {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         @js.Object::assign(@js.Object::new(), p) |> @js.identity
    |       } else {
189 |         p
    |         ^ 	<-- UNCOVERED
    |       }
    |     None => @js.Object::new()
    |   }
    |   attrs.set("cx", cx)
    |   attrs.set("cy", cy)
    |   attrs.set("rx", rx)
    |   attrs.set("ry", ry)
    |   if stroke is Some(stroke) {
198 |     attrs.set("stroke", stroke)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if stroke_width is Some(stroke_width) {
201 |     attrs.set("strokeWidth", stroke_width)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if fill is Some(fill) {
    |     attrs.set("fill", fill)
    |   }
    |   common_node(
    |     "circle",
    |     attrs,
    |     id~,
    |     class~,
    |     style~,
    |     tab_index~,
    |     ref_~,
    |     key~,
    |     on_click~,
    |     on_change~,
    |     on_keydown~,
    |     on_keyup~,
    |     on_focus~,
    |     on_blur~,
    |     on_drag~,
    |     on_dragend~,
    |     on_dragenter~,
    |     on_dragleave~,
    |     on_dragover~,
    |     on_dragstart~,
    |     on_drop~,
    |     children=[],
    |   )
    | }
    …

    | pub fn rect(
    |   // common props
    |   x~ : Double,
    |   y~ : Double,
    |   width~ : Double,
    |   height~ : Double,
    |   stroke? : String,
    |   stroke_width? : Double,
    |   fill? : String,
    | 
    |   // shared
    |   props? : @js.Object,
    |   id? : String,
    |   class? : String,
    |   style? : Map[String, String],
    |   tab_index? : Int,
    |   // react
    |   ref_? : @react.ReactRef[@dom.Element],
    |   key? : String,
    |   // event handlers
    |   on_click? : @react.MouseEventHandler[@dom.Element],
    |   on_change? : @react.ChangeEventHandler[@dom.Element],
    |   on_keydown? : @react.KeyboardEventHandler[@dom.Element],
    |   on_keyup? : @react.KeyboardEventHandler[@dom.Element],
    |   on_focus? : @react.FocusEventHandler[@dom.Element],
    |   on_blur? : @react.FocusEventHandler[@dom.Element],
    |   on_drag? : @react.DragEventHandler[@dom.Element],
    |   on_dragstart? : @react.DragEventHandler[@dom.Element],
    |   on_dragend? : @react.DragEventHandler[@dom.Element],
    |   on_dragleave? : @react.DragEventHandler[@dom.Element],
    |   on_dragenter? : @react.DragEventHandler[@dom.Element],
    |   on_dragover? : @react.DragEventHandler[@dom.Element],
    |   on_drop? : @react.DragEventHandler[@dom.Element],
    | ) -> @react.Element {
    |   let attrs : @js.Object = match props {
    |     Some(p) =>
269 |       if @js.Object::keys(p).length() > 0 {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         @js.Object::assign(@js.Object::new(), p) |> @js.identity
    |       } else {
272 |         p
    |         ^ 	<-- UNCOVERED
    |       }
    |     None => @js.Object::new()
    |   }
    |   attrs.set("x", x)
    |   attrs.set("y", y)
    |   attrs.set("width", width)
    |   attrs.set("height", height)
    |   if stroke is Some(stroke) {
281 |     attrs.set("stroke", stroke)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if stroke_width is Some(stroke_width) {
284 |     attrs.set("strokeWidth", stroke_width)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if fill is Some(fill) {
    |     attrs.set("fill", fill)
    |   }
    |   common_node(
    |     "rect",
    |     attrs,
    |     id~,
    |     class~,
    |     style~,
    |     tab_index~,
    |     ref_~,
    |     key~,
    |     on_click~,
    |     on_change~,
    |     on_keydown~,
    |     on_keyup~,
    |     on_focus~,
    |     on_blur~,
    |     on_drag~,
    |     on_dragend~,
    |     on_dragenter~,
    |     on_dragleave~,
    |     on_dragover~,
    |     on_dragstart~,
    |     on_drop~,
    |     children=[],
    |   )
    | }
    …

    | pub fn line(
    |   // common props
    |   x1~ : Double,
    |   y1~ : Double,
    |   x2~ : Double,
    |   y2~ : Double,
    |   stroke? : String,
    |   stroke_width? : Double,
    |   fill? : String,
    | 
    |   // shared
    |   props? : @js.Object,
    |   id? : String,
    |   class? : String,
    |   style? : Map[String, String],
    |   tab_index? : Int,
    |   // react
    |   ref_? : @react.ReactRef[@dom.Element],
    |   key? : String,
    |   // event handlers
    |   on_click? : @react.MouseEventHandler[@dom.Element],
    |   on_change? : @react.ChangeEventHandler[@dom.Element],
    |   on_keydown? : @react.KeyboardEventHandler[@dom.Element],
    |   on_keyup? : @react.KeyboardEventHandler[@dom.Element],
    |   on_focus? : @react.FocusEventHandler[@dom.Element],
    |   on_blur? : @react.FocusEventHandler[@dom.Element],
    |   on_drag? : @react.DragEventHandler[@dom.Element],
    |   on_dragstart? : @react.DragEventHandler[@dom.Element],
    |   on_dragend? : @react.DragEventHandler[@dom.Element],
    |   on_dragleave? : @react.DragEventHandler[@dom.Element],
    |   on_dragenter? : @react.DragEventHandler[@dom.Element],
    |   on_dragover? : @react.DragEventHandler[@dom.Element],
    |   on_drop? : @react.DragEventHandler[@dom.Element],
    | ) -> @react.Element {
    |   let attrs : @js.Object = match props {
    |     Some(p) =>
352 |       if @js.Object::keys(p).length() > 0 {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         @js.Object::assign(@js.Object::new(), p) |> @js.identity
    |       } else {
355 |         p
    |         ^ 	<-- UNCOVERED
    |       }
    |     None => @js.Object::new()
    |   }
    |   attrs.set("x1", x1)
    |   attrs.set("y1", y1)
    |   attrs.set("x2", x2)
    |   attrs.set("y2", y2)
    |   if stroke is Some(stroke) {
    |     attrs.set("stroke", stroke)
    |   }
    |   if stroke_width is Some(stroke_width) {
    |     attrs.set("strokeWidth", stroke_width)
    |   }
    |   if fill is Some(fill) {
370 |     attrs.set("fill", fill)
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   common_node(
    |     "line",
    |     attrs,
    |     id~,
    |     class~,
    |     style~,
    |     tab_index~,
    |     ref_~,
    |     key~,
    |     on_click~,
    |     on_change~,
    |     on_keydown~,
    |     on_keyup~,
    |     on_focus~,
    |     on_blur~,
    |     on_drag~,
    |     on_dragend~,
    |     on_dragenter~,
    |     on_dragleave~,
    |     on_dragover~,
    |     on_dragstart~,
    |     on_drop~,
    |     children=[],
    |   )
    | }
    …

    | pub fn path(
    |   // common props
    |   d~ : String,
    |   stroke? : String,
    |   stroke_width? : Double,
    |   fill? : String,
    | 
    |   // shared
    |   props? : @js.Object,
    |   id? : String,
    |   class? : String,
    |   style? : Map[String, String],
    |   tab_index? : Int,
    |   // react
    |   ref_? : @react.ReactRef[@dom.Element],
    |   key? : String,
    |   // event handlers
    |   on_click? : @react.MouseEventHandler[@dom.Element],
    |   on_change? : @react.ChangeEventHandler[@dom.Element],
    |   on_keydown? : @react.KeyboardEventHandler[@dom.Element],
    |   on_keyup? : @react.KeyboardEventHandler[@dom.Element],
    |   on_focus? : @react.FocusEventHandler[@dom.Element],
    |   on_blur? : @react.FocusEventHandler[@dom.Element],
    |   on_drag? : @react.DragEventHandler[@dom.Element],
    |   on_dragstart? : @react.DragEventHandler[@dom.Element],
    |   on_dragend? : @react.DragEventHandler[@dom.Element],
    |   on_dragleave? : @react.DragEventHandler[@dom.Element],
    |   on_dragenter? : @react.DragEventHandler[@dom.Element],
    |   on_dragover? : @react.DragEventHandler[@dom.Element],
    |   on_drop? : @react.DragEventHandler[@dom.Element],
    | ) -> @react.Element {
    |   let attrs : @js.Object = match props {
    |     Some(p) =>
432 |       if @js.Object::keys(p).length() > 0 {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         @js.Object::assign(@js.Object::new(), p) |> @js.identity
    |       } else {
435 |         p
    |         ^ 	<-- UNCOVERED
    |       }
    |     None => @js.Object::new()
    |   }
    |   attrs.set("d", d)
    |   if stroke is Some(stroke) {
    |     attrs.set("stroke", stroke)
    |   }
    |   if stroke_width is Some(stroke_width) {
    |     attrs.set("strokeWidth", stroke_width)
    |   }
    |   if fill is Some(fill) {
447 |     attrs.set("fill", fill)
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   common_node(
    |     "path",
    |     attrs,
    |     id~,
    |     class~,
    |     style~,
    |     tab_index~,
    |     ref_~,
    |     key~,
    |     on_click~,
    |     on_change~,
    |     on_keydown~,
    |     on_keyup~,
    |     on_focus~,
    |     on_blur~,
    |     on_drag~,
    |     on_dragend~,
    |     on_dragenter~,
    |     on_dragleave~,
    |     on_dragover~,
    |     on_dragstart~,
    |     on_drop~,
    |     children=[],
    |   )
    | }
    …

    | pub fn use_(
    |   // common props
    |   href~ : String,
    | 
    |   // shared
    |   props? : @js.Object,
    |   id? : String,
    |   class? : String,
    |   style? : Map[String, String],
    |   tab_index? : Int,
    |   // react
    |   ref_? : @react.ReactRef[@dom.Element],
    |   key? : String,
    |   // event handlers
    |   on_click? : @react.MouseEventHandler[@dom.Element],
    |   on_change? : @react.ChangeEventHandler[@dom.Element],
    |   on_keydown? : @react.KeyboardEventHandler[@dom.Element],
    |   on_keyup? : @react.KeyboardEventHandler[@dom.Element],
    |   on_focus? : @react.FocusEventHandler[@dom.Element],
    |   on_blur? : @react.FocusEventHandler[@dom.Element],
    |   on_drag? : @react.DragEventHandler[@dom.Element],
    |   on_dragstart? : @react.DragEventHandler[@dom.Element],
    |   on_dragend? : @react.DragEventHandler[@dom.Element],
    |   on_dragleave? : @react.DragEventHandler[@dom.Element],
    |   on_dragenter? : @react.DragEventHandler[@dom.Element],
    |   on_dragover? : @react.DragEventHandler[@dom.Element],
    |   on_drop? : @react.DragEventHandler[@dom.Element],
    | ) -> @react.Element {
504 |   let attrs : @js.Object = match props {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(p) =>
506 |       if @js.Object::keys(p).length() > 0 {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         @js.Object::assign(@js.Object::new(), p) |> @js.identity
    |       } else {
509 |         p
    |         ^ 	<-- UNCOVERED
    |       }
511 |     None => @js.Object::new()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
513 |   attrs.set("href", href)
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   common_node(
    |     "use",
    |     attrs,
    |     id~,
    |     class~,
    |     style~,
    |     tab_index~,
    |     ref_~,
    |     key~,
    |     on_click~,
    |     on_change~,
    |     on_keydown~,
    |     on_keyup~,
    |     on_focus~,
    |     on_blur~,
    |     on_drag~,
    |     on_dragend~,
    |     on_dragenter~,
    |     on_dragleave~,
    |     on_dragover~,
    |     on_dragstart~,
    |     on_drop~,
    |     children=[],
    |   )
    | }
    …

    | pub fn polygon(
    |   // common props
    |   points~ : Array[(Double, Double)],
    |   stroke? : String,
    |   stroke_width? : Double,
    |   fill? : String,
    | 
    |   // shared
    |   props? : @js.Object,
    |   id? : String,
    |   class? : String,
    |   style? : Map[String, String],
    |   tab_index? : Int,
    |   // react
    |   ref_? : @react.ReactRef[@dom.Element],
    |   key? : String,
    |   // event handlers
    |   on_click? : @react.MouseEventHandler[@dom.Element],
    |   on_change? : @react.ChangeEventHandler[@dom.Element],
    |   on_keydown? : @react.KeyboardEventHandler[@dom.Element],
    |   on_keyup? : @react.KeyboardEventHandler[@dom.Element],
    |   on_focus? : @react.FocusEventHandler[@dom.Element],
    |   on_blur? : @react.FocusEventHandler[@dom.Element],
    |   on_drag? : @react.DragEventHandler[@dom.Element],
    |   on_dragstart? : @react.DragEventHandler[@dom.Element],
    |   on_dragend? : @react.DragEventHandler[@dom.Element],
    |   on_dragleave? : @react.DragEventHandler[@dom.Element],
    |   on_dragenter? : @react.DragEventHandler[@dom.Element],
    |   on_dragover? : @react.DragEventHandler[@dom.Element],
    |   on_drop? : @react.DragEventHandler[@dom.Element],
    | ) -> @react.Element {
572 |   let attrs : @js.Object = match props {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(p) =>
574 |       if @js.Object::keys(p).length() > 0 {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         @js.Object::assign(@js.Object::new(), p) |> @js.identity
    |       } else {
577 |         p
    |         ^ 	<-- UNCOVERED
    |       }
579 |     None => @js.Object::new()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
581 |   attrs.set("points", points |> @js.identity)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   if stroke is Some(stroke) {
583 |     attrs.set("stroke", stroke)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if stroke_width is Some(stroke_width) {
586 |     attrs.set("strokeWidth", stroke_width)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if fill is Some(fill) {
589 |     attrs.set("fill", fill)
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
591 |   common_node(
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     "points",
    |     attrs,
    |     id~,
    |     class~,
    |     style~,
    |     tab_index~,
    |     ref_~,
    |     key~,
    |     on_click~,
    |     on_change~,
    |     on_keydown~,
    |     on_keyup~,
    |     on_focus~,
    |     on_blur~,
    |     on_drag~,
    |     on_dragend~,
    |     on_dragenter~,
    |     on_dragleave~,
    |     on_dragover~,
    |     on_dragstart~,
    |     on_drop~,
    |     children=[],
    |   )
    | }
    …

    | pub fn polyline(
    |   // common props
    |   points~ : Array[(Double, Double)],
    |   stroke? : String,
    |   stroke_width? : Double,
    |   fill? : String,
    | 
    |   // shared
    |   props? : @js.Object,
    |   id? : String,
    |   class? : String,
    |   style? : Map[String, String],
    |   tab_index? : Int,
    |   // react
    |   ref_? : @react.ReactRef[@dom.Element],
    |   key? : String,
    |   // event handlers
    |   on_click? : @react.MouseEventHandler[@dom.Element],
    |   on_change? : @react.ChangeEventHandler[@dom.Element],
    |   on_keydown? : @react.KeyboardEventHandler[@dom.Element],
    |   on_keyup? : @react.KeyboardEventHandler[@dom.Element],
    |   on_focus? : @react.FocusEventHandler[@dom.Element],
    |   on_blur? : @react.FocusEventHandler[@dom.Element],
    |   on_drag? : @react.DragEventHandler[@dom.Element],
    |   on_dragstart? : @react.DragEventHandler[@dom.Element],
    |   on_dragend? : @react.DragEventHandler[@dom.Element],
    |   on_dragleave? : @react.DragEventHandler[@dom.Element],
    |   on_dragenter? : @react.DragEventHandler[@dom.Element],
    |   on_dragover? : @react.DragEventHandler[@dom.Element],
    |   on_drop? : @react.DragEventHandler[@dom.Element],
    | ) -> @react.Element {
649 |   let attrs : @js.Object = match props {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(p) =>
651 |       if @js.Object::keys(p).length() > 0 {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         @js.Object::assign(@js.Object::new(), p) |> @js.identity
    |       } else {
654 |         p
    |         ^ 	<-- UNCOVERED
    |       }
656 |     None => @js.Object::new()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
658 |   attrs.set("points", points |> @js.identity)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   if stroke is Some(stroke) {
660 |     attrs.set("stroke", stroke)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if stroke_width is Some(stroke_width) {
663 |     attrs.set("strokeWidth", stroke_width)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if fill is Some(fill) {
666 |     attrs.set("fill", fill)
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
668 |   common_node(
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     "polyline",
    |     attrs,
    |     id~,
    |     class~,
    |     style~,
    |     tab_index~,
    |     ref_~,
    |     key~,
    |     on_click~,
    |     on_change~,
    |     on_keydown~,
    |     on_keyup~,
    |     on_focus~,
    |     on_blur~,
    |     on_drag~,
    |     on_dragend~,
    |     on_dragenter~,
    |     on_dragleave~,
    |     on_dragover~,
    |     on_dragstart~,
    |     on_drop~,
    |     children=[],
    |   )
    | }
    …

    | pub fn g(
    |   children : Array[&@react.ReactNode],
    |   // common props
    |   stroke? : String,
    |   stroke_width? : Double,
    |   fill? : String,
    | 
    |   // shared
    |   props? : @js.Object,
    |   id? : String,
    |   class? : String,
    |   style? : Map[String, String],
    |   tab_index? : Int,
    |   // react
    |   ref_? : @react.ReactRef[@dom.Element],
    |   key? : String,
    |   // event handlers
    |   on_click? : @react.MouseEventHandler[@dom.Element],
    |   on_change? : @react.ChangeEventHandler[@dom.Element],
    |   on_keydown? : @react.KeyboardEventHandler[@dom.Element],
    |   on_keyup? : @react.KeyboardEventHandler[@dom.Element],
    |   on_focus? : @react.FocusEventHandler[@dom.Element],
    |   on_blur? : @react.FocusEventHandler[@dom.Element],
    |   on_drag? : @react.DragEventHandler[@dom.Element],
    |   on_dragstart? : @react.DragEventHandler[@dom.Element],
    |   on_dragend? : @react.DragEventHandler[@dom.Element],
    |   on_dragleave? : @react.DragEventHandler[@dom.Element],
    |   on_dragenter? : @react.DragEventHandler[@dom.Element],
    |   on_dragover? : @react.DragEventHandler[@dom.Element],
    |   on_drop? : @react.DragEventHandler[@dom.Element],
    | ) -> @react.Element {
    |   let attrs : @js.Object = match props {
    |     Some(p) =>
728 |       if @js.Object::keys(p).length() > 0 {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         @js.Object::assign(@js.Object::new(), p) |> @js.identity
    |       } else {
731 |         p
    |         ^ 	<-- UNCOVERED
    |       }
    |     None => @js.Object::new()
    |   }
    |   if stroke is Some(stroke) {
    |     attrs.set("stroke", stroke)
    |   }
    |   if stroke_width is Some(stroke_width) {
739 |     attrs.set("strokeWidth", stroke_width)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if fill is Some(fill) {
742 |     attrs.set("fill", fill)
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   common_node(
    |     "g",
    |     attrs,
    |     id~,
    |     class~,
    |     style~,
    |     tab_index~,
    |     ref_~,
    |     key~,
    |     on_click~,
    |     on_change~,
    |     on_keydown~,
    |     on_keyup~,
    |     on_focus~,
    |     on_blur~,
    |     on_drag~,
    |     on_dragend~,
    |     on_dragenter~,
    |     on_dragleave~,
    |     on_dragover~,
    |     on_dragstart~,
    |     on_drop~,
    |     children~,
    |   )
    | }
    …

    | pub fn defs(
    |   children : Array[&@react.ReactNode],
    |   // shared
    |   props? : @js.Object,
    |   id? : String,
    |   class? : String,
    |   style? : Map[String, String],
    |   tab_index? : Int,
    |   // react
    |   ref_? : @react.ReactRef[@dom.Element],
    |   key? : String,
    |   // event handlers
    |   on_click? : @react.MouseEventHandler[@dom.Element],
    |   on_change? : @react.ChangeEventHandler[@dom.Element],
    |   on_keydown? : @react.KeyboardEventHandler[@dom.Element],
    |   on_keyup? : @react.KeyboardEventHandler[@dom.Element],
    |   on_focus? : @react.FocusEventHandler[@dom.Element],
    |   on_blur? : @react.FocusEventHandler[@dom.Element],
    |   on_drag? : @react.DragEventHandler[@dom.Element],
    |   on_dragstart? : @react.DragEventHandler[@dom.Element],
    |   on_dragend? : @react.DragEventHandler[@dom.Element],
    |   on_dragleave? : @react.DragEventHandler[@dom.Element],
    |   on_dragenter? : @react.DragEventHandler[@dom.Element],
    |   on_dragover? : @react.DragEventHandler[@dom.Element],
    |   on_drop? : @react.DragEventHandler[@dom.Element],
    | ) -> @react.Element {
    |   let attrs : @js.Object = match props {
    |     Some(p) =>
799 |       if @js.Object::keys(p).length() > 0 {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         @js.Object::assign(@js.Object::new(), p) |> @js.identity
    |       } else {
802 |         p
    |         ^ 	<-- UNCOVERED
    |       }
    |     None => @js.Object::new()
    |   }
    |   common_node(
    |     "defs",
    |     attrs,
    |     id~,
    |     class~,
    |     style~,
    |     tab_index~,
    |     ref_~,
    |     key~,
    |     on_click~,
    |     on_change~,
    |     on_keydown~,
    |     on_keyup~,
    |     on_focus~,
    |     on_blur~,
    |     on_drag~,
    |     on_dragend~,
    |     on_dragenter~,
    |     on_dragleave~,
    |     on_dragover~,
    |     on_dragstart~,
    |     on_drop~,
    |     children~,
    |   )
    | }
    …

    | pub fn text(
    |   children : Array[&@react.ReactNode],
    |   // common props
    |   x~ : Double,
    |   y~ : Double,
    |   dx? : String,
    |   dy? : String,
    |   length_adjust? : String,
    |   text_length? : String,
    |   rotate? : String,
    |   stroke? : String,
    |   stroke_width? : Double,
    |   fill? : String,
    | 
    |   // shared
    |   props? : @js.Object,
    |   id? : String,
    |   class? : String,
    |   style? : Map[String, String],
    |   tab_index? : Int,
    |   // react
    |   ref_? : @react.ReactRef[@dom.Element],
    |   key? : String,
    |   // event handlers
    |   on_click? : @react.MouseEventHandler[@dom.Element],
    |   on_change? : @react.ChangeEventHandler[@dom.Element],
    |   on_keydown? : @react.KeyboardEventHandler[@dom.Element],
    |   on_keyup? : @react.KeyboardEventHandler[@dom.Element],
    |   on_focus? : @react.FocusEventHandler[@dom.Element],
    |   on_blur? : @react.FocusEventHandler[@dom.Element],
    |   on_drag? : @react.DragEventHandler[@dom.Element],
    |   on_dragstart? : @react.DragEventHandler[@dom.Element],
    |   on_dragend? : @react.DragEventHandler[@dom.Element],
    |   on_dragleave? : @react.DragEventHandler[@dom.Element],
    |   on_dragenter? : @react.DragEventHandler[@dom.Element],
    |   on_dragover? : @react.DragEventHandler[@dom.Element],
    |   on_drop? : @react.DragEventHandler[@dom.Element],
    | ) -> @react.Element {
    |   let attrs : @js.Object = match props {
    |     Some(p) =>
873 |       if @js.Object::keys(p).length() > 0 {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         @js.Object::assign(@js.Object::new(), p) |> @js.identity
    |       } else {
876 |         p
    |         ^ 	<-- UNCOVERED
    |       }
    |     None => @js.Object::new()
    |   }
    |   attrs.set("x", x)
    |   attrs.set("y", y)
    |   if dx is Some(dx) {
883 |     attrs.set("dx", dx)
    |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if dy is Some(dy) {
886 |     attrs.set("dy", dy)
    |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if length_adjust is Some(length_adjust) {
889 |     attrs.set("lengthAdjust", length_adjust)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if text_length is Some(text_length) {
892 |     attrs.set("textLength", text_length)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if stroke is Some(stroke) {
895 |     attrs.set("stroke", stroke)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if stroke_width is Some(stroke_width) {
898 |     attrs.set("strokeWidth", stroke_width)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if fill is Some(fill) {
    |     attrs.set("fill", fill)
    |   }
    |   if rotate is Some(rotate) {
904 |     attrs.set("rotate", rotate)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   common_node(
    |     "text",
    |     attrs,
    |     id~,
    |     class~,
    |     style~,
    |     tab_index~,
    |     ref_~,
    |     key~,
    |     on_click~,
    |     on_change~,
    |     on_keydown~,
    |     on_keyup~,
    |     on_focus~,
    |     on_blur~,
    |     on_drag~,
    |     on_dragend~,
    |     on_dragenter~,
    |     on_dragleave~,
    |     on_dragover~,
    |     on_dragstart~,
    |     on_drop~,
    |     children~,
    |   )
    | }
    …

    | pub fn image(
    |   x~ : Double,
    |   y~ : Double,
    |   href~ : String,
    |   // shared
    |   props? : @js.Object,
    |   id? : String,
    |   class? : String,
    |   style? : Map[String, String],
    |   tab_index? : Int,
    |   // react
    |   ref_? : @react.ReactRef[@dom.Element],
    |   key? : String,
    |   // event handlers
    |   on_click? : @react.MouseEventHandler[@dom.Element],
    |   on_change? : @react.ChangeEventHandler[@dom.Element],
    |   on_keydown? : @react.KeyboardEventHandler[@dom.Element],
    |   on_keyup? : @react.KeyboardEventHandler[@dom.Element],
    |   on_focus? : @react.FocusEventHandler[@dom.Element],
    |   on_blur? : @react.FocusEventHandler[@dom.Element],
    |   on_drag? : @react.DragEventHandler[@dom.Element],
    |   on_dragstart? : @react.DragEventHandler[@dom.Element],
    |   on_dragend? : @react.DragEventHandler[@dom.Element],
    |   on_dragleave? : @react.DragEventHandler[@dom.Element],
    |   on_dragenter? : @react.DragEventHandler[@dom.Element],
    |   on_dragover? : @react.DragEventHandler[@dom.Element],
    |   on_drop? : @react.DragEventHandler[@dom.Element],
    | ) -> @react.Element {
    |   let attrs : @js.Object = match props {
    |     Some(p) =>
963 |       if @js.Object::keys(p).length() > 0 {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         @js.Object::assign(@js.Object::new(), p) |> @js.identity
    |       } else {
966 |         p
    |         ^ 	<-- UNCOVERED
    |       }
    |     None => @js.Object::new()
    |   }
    |   attrs.set("x", x)
    |   attrs.set("y", y)
    |   attrs.set("href", href)
    |   common_node(
    |     "image",
    |     attrs,
    |     id~,
    |     class~,
    |     style~,
    |     tab_index~,
    |     ref_~,
    |     key~,
    |     on_click~,
    |     on_change~,
    |     on_keydown~,
    |     on_keyup~,
    |     on_focus~,
    |     on_blur~,
    |     on_drag~,
    |     on_dragend~,
    |     on_dragenter~,
    |     on_dragleave~,
    |     on_dragover~,
    |     on_dragstart~,
    |     on_drop~,
    |     children=[],
    |   )
    | }
    …

7 uncovered line(s) in src/npm/react_router/react_router.mbt:

    | pub async fn dynamic_import_async() -> Unit {
 15 |   if @js.is_undefined(@js.globalThis().get("__ReactRouterApi")) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let v = import_react_router().wait()
    |     @js.globalThis().set("__ReactRouterApi", v)
    |   }
    | }
    …

    | pub async fn init_react_router_async() -> Unit {
 24 |   dynamic_import_async()
    |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(router_provider)
    | pub fn routerProvider(router : Router) -> @react.Element {
 43 |   let p = get_router_provider()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @react.component(p, RouterProviderProps::{ router, })
    | }
    …

    | impl @js.JsImpl for Route with to_any(self) {
 63 |   match self {
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Route::Component(path~, component~) => {
    |       let obj = @js.Object::new()
    |       obj.set("path", path)
    |       obj.set("Component", component |> @js.unsafe_any)
    |       obj.to_any()
    |     }
 70 |     Route::Element(path~, element~) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let obj = @js.Object::new()
    |       obj.set("path", path)
    |       obj.set("element", element |> @js.unsafe_any)
    |       obj.to_any()
    |     }
    |   }
    | }
    …

    | #alias(create_browser_router)
    | pub fn createBrowserRouter(routes : Array[Route]) -> Router {
 82 |   let create_browser_router : (Array[@js.Any]) -> Router = @js.global_this()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     .get("__ReactRouterApi")
    |     .get("createBrowserRouter")
    |     .cast()
    |   create_browser_router(routes.map(_.to_any()))
    | }
    …

    | pub fn link(
    |   to~ : String,
    |   children : Array[&@react.ReactNode],
    | ) -> @react.Element {
103 |   let p = get_link()
    |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @react.c(p, LinkProps::{ to, }, children~)
    | }
    …

49 uncovered line(s) in src/npm/react_testing_library/rtl.mbt:

    | pub fn RenderResult::debug(self : RenderResult) -> Unit {
 46 |   self.call0("debug") |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn RenderResult::asFragment(self : RenderResult) -> @js.Any {
 67 |   self.call0("asFragment")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn act(callback : () -> Unit) -> @js.Any {
 80 |   let rtl = testing_library()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   rtl.call("act", [@js.identity(callback)])
    | }
    …

    | pub fn FireEvent::input(
    |   self : FireEvent,
    |   target : @dom.HTMLElement,
    |   event : @js.Any,
    | ) -> Unit {
166 |   self.call("input", [target, event]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn FireEvent::keyUp(
    |   self : FireEvent,
    |   target : @dom.HTMLElement,
    |   event : @js.Any,
    | ) -> Unit {
204 |   self.call("keyUp", [target, event]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn FireEvent::mouseEnter(
    |   self : FireEvent,
    |   target : @dom.HTMLElement,
    | ) -> Unit {
213 |   self.call("mouseEnter", [target]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn FireEvent::mouseLeave(
    |   self : FireEvent,
    |   target : @dom.HTMLElement,
    | ) -> Unit {
222 |   self.call("mouseLeave", [target]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::debug(self : Self) -> Unit {
243 |   self.call0("debug") |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::getByLabelText(self : Screen, text : String) -> ScreenResult {
264 |   self.call("getByLabelText", [text]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::getByAltText(self : Screen, text : String) -> ScreenResult {
291 |   self.call("getByAltText", [text]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::getByTitle(self : Screen, title : String) -> ScreenResult {
297 |   self.call("getByTitle", [title]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::getByTestId(self : Screen, testId : String) -> ScreenResult {
303 |   self.call("getByTestId", [testId]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::queryByRole(self : Screen, role : String) -> ScreenResult? {
311 |   self.call("queryByRole", [role]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::queryByLabelText(self : Screen, text : String) -> ScreenResult? {
317 |   self.call("queryByLabelText", [text]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::queryByPlaceholderText(
    |   self : Screen,
    |   text : String,
    | ) -> ScreenResult? {
326 |   self.call("queryByPlaceholderText", [text]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::queryByText(self : Screen, text : String) -> ScreenResult? {
332 |   self.call("queryByText", [text]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::queryByDisplayValue(
    |   self : Screen,
    |   value : String,
    | ) -> ScreenResult? {
341 |   self.call("queryByDisplayValue", [value]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::queryByAltText(self : Screen, text : String) -> ScreenResult? {
347 |   self.call("queryByAltText", [text]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::queryByTitle(self : Screen, title : String) -> ScreenResult? {
353 |   self.call("queryByTitle", [title]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::queryByTestId(self : Screen, testId : String) -> ScreenResult? {
359 |   self.call("queryByTestId", [testId]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::findByRole(
    |   self : Screen,
    |   role : String,
    | ) -> @js.Promise[ScreenResult] {
370 |   self.call("findByRole", [role]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::findByLabelText(
    |   self : Screen,
    |   text : String,
    | ) -> @js.Promise[ScreenResult] {
379 |   self.call("findByLabelText", [text]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::findByPlaceholderText(
    |   self : Screen,
    |   text : String,
    | ) -> @js.Promise[ScreenResult] {
388 |   self.call("findByPlaceholderText", [text]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::findByText(
    |   self : Screen,
    |   text : String,
    | ) -> @js.Promise[ScreenResult] {
397 |   self.call("findByText", [text]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::findByDisplayValue(
    |   self : Screen,
    |   value : String,
    | ) -> @js.Promise[ScreenResult] {
406 |   self.call("findByDisplayValue", [value]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::findByAltText(
    |   self : Screen,
    |   text : String,
    | ) -> @js.Promise[ScreenResult] {
415 |   self.call("findByAltText", [text]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::findByTitle(
    |   self : Screen,
    |   title : String,
    | ) -> @js.Promise[ScreenResult] {
424 |   self.call("findByTitle", [title]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::findByTestId(
    |   self : Screen,
    |   testId : String,
    | ) -> @js.Promise[ScreenResult] {
433 |   self.call("findByTestId", [testId]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::getAllByLabelText(self : Screen, text : String) -> ScreenResults {
447 |   self.call("getAllByLabelText", [text]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::getAllByPlaceholderText(
    |   self : Screen,
    |   text : String,
    | ) -> ScreenResults {
456 |   self.call("getAllByPlaceholderText", [text]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::getAllByDisplayValue(
    |   self : Screen,
    |   value : String,
    | ) -> ScreenResults {
471 |   self.call("getAllByDisplayValue", [value]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::getAllByAltText(self : Screen, text : String) -> ScreenResults {
477 |   self.call("getAllByAltText", [text]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::getAllByTitle(self : Screen, title : String) -> ScreenResults {
483 |   self.call("getAllByTitle", [title]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::getAllByTestId(self : Screen, testId : String) -> ScreenResults {
489 |   self.call("getAllByTestId", [testId]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::queryAllByLabelText(
    |   self : Screen,
    |   text : String,
    | ) -> ScreenResults {
506 |   self.call("queryAllByLabelText", [text]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::queryAllByPlaceholderText(
    |   self : Screen,
    |   text : String,
    | ) -> ScreenResults {
515 |   self.call("queryAllByPlaceholderText", [text]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::queryAllByText(self : Screen, text : String) -> ScreenResults {
521 |   self.call("queryAllByText", [text]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::queryAllByDisplayValue(
    |   self : Screen,
    |   value : String,
    | ) -> ScreenResults {
530 |   self.call("queryAllByDisplayValue", [value]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::queryAllByAltText(self : Screen, text : String) -> ScreenResults {
536 |   self.call("queryAllByAltText", [text]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::queryAllByTitle(self : Screen, title : String) -> ScreenResults {
542 |   self.call("queryAllByTitle", [title]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::queryAllByTestId(
    |   self : Screen,
    |   testId : String,
    | ) -> ScreenResults {
551 |   self.call("queryAllByTestId", [testId]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::findAllByRole(
    |   self : Screen,
    |   role : String,
    | ) -> @js.Promise[ScreenResults] {
562 |   self.call("findAllByRole", [role]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::findAllByLabelText(
    |   self : Screen,
    |   text : String,
    | ) -> @js.Promise[ScreenResults] {
571 |   self.call("findAllByLabelText", [text]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::findAllByPlaceholderText(
    |   self : Screen,
    |   text : String,
    | ) -> @js.Promise[ScreenResults] {
580 |   self.call("findAllByPlaceholderText", [text]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::findAllByText(
    |   self : Screen,
    |   text : String,
    | ) -> @js.Promise[ScreenResults] {
589 |   self.call("findAllByText", [text]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::findAllByDisplayValue(
    |   self : Screen,
    |   value : String,
    | ) -> @js.Promise[ScreenResults] {
598 |   self.call("findAllByDisplayValue", [value]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::findAllByAltText(
    |   self : Screen,
    |   text : String,
    | ) -> @js.Promise[ScreenResults] {
607 |   self.call("findAllByAltText", [text]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::findAllByTitle(
    |   self : Screen,
    |   title : String,
    | ) -> @js.Promise[ScreenResults] {
616 |   self.call("findAllByTitle", [title]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Screen::findAllByTestId(
    |   self : Screen,
    |   testId : String,
    | ) -> @js.Promise[ScreenResults] {
625 |   self.call("findAllByTestId", [testId]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

1 uncovered line(s) in src/npm/semver/semver.mbt:

    | pub fn coerce(version : String) -> @js.Any {
    |   let result = semver().call("coerce", [version])
    |   if @js.is_null(result) {
234 |     result
    |     ^^^^^^ 	<-- UNCOVERED
    |   } else {
    |     result.get("version")
    |   }
    | }
    …

5 uncovered line(s) in src/npm/vite/_example/config_example.mbt:

   | pub fn config_example() -> Unit {
 4 |   println("=== defineConfig Example ===")
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | 
   |   // Create configuration using defineConfig with labeled arguments
   |   // This returns a @js.Any object directly
 8 |   let config = @vite.defineConfig(
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     root?=Some("."),
   |     base?=Some("/"),
   |     mode?=Some("development"),
   |     server?=Some(
13 |       @js.from_entries([("port", 3000), ("host", "localhost"), ("open", false)]),
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     ),
   |     build?=Some(
16 |       @js.from_entries([
   |       ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |         ("outDir", "dist"),
   |         ("sourcemap", true),
   |         ("minify", true),
   |       ]),
   |     ),
   |   )
23 |   println("✓ Config created with defineConfig")
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   println("Config: \{config}")
   | }
   …

13 uncovered line(s) in src/npm/vite/_example/main.mbt:

   | fn main {
 4 |   config_example()
   |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   plugin_example()
   |   dev_server_example()
   | }
   …

   | fn dev_server_example() -> Unit {
12 |   @js.run_async(async fn() -> Unit noraise {
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     println("=== Vite Dev Server Example ===")
   | 
   |     // Create and start development server
16 |     println("Creating development server...")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     let server = @vite.createServer(
   |       root?=Some("."),
   |       logLevel?=Some("info"),
   |       clearScreen?=Some(false),
   |     ) catch {
22 |       e => {
   |       ^^^^^^ 	<-- UNCOVERED
   |         println("Failed to create server: \{e}")
   |         return
   |       }
   |     }
27 |     println("✓ Server created")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | 
   |     // Start listening
30 |     let listening = server.listen(port?=Some(5173)) catch {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       e => {
   |         println("Failed to start server: \{e}")
   |         return
   |       }
   |     }
36 |     println("✓ Server listening")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | 
   |     // Print URLs
39 |     listening.printUrls()
   |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | 
   |     // Get resolved URLs
42 |     let urls = listening.resolvedUrls()
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     println("URLs: \{urls}")
   | 
   |     // Wait a bit
46 |     let _ = @js.set_timeout(
   |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       fn() {
48 |         @js.run_async(async fn() -> Unit noraise {
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |           // Close server
50 |           server.close() catch {
   |           ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |             e => println("Failed to close server: \{e}")
   |           }
53 |           println("✓ Server closed")
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |         })
   |       },
   |       3000,
   |     )
   | 
   |   })
   | }
   …

10 uncovered line(s) in src/npm/vite/_example/plugin_example.mbt:

   | pub fn plugin_example() -> Unit {
 4 |   println("=== Vite Plugin Example ===")
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | 
   |   // Create a transform plugin
 7 |   let transform_plugin = @vite.define_plugin(
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     "my-transform-plugin",
   |     enforce?=Some("pre"),
   |     transform?=Some(fn(_code, id) {
11 |       println("Transforming: \{id}")
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       // Return transformed code or None to pass through
   |       if id.contains(".custom") {
14 |         Some("export default 'transformed'")
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       } else {
16 |         None
   |         ^^^^ 	<-- UNCOVERED
   |       }
   |     }),
   |   )
20 |   println("✓ Transform plugin created")
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   let plugin_name = transform_plugin.get("name")
   |   println("Plugin name: \{plugin_name}")
   | 
   |   // Create a build lifecycle plugin
25 |   let _lifecycle_plugin = @vite.define_plugin(
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     "my-lifecycle-plugin",
27 |     buildStart?=Some(fn(_options) { println("✓ Build started") }),
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     buildEnd?=Some(fn(error) {
29 |       match error {
   |       ^^^^^^^^^^^^^ 	<-- UNCOVERED
   |         Some(err) => println("Build failed: \{err}")
   |         None => println("✓ Build completed successfully")
   |       }
   |     }),
   |   )
35 |   println("✓ Lifecycle plugin created")
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

20 uncovered line(s) in src/npm/vite/config.mbt:

    | pub fn defineConfig(
    |   root? : String,
    |   base? : String,
    |   mode? : String,
    |   logLevel? : String,
    |   clearScreen? : Bool,
    |   server? : @js.Any,
    |   build? : @js.Any,
    |   preview? : @js.Any,
    |   optimizeDeps? : @js.Any,
    |   plugins? : @js.Any,
    |   publicDir? : String,
    |   cacheDir? : String,
    |   resolve? : @js.Any,
    |   css? : @js.Any,
    |   json? : @js.Any,
    |   esbuild? : @js.Any,
    |   assetsInclude? : @js.Any,
    |   envDir? : String,
    |   envPrefix? : String,
    | ) -> @js.Any {
 62 |   let obj = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match root {
    |     Some(v) => obj.set("root", @js.any(v))
    |     None => ()
    |   }
 67 |   match base {
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => obj.set("base", @js.any(v))
    |     None => ()
    |   }
 71 |   match mode {
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => obj.set("mode", @js.any(v))
    |     None => ()
    |   }
 75 |   match logLevel {
    |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => obj.set("logLevel", @js.any(v))
    |     None => ()
    |   }
 79 |   match clearScreen {
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => obj.set("clearScreen", @js.any(v))
    |     None => ()
    |   }
 83 |   match server {
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => obj.set("server", v)
    |     None => ()
    |   }
 87 |   match build {
    |   ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => obj.set("build", v)
    |     None => ()
    |   }
 91 |   match preview {
    |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => obj.set("preview", v)
    |     None => ()
    |   }
 95 |   match optimizeDeps {
    |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => obj.set("optimizeDeps", v)
    |     None => ()
    |   }
 99 |   match plugins {
    |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => obj.set("plugins", v)
    |     None => ()
    |   }
103 |   match publicDir {
    |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => obj.set("publicDir", @js.any(v))
    |     None => ()
    |   }
107 |   match cacheDir {
    |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => obj.set("cacheDir", @js.any(v))
    |     None => ()
    |   }
111 |   match resolve {
    |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => obj.set("resolve", v)
    |     None => ()
    |   }
115 |   match css {
    |   ^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => obj.set("css", v)
    |     None => ()
    |   }
119 |   match json {
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => obj.set("json", v)
    |     None => ()
    |   }
123 |   match esbuild {
    |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => obj.set("esbuild", v)
    |     None => ()
    |   }
127 |   match assetsInclude {
    |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => obj.set("assetsInclude", v)
    |     None => ()
    |   }
131 |   match envDir {
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => obj.set("envDir", @js.any(v))
    |     None => ()
    |   }
135 |   match envPrefix {
    |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => obj.set("envPrefix", @js.any(v))
    |     None => ()
    |   }
139 |   ffi_defineConfig(obj.to_any())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

16 uncovered line(s) in src/npm/vite/plugin.mbt:

    | pub fn define_plugin(
    |   name : String,
    |   enforce? : String,
    |   apply? : String,
    |   config? : (@js.Any) -> Unit,
    |   configResolved? : ConfigResolvedHook,
    |   configureServer? : ConfigureServerHook,
    |   configurePreviewServer? : (@js.Any) -> Unit,
    |   transformIndexHtml? : (@js.Any) -> @js.Any,
    |   handleHotUpdate? : (@js.Any) -> Unit,
    |   options? : (@js.Any) -> Unit,
    |   buildStart? : BuildStartHook,
    |   resolveId? : ResolveIdHook,
    |   load? : LoadHook,
    |   transform? : TransformHook,
    |   buildEnd? : BuildEndHook,
    |   closeBundle? : () -> Unit,
    | ) -> Plugin {
 67 |   let plugin = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   plugin.set("name", @js.any(name))
    |   match enforce {
    |     Some(v) => plugin.set("enforce", @js.any(v))
    |     None => ()
    |   }
 73 |   match apply {
    |   ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => plugin.set("apply", @js.any(v))
    |     None => ()
    |   }
 77 |   match config {
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => plugin.set("config", @js.identity(v))
    |     None => ()
    |   }
 81 |   match configResolved {
    |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => plugin.set("configResolved", @js.identity(v))
    |     None => ()
    |   }
 85 |   match configureServer {
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => plugin.set("configureServer", @js.identity(v))
    |     None => ()
    |   }
 89 |   match configurePreviewServer {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => plugin.set("configurePreviewServer", @js.identity(v))
    |     None => ()
    |   }
 93 |   match transformIndexHtml {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => plugin.set("transformIndexHtml", @js.identity(v))
    |     None => ()
    |   }
 97 |   match handleHotUpdate {
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => plugin.set("handleHotUpdate", @js.identity(v))
    |     None => ()
    |   }
101 |   match options {
    |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => plugin.set("options", @js.identity(v))
    |     None => ()
    |   }
105 |   match buildStart {
    |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => plugin.set("buildStart", @js.identity(v))
    |     None => ()
    |   }
109 |   match resolveId {
    |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => plugin.set("resolveId", @js.identity(v))
    |     None => ()
    |   }
113 |   match load {
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => plugin.set("load", @js.identity(v))
    |     None => ()
    |   }
117 |   match transform {
    |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => plugin.set("transform", @js.identity(v))
    |     None => ()
    |   }
121 |   match buildEnd {
    |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => plugin.set("buildEnd", @js.identity(v))
    |     None => ()
    |   }
125 |   match closeBundle {
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => plugin.set("closeBundle", @js.identity(v))
    |     None => ()
    |   }
129 |   plugin.to_any()
    |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

39 uncovered line(s) in src/npm/vite/vite.mbt:

    | pub async fn createServer(
    |   root? : String,
    |   base? : String,
    |   mode? : String,
    |   configFile? : String,
    |   logLevel? : String,
    |   clearScreen? : Bool,
    |   server? : @js.Any,
    | ) -> ViteDevServer {
 82 |   let config = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match root {
    |     Some(v) => config.set("root", @js.any(v))
    |     None => ()
    |   }
 87 |   match base {
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => config.set("base", @js.any(v))
    |     None => ()
    |   }
 91 |   match mode {
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => config.set("mode", @js.any(v))
    |     None => ()
    |   }
 95 |   match configFile {
    |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => config.set("configFile", @js.any(v))
    |     None => ()
    |   }
 99 |   match logLevel {
    |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => config.set("logLevel", @js.any(v))
    |     None => ()
    |   }
103 |   match clearScreen {
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => config.set("clearScreen", @js.any(v))
    |     None => ()
    |   }
107 |   match server {
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => config.set("server", v)
    |     None => ()
    |   }
111 |   let promise : @js.Promise[ViteDevServer] = @js.identity(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ffi_createServer(config.to_any()),
    |   )
114 |   promise.wait()
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn build(
    |   root? : String,
    |   base? : String,
    |   mode? : String,
    |   configFile? : String,
    |   logLevel? : String,
    |   clearScreen? : Bool,
    |   build? : @js.Any,
    | ) -> RollupOutput {
130 |   let config = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match root {
    |     Some(v) => config.set("root", @js.any(v))
    |     None => ()
    |   }
135 |   match base {
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => config.set("base", @js.any(v))
    |     None => ()
    |   }
139 |   match mode {
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => config.set("mode", @js.any(v))
    |     None => ()
    |   }
143 |   match configFile {
    |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => config.set("configFile", @js.any(v))
    |     None => ()
    |   }
147 |   match logLevel {
    |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => config.set("logLevel", @js.any(v))
    |     None => ()
    |   }
151 |   match clearScreen {
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => config.set("clearScreen", @js.any(v))
    |     None => ()
    |   }
155 |   match build {
    |   ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => config.set("build", v)
    |     None => ()
    |   }
159 |   let promise : @js.Promise[RollupOutput] = @js.identity(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ffi_build(config.to_any()),
    |   )
162 |   promise.wait()
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn preview(
    |   root? : String,
    |   base? : String,
    |   mode? : String,
    |   configFile? : String,
    |   logLevel? : String,
    |   clearScreen? : Bool,
    |   preview? : @js.Any,
    | ) -> PreviewServer {
178 |   let config = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match root {
    |     Some(v) => config.set("root", @js.any(v))
    |     None => ()
    |   }
183 |   match base {
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => config.set("base", @js.any(v))
    |     None => ()
    |   }
187 |   match mode {
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => config.set("mode", @js.any(v))
    |     None => ()
    |   }
191 |   match configFile {
    |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => config.set("configFile", @js.any(v))
    |     None => ()
    |   }
195 |   match logLevel {
    |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => config.set("logLevel", @js.any(v))
    |     None => ()
    |   }
199 |   match clearScreen {
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => config.set("clearScreen", @js.any(v))
    |     None => ()
    |   }
203 |   match preview {
    |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => config.set("preview", v)
    |     None => ()
    |   }
207 |   let promise : @js.Promise[PreviewServer] = @js.identity(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ffi_preview(config.to_any()),
    |   )
210 |   promise.wait()
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn ViteDevServer::listen(
    |   self : ViteDevServer,
    |   port? : Int,
    |   host? : String,
    | ) -> ViteDevServer {
223 |   let options = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match port {
    |     Some(v) => options.set("port", @js.any(v))
    |     None => ()
    |   }
228 |   match host {
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(v) => options.set("host", @js.any(v))
    |     None => ()
    |   }
232 |   let promise : @js.Promise[ViteDevServer] = @js.identity(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self.call("listen", [options.to_any()]),
    |   )
235 |   promise.wait()
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub async fn ViteDevServer::close(self : ViteDevServer) -> Unit {
242 |   let promise : @js.Promise[Unit] = @js.identity(self.call("close", []))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   promise.wait()
    | }
    …

    | pub fn ViteDevServer::printUrls(self : ViteDevServer) -> Unit {
250 |   let _ = self.call("printUrls", [])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | 
    | }
    …

    | pub async fn ViteDevServer::restart(
    |   self : ViteDevServer,
    |   forceOptimize? : Bool,
    | ) -> Unit {
261 |   let options = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match forceOptimize {
    |     Some(v) => options.set("forceOptimize", @js.any(v))
    |     None => ()
    |   }
266 |   let promise : @js.Promise[Unit] = @js.identity(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self.call("restart", [options.to_any()]),
    |   )
269 |   promise.wait()
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ViteDevServer::resolvedUrls(self : ViteDevServer) -> @js.Any {
276 |   self.get("resolvedUrls")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn PreviewServer::printUrls(self : PreviewServer) -> Unit {
285 |   let _ = self.call("printUrls", [])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | 
    | }
    …

    | pub fn PreviewServer::resolvedUrls(self : PreviewServer) -> @js.Any {
293 |   self.get("resolvedUrls")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

4 uncovered line(s) in src/web/blob/blob.mbt:

   | pub fn Blob::slice(
   |   self : Self,
   |   start? : Int,
   |   end? : Int,
   |   content_type? : String,
   | ) -> Blob {
   |   let js = self.to_any()
   |   match (start, end, content_type) {
   |     (None, None, None) => js.call0("slice").cast()
   |     (Some(s), None, None) => js.call("slice", [s]).cast()
   |     (Some(s), Some(e), None) => js.call2("slice", s, e).cast()
64 |     (Some(s), Some(e), Some(ct)) => js.call("slice", [s, e, ct]).cast()
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     (None, Some(e), ct) =>
66 |       match ct {
   |       ^^^^^^^^^^ 	<-- UNCOVERED
   |         Some(t) => js.call("slice", [0, e, t]).cast()
   |         None => js.call2("slice", 0, e).cast()
   |       }
70 |     (Some(s), None, Some(ct)) => {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       let size = self.size
72 |       js.call("slice", [s, size, ct]).cast()
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     }
   |     (None, None, Some(ct)) => {
   |       let size = self.size
   |       js.call("slice", [0, size, ct]).cast()
   |     }
   |   }
   | }
   …

9 uncovered line(s) in src/web/console/console.mbt:

    | pub fn log(value : &@js.JsImpl) -> Unit {
  5 |   log_impl(value.to_any())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn warn(value : &@js.JsImpl) -> Unit {
 16 |   warn_impl(value.to_any())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn error(value : &@js.JsImpl) -> Unit {
 27 |   error_impl(value.to_any())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn info(value : &@js.JsImpl) -> Unit {
 38 |   info_impl(value.to_any())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn debug(value : &@js.JsImpl) -> Unit {
 49 |   debug_impl(value.to_any())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn trace(value : &@js.JsImpl) -> Unit {
 59 |   trace_impl(value.to_any())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn dir(value : &@js.JsImpl) -> Unit {
 69 |   dir_impl(value.to_any())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn table(value : &@js.JsImpl, keys : Array[String]) -> Unit {
 79 |   table_impl(value.to_any(), keys)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn assert_(condition : Bool, value : &@js.JsImpl) -> Unit {
 89 |   assert_impl(condition, value.to_any())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

21 uncovered line(s) in src/web/crypto/crypto.mbt:

    | pub fn SubtleCrypto::encrypt(
    |   self : Self,
    |   algorithm : &@js.JsImpl,
    |   key : &@js.JsImpl,
    |   data : &@js.JsImpl,
    | ) -> @js.Promise[@js.Any] {
 18 |   self.call("encrypt", [algorithm, key, data]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SubtleCrypto::decrypt(
    |   self : Self,
    |   algorithm : &@js.JsImpl,
    |   key : &@js.JsImpl,
    |   data : &@js.JsImpl,
    | ) -> @js.Promise[@js.Any] {
 28 |   self.call("decrypt", [algorithm, key, data]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SubtleCrypto::sign(
    |   self : Self,
    |   algorithm : &@js.JsImpl,
    |   key : &@js.JsImpl,
    |   data : &@js.JsImpl,
    | ) -> @js.Promise[@js.Any] {
 39 |   self.call("sign", [algorithm, key, data]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SubtleCrypto::verify(
    |   self : Self,
    |   algorithm : &@js.JsImpl,
    |   key : &@js.JsImpl,
    |   signature : &@js.JsImpl,
    |   data : &@js.JsImpl,
    | ) -> @js.Promise[Bool] {
 50 |   self.call("verify", [algorithm, key, signature, data]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(derive_key)
    | pub fn SubtleCrypto::deriveKey(
    |   self : Self,
    |   algorithm : &@js.JsImpl,
    |   base_key : &@js.JsImpl,
    |   derived_key_type : &@js.JsImpl,
    |   extractable : Bool,
    |   key_usages : Array[String],
    | ) -> @js.Promise[@js.Any] {
 87 |   self
    |   ^^^^ 	<-- UNCOVERED
    |   .call("deriveKey", [
    |     algorithm,
    |     base_key,
    |     derived_key_type,
    |     extractable,
 93 |     key_usages |> @js.from_array,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ])
 95 |   .cast()
    |   ^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(derive_bits)
    | pub fn SubtleCrypto::deriveBits(
    |   self : Self,
    |   algorithm : &@js.JsImpl,
    |   base_key : &@js.JsImpl,
    |   length : Int,
    | ) -> @js.Promise[@js.Any] {
106 |   self.call("deriveBits", [algorithm, base_key, length]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(import_key)
    | pub fn SubtleCrypto::importKey(
    |   self : Self,
    |   format : String,
    |   key_data : &@js.JsImpl,
    |   algorithm : &@js.JsImpl,
    |   extractable : Bool,
    |   key_usages : Array[String],
    | ) -> @js.Promise[@js.Any] {
120 |   self
    |   ^^^^ 	<-- UNCOVERED
    |   .call("importKey", [
    |     format,
    |     key_data,
    |     algorithm,
    |     extractable,
126 |     key_usages |> @js.from_array,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ])
128 |   .cast()
    |   ^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(export_key)
    | pub fn SubtleCrypto::exportKey(
    |   self : Self,
    |   format : String,
    |   key : &@js.JsImpl,
    | ) -> @js.Promise[@js.Any] {
138 |   self.call2("exportKey", format, key).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(wrap_key)
    | pub fn SubtleCrypto::wrapKey(
    |   self : Self,
    |   format : String,
    |   key : &@js.JsImpl,
    |   wrapping_key : &@js.JsImpl,
    |   wrap_algorithm : &@js.JsImpl,
    | ) -> @js.Promise[@js.Any] {
151 |   self.call("wrapKey", [format, key, wrapping_key, wrap_algorithm]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(unwrap_key)
    | pub fn SubtleCrypto::unwrapKey(
    |   self : Self,
    |   format : String,
    |   wrapped_key : &@js.JsImpl,
    |   unwrapping_key : &@js.JsImpl,
    |   unwrap_algorithm : &@js.JsImpl,
    |   unwrapped_key_algorithm : &@js.JsImpl,
    |   extractable : Bool,
    |   key_usages : Array[String],
    | ) -> @js.Promise[@js.Any] {
166 |   self
    |   ^^^^ 	<-- UNCOVERED
    |   .call("unwrapKey", [
    |     format,
    |     wrapped_key,
    |     unwrapping_key,
    |     unwrap_algorithm,
    |     unwrapped_key_algorithm,
    |     extractable,
174 |     key_usages |> @js.from_array,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ])
176 |   .cast()
    |   ^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Crypto::getRandomValuesU16(
    |   self : Self,
    |   array : @typedarray.Uint16Array,
    | ) -> @typedarray.Uint16Array {
206 |   self.call("getRandomValues", [array]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Crypto::getRandomValuesI8(
    |   self : Self,
    |   array : @typedarray.Int8Array,
    | ) -> @typedarray.Int8Array {
226 |   self.call("getRandomValues", [array]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Crypto::getRandomValuesI16(
    |   self : Self,
    |   array : @typedarray.Int16Array,
    | ) -> @typedarray.Int16Array {
236 |   self.call("getRandomValues", [array]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Crypto::getRandomValuesI32(
    |   self : Self,
    |   array : @typedarray.Int32Array,
    | ) -> @typedarray.Int32Array {
246 |   self.call("getRandomValues", [array]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Crypto::getRandomValuesClamped(
    |   self : Self,
    |   array : @typedarray.Uint8ClampedArray,
    | ) -> @typedarray.Uint8ClampedArray {
256 |   self.call("getRandomValues", [array]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

4 uncovered line(s) in src/web/event/event_source.mbt:

    | pub fn EventSource::close(self : Self) -> Unit {
 55 |   self.call0("close") |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn EventSource::set_onopen(
    |   self : Self,
    |   handler : (@js.Any) -> Unit,
    | ) -> Unit {
 65 |   self.set("onopen", @js.from_fn1(handler))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn EventSource::set_onmessage(
    |   self : Self,
    |   handler : (@js.Any) -> Unit,
    | ) -> Unit {
 75 |   self.set("onmessage", @js.from_fn1(handler))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn EventSource::set_onerror(
    |   self : Self,
    |   handler : (@js.Any) -> Unit,
    | ) -> Unit {
 85 |   self.set("onerror", @js.from_fn1(handler))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

6 uncovered line(s) in src/web/http/fetch.mbt:

   | pub fn fetch(
   |   url : String,
   |   method_~ : String,
   |   headers? : Map[String, String] = {},
   |   cache? : String,
   |   mode? : String,
   |   body? : &@js.JsImpl, // String, ArrayBuffer, FormData, etc.
   |   credentials? : String,
   |   integrity? : String,
   |   keepalive? : Bool,
   |   priority? : String,
   |   redirect? : String,
   |   referrer? : String,
   |   referrerPolicy? : String,
   |   signal? : @js.AbortSignal,
   | ) -> @js.Promise[Response] {
28 |   let header_obj = @js.Object::new()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   for k, v in headers {
30 |     header_obj.set(k, v)
   |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
32 |   let init_obj = @js.from_entries_option([
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     ("method", Some(method_)),
   |     ("headers", Some(header_obj)),
35 |     ("body", body.map(x => x)),
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     ("cache", cache.map(x => x)),
   |     ("mode", mode.map(x => x)),
   |     ("credentials", credentials.map(x => x)),
   |     ("integrity", integrity.map(x => x)),
   |     ("keepalive", keepalive.map(x => x)),
   |     ("priority", priority.map(x => x)),
   |     ("redirect", redirect.map(x => x)),
   |     ("referrer", referrer.map(x => x)),
   |     ("referrerPolicy", referrerPolicy.map(x => x)),
   |     ("signal", signal.map(x => x)),
   |   ])
47 |   ffi_fetch(url, init_obj)
   |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn fetch_request(request : Request) -> @js.Promise[Response] {
52 |   ffi_fetch_request(request)
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

3 uncovered line(s) in src/web/http/form_data.mbt:

   | pub fn FormData::append(self : Self, name : String, value : String) -> Unit {
11 |   self.call2("append", name, value).cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn FormData::delete(self : Self, name : String) -> Unit {
16 |   self.call("delete", [name]).cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn FormData::get(self : Self, name : String) -> String {
21 |   self.call("get", [name]).cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

8 uncovered line(s) in src/web/http/request.mbt:

   | pub fn Request::new(url : String) -> Request {
19 |   let req = ffi_request_new(url)
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   @js.identity(req)
   | }
   …

   | pub fn Request::method_(self : Request) -> String {
27 |   self.get("method").cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Request::clone(self : Request) -> Request {
32 |   self.call0("clone").cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Request::json(self : Request) -> @js.Promise[@js.Any] {
37 |   self.call0("json").cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Request::text(self : Request) -> @js.Promise[String] {
42 |   self.call0("text").cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Request::arraybuffer(self : Request) -> @js.Promise[@js.ArrayBuffer] {
47 |   self.call0("arrayBuffer").cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Request::blob(self : Request) -> @js.Promise[@blob.Blob] {
52 |   self.call0("blob").cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Request::bytes(self : Request) -> @js.Promise[@typedarray.Uint8Array] {
57 |   self.call0("bytes").cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

6 uncovered line(s) in src/web/http/response.mbt:

    | pub fn Response::new(
    |   body? : String,
    |   status? : Int,
    |   statusText? : String,
    |   headers? : &@js.JsImpl,
    | ) -> Response {
 22 |   let body_js = match body {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(b) => @js.identity(b)
    |     None => @js.undefined()
    |   }
 26 |   match (status, statusText, headers) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(s), Some(st), Some(h)) =>
 28 |       new_impl_full(body_js, s, @js.identity(st), h.to_any())
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(s), Some(st), None) =>
 30 |       new_impl_status_text(body_js, s, @js.identity(st))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(s), None, Some(h)) => new_impl_status_headers(body_js, s, h.to_any())
    |     (Some(s), None, None) => new_impl_status(body_js, s)
    |     (None, Some(st), Some(h)) =>
 34 |       new_impl_text_headers(body_js, @js.identity(st), h.to_any())
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (None, Some(st), None) => new_impl_text(body_js, @js.identity(st))
    |     (None, None, Some(h)) => new_impl_headers(body_js, h.to_any())
    |     (None, None, None) => new_impl_plain(body_js)
    |   }
    | }
    …

    | pub fn Response::json_(data : &@js.JsImpl, options? : &@js.JsImpl) -> Response {
 98 |   match options {
    |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(opts) => json_impl(data.to_any(), opts.to_any())
    |     None => json_impl(data.to_any(), @js.undefined())
    |   }
    | }
    …

5 uncovered line(s) in src/web/message/message_channel.mbt:

    | pub impl Show for MessagePort with output(self, logger) {
 37 |   logger.write_string(self.to_string())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MessagePort::post_message_with_transfer(
    |   port : MessagePort,
    |   message : &@js.JsImpl,
    |   transfer : Array[@js.Any],
    | ) -> Unit {
 63 |   let arr = @js.JsArray::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let mut i = 0
    |   while i < transfer.length() {
 66 |     arr.call("push", [transfer[i]]) |> ignore
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     i = i + 1
    |   }
 69 |   port.call2("postMessage", message.to_any(), arr.to_any()) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl Show for MessageChannel with output(self, logger) {
 97 |   logger.write_string(self.to_string())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

7 uncovered line(s) in src/web/performance/observer.mbt:

   | pub fn PerformanceObserver::new(
   |   callback : (PerformanceObserverEntryList, PerformanceObserver) -> Unit,
   | ) -> PerformanceObserver {
30 |   ffi_new_performance_observer(fn(list, observer) {
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     callback(@js.identity(list), @js.identity(observer))
   |   })
   | }
   …

   | pub fn PerformanceObserver::observe(
   |   self : PerformanceObserver,
   |   options : @js.Object,
   | ) -> Unit {
43 |   self.call("observe", [options]) |> ignore
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn PerformanceObserver::disconnect(self : PerformanceObserver) -> Unit {
50 |   self.call0("disconnect") |> ignore
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn PerformanceObserver::takeRecords(
   |   self : PerformanceObserver,
   | ) -> Array[PerformanceEntry] {
59 |   self.call0("takeRecords").cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn PerformanceObserverEntryList::getEntries(
   |   self : PerformanceObserverEntryList,
   | ) -> Array[PerformanceEntry] {
68 |   self.call0("getEntries").cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn PerformanceObserverEntryList::getEntriesByType(
   |   self : PerformanceObserverEntryList,
   |   entryType : String,
   | ) -> Array[PerformanceEntry] {
78 |   self.call("getEntriesByType", [entryType]).cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn PerformanceObserverEntryList::getEntriesByName(
   |   self : PerformanceObserverEntryList,
   |   name : String,
   | ) -> Array[PerformanceEntry] {
88 |   self.call("getEntriesByName", [name]).cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

9 uncovered line(s) in src/web/performance/performance.mbt:

    | pub fn performance() -> Performance {
 29 |   @js.global_this().get("performance").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Performance::now(self : Performance) -> Double {
 36 |   self.call0("now").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Performance::mark(self : Performance, name : String) -> PerformanceEntry {
 43 |   self.call("mark", [name]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Performance::measure(
    |   self : Performance,
    |   name : String,
    |   startMark? : String,
    |   endMark? : String,
    | ) -> PerformanceEntry {
 55 |   match (startMark, endMark) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(s), Some(e)) => self.call("measure", [name, s, e]).cast()
    |     (Some(s), None) => self.call2("measure", name, s).cast()
    |     (None, _) => self.call("measure", [name]).cast()
    |   }
    | }
    …

    | pub fn Performance::getEntries(self : Performance) -> Array[PerformanceEntry] {
 66 |   self.call0("getEntries").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Performance::getEntriesByType(
    |   self : Performance,
    |   entryType : String,
    | ) -> Array[PerformanceEntry] {
 76 |   self.call("getEntriesByType", [entryType]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Performance::getEntriesByName(
    |   self : Performance,
    |   name : String,
    | ) -> Array[PerformanceEntry] {
 86 |   self.call("getEntriesByName", [name]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Performance::clearMarks(self : Performance, name? : String) -> Unit {
 93 |   match name {
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(n) => self.call("clearMarks", [n]) |> ignore
    |     None => self.call0("clearMarks") |> ignore
    |   }
    | }
    …

    | pub fn Performance::clearMeasures(self : Performance, name? : String) -> Unit {
103 |   match name {
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(n) => self.call("clearMeasures", [n]) |> ignore
    |     None => self.call0("clearMeasures") |> ignore
    |   }
    | }
    …

10 uncovered line(s) in src/web/streams/stream.mbt:

    | pub fn ReadableStream::cancel(
    |   self : Self,
    |   reason? : @js.Any,
    | ) -> @js.Promise[Unit] {
 28 |   match reason {
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(r) => self.call("cancel", [r]).cast()
    |     None => self.call0("cancel").cast()
    |   }
    | }
    …

    | #alias(pipe_to)
    | pub fn ReadableStream::pipeTo(
    |   self : Self,
    |   destination : WritableStream,
    |   options? : @js.Any,
    | ) -> @js.Promise[Unit] {
 49 |   match options {
    |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(opts) => self.call2("pipeTo", destination, opts).cast()
    |     None => self.call("pipeTo", [destination]).cast()
    |   }
    | }
    …

    | #alias(pipe_through)
    | pub fn ReadableStream::pipeThrough(
    |   self : Self,
    |   transform : @js.Any,
    |   options? : @js.Any,
    | ) -> ReadableStream {
 63 |   match options {
    |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(opts) => self.call2("pipeThrough", transform, opts).cast()
    |     None => self.call("pipeThrough", [transform]).cast()
    |   }
    | }
    …

    | pub fn ReadableStreamDefaultReader::read(self : Self) -> @js.Promise[@js.Any] {
 94 |   self.call0("read").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ReadableStreamDefaultReader::cancel(
    |   self : Self,
    |   reason? : @js.Any,
    | ) -> @js.Promise[Unit] {
110 |   match reason {
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(r) => self.call("cancel", [r]).cast()
    |     None => self.call0("cancel").cast()
    |   }
    | }
    …

    | pub fn WritableStream::abort(
    |   self : Self,
    |   reason? : @js.Any,
    | ) -> @js.Promise[Unit] {
142 |   match reason {
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(r) => self.call("abort", [r]).cast()
    |     None => self.call0("abort").cast()
    |   }
    | }
    …

    | pub fn WritableStream::close(self : Self) -> @js.Promise[Unit] {
151 |   self.call0("close").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn WritableStreamDefaultWriter::write(
    |   self : Self,
    |   chunk : @js.Any,
    | ) -> @js.Promise[Unit] {
178 |   self.call("write", [chunk]).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn WritableStreamDefaultWriter::close(self : Self) -> @js.Promise[Unit] {
184 |   self.call0("close").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn WritableStreamDefaultWriter::abort(
    |   self : Self,
    |   reason? : @js.Any,
    | ) -> @js.Promise[Unit] {
193 |   match reason {
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(r) => self.call("abort", [r]).cast()
    |     None => self.call0("abort").cast()
    |   }
    | }
    …

2 uncovered line(s) in src/web/url/search_params.mbt:

   | impl Eq for URLSearchParams with equal(self, other) {
11 |   self.to_any() == other.to_any()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | impl Show for URLSearchParams with output(self, logger) {
16 |   logger.write_string(self.to_string())
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

1 uncovered line(s) in src/web/url/url.mbt:

   | pub fn URL::searchParams(self : URL) -> URLSearchParams {
38 |   self.get("searchParams").cast()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

6 uncovered line(s) in src/web/url/url_pattern.mbt:

    | pub fn URLPattern::new(pattern : String, base? : String) -> URLPattern {
    |   let pattern_val = @js.unsafe_any(pattern)
    |   match base {
 58 |     Some(b) => @js.identity(ffi_new_url_pattern_with_base(pattern_val, b))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => @js.identity(ffi_new_url_pattern(pattern_val))
    |   }
    | }
    …

    | #alias(new_from_object)
    | pub fn URLPattern::newFromObject(
    |   pattern : @js.Any,
    |   base? : String,
    | ) -> URLPattern {
 70 |   match base {
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(b) => @js.identity(ffi_new_url_pattern_with_base(pattern, b))
    |     None => @js.identity(ffi_new_url_pattern(pattern))
    |   }
    | }
    …

    | pub fn URLPattern::test_url_with_base(
    |   self : Self,
    |   input : String,
    |   base? : String,
    | ) -> Bool {
 89 |   match base {
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(b) => self.call2("test", input, b).cast()
    |     None => self.call("test", [input]).cast()
    |   }
    | }
    …

    | #alias(exec_with_base)
    | pub fn URLPattern::execWithBase(
    |   self : Self,
    |   input : String,
    |   base? : String,
    | ) -> URLPatternResult? {
118 |   let result = match base {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(b) => self.call2("exec", input, b)
    |     None => self.call("exec", [input])
    |   }
    |   if ffi_is_null(result) {
123 |     None
    |     ^^^^ 	<-- UNCOVERED
    |   } else {
125 |     Some(result.cast())
    |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

7 uncovered line(s) in src/web/webassembly/webassembly.mbt:

    | pub fn WebAssemblyTable::set(self : Self, index : Int, value : @js.Any) -> Unit {
 94 |   ignore(self.call2("set", index, value))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn WebAssemblyTable::grow(self : Self, delta : Int, value : @js.Any) -> Int {
100 |   self.call2("grow", delta, value).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn instantiate_bytes(
    |   bytes : @typedarray.Uint8Array,
    |   import_object : @js.Any?,
    | ) -> (WebAssemblyModule, WebAssemblyInstance) {
227 |   let imports = match import_object {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(obj) => obj
    |     None => @js.undefined()
    |   }
231 |   let result = ffi_instantiate(bytes.to_any(), imports)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let wasm_module : WebAssemblyModule = result.get("module").cast()
    |   let instance : WebAssemblyInstance = result.get("instance").cast()
    |   (wasm_module, instance)
    | }
    …

    | pub fn instantiate_module(
    |   wasm_module : WebAssemblyModule,
    |   import_object : @js.Any?,
    | ) -> WebAssemblyInstance {
243 |   let imports = match import_object {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(obj) => obj
    |     None => @js.undefined()
    |   }
247 |   ffi_instantiate(wasm_module.to_any(), imports).cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn compile(bytes : @typedarray.Uint8Array) -> @js.Any {
267 |   ffi_compile(bytes.to_any())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

10 uncovered line(s) in src/web/websocket/websocket.mbt:

    | pub fn WebSocket::close(self : Self, code? : Int, reason? : String) -> Unit {
 72 |   match (code, reason) {
    |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(c), Some(r)) => self.call("close", [c, r]) |> ignore
    |     (Some(c), None) => self.call1("close", c) |> ignore
    |     (None, _) => self.call0("close") |> ignore
    |   }
    | }
    …

    | pub fn WebSocket::send_string(self : Self, data : String) -> Unit {
 83 |   self.call1("send", data) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn WebSocket::send_buffer(self : Self, data : @buffer.Buffer) -> Unit {
 90 |   self.call1("send", data) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn WebSocket::send_arraybuffer(self : Self, data : @js.ArrayBuffer) -> Unit {
 97 |   self.call1("send", data) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn WebSocket::send_blob(self : Self, data : @blob.Blob) -> Unit {
104 |   self.call1("send", data) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn WebSocket::set_onopen(self : Self, handler : (@js.Any) -> Unit) -> Unit {
111 |   self.set("onopen", @js.from_fn1(handler))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn WebSocket::set_onmessage(
    |   self : Self,
    |   handler : (@js.Any) -> Unit,
    | ) -> Unit {
121 |   self.set("onmessage", @js.from_fn1(handler))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn WebSocket::set_onerror(self : Self, handler : (@js.Any) -> Unit) -> Unit {
128 |   self.set("onerror", @js.from_fn1(handler))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn WebSocket::set_onclose(self : Self, handler : (@js.Any) -> Unit) -> Unit {
135 |   self.set("onclose", @js.from_fn1(handler))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn get_message_data(event : @js.Any) -> String {
142 |   event.get("data").cast()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

8 uncovered line(s) in src/web/worker/worker.mbt:

   | pub fn Worker::new(script_url : String, type_? : String) -> Worker {
41 |   let option = if type_ is Some(v) {
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     @js.from_map({ "type": @js.any(v) })
   |   } else {
44 |     @js.undefined()
   |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
46 |   ffi_new_worker(script_url, option)
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Worker::terminate(worker : Worker) -> Unit {
51 |   worker.call0("terminate") |> ignore
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | #alias(post_message)
   | pub fn Worker::postMessage(worker : Worker, message : &@js.JsImpl) -> Unit {
65 |   ffi_worker_post_message(worker, message.to_any(), @js.undefined())
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Worker::post_message_with_transfer(
   |   worker : Worker,
   |   message : &@js.JsImpl,
   |   transfer : Array[@js.Any],
   | ) -> Unit {
74 |   let arr = @js.JsArray::new()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   let mut i = 0
   |   while i < transfer.length() {
77 |     arr.call("push", [transfer[i]]) |> ignore
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     i = i + 1
   |   }
80 |   ffi_worker_post_message(worker, message.to_any(), arr.to_any())
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

Total: 2278 uncovered line(s) in 138 file(s)
