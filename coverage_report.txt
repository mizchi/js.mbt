Hello, WASI!
✔ renderToString should render a simple element (36.330834ms)
✔ renderToString should render an element with text (2.27025ms)
✔ renderToReadableStream should return a Promise of ReadableStream (12.532458ms)
✔ renderToReadableStream should render HTML content (2.297417ms)
✔ renderToReadableStream should handle nested elements (1.521625ms)
✔ Promise::then (5.616042ms)
✔ Promise::catch_ (0.358125ms)
✔ Promise::finally_ (4.986708ms)
✔ Promise::all (0.948417ms)
✔ Promise::race (5.085ms)
✔ Promise::new (3.536666ms)
✔ Promise::try_ success (1.289875ms)
✔ Promise::try_ failure (1.557958ms)
✔ async function to Promise and back (0.45375ms)
✔ Promise.resolve to async unwrap (2.137ms)
✔ promisify0 converts async function to Promise function (0.478334ms)
✔ promisify1 converts async function to Promise function (0.240625ms)
✔ Promise.then with async unwrap (0.150208ms)
✔ unwrap Promise inside async function (0.185ms)
✔ Promise.all with async unwrap (0.172416ms)
✔ async function with error converts to rejected Promise (0.266084ms)
✔ Promise.new to async unwrap (0.231792ms)
✔ chaining async and Promise operations (0.180167ms)
✔ Promise and async are interchangeable (0.122166ms)
✔ Promise.race returns first resolved Promise (1.56925ms)
✔ Promise.finally_ always executes (0.163125ms)
✔ Promise.finally_ always executes (0.378542ms)
✔ promisify0 (0.210667ms)
✔ promisify1 (0.092583ms)
✔ promisify2 (0.178458ms)
✔ promisify3 (1.809417ms)
✔ suspend with resolve (0.188667ms)
✔ suspend with reject (0.110542ms)
✔ Promise chain (0.641417ms)
✔ Promise::resolve with different types (0.28775ms)
✔ Promise::all with empty array (0.094333ms)
✔ Promise::race with single promise (0.084959ms)
✔ nested promises (5.522666ms)
✔ Promise::all with mixed resolution times (17.034583ms)
✔ Promise::withResolvers multiple resolve calls (0.161833ms)
✔ Promise chain with error recovery (0.269625ms)
✔ Readable stream - read and pause/resume (0.3795ms)
✔ Readable stream - properties (0.697ms)
✔ Writable stream - write and properties (0.324125ms)
✔ pipe - Readable to Writable (12.61425ms)
✔ Transform stream - uppercase (11.913667ms)
✔ PassThrough stream (12.370458ms)
✔ pipeline - multiple streams (11.969417ms)
✔ pipeline with callback (23.515375ms)
✔ finished - stream completion (24.929ms)
✔ Readable setEncoding (0.387958ms)
✔ Writable cork/uncork (11.61625ms)
✔ Readable unpipe (1.593416ms)
✔ async pipeline with Promise (4.010875ms)
✔ Readable destroy (6.437458ms)
✔ Writable destroy (7.067292ms)
✔ Writable end (6.045916ms)
✔ multiple transforms in pipeline (16.199959ms)
✔ stream properties after operations (12.636959ms)
✔ pipeline with promises - basic (1.784ms)
✔ pipeline with promises - with transform (2.116625ms)
✔ pipeline with promises - multiple transforms (2.201667ms)
✔ finished with promises - writable (0.46525ms)
✔ finished with promises - readable (0.281541ms)
✔ pipeline with promises - async operations (1.916459ms)
✔ pipeline with promises - successful completion (0.591958ms)
✔ pipeline with promises - then chain (0.372292ms)
✔ finished with promises - multiple streams (0.269208ms)
✔ pipeline with promises - large data (2.250209ms)
✔ isIPv4 should validate IPv4 addresses (1.314875ms)
✔ isIPv6 should validate IPv6 addresses (4.376167ms)
✔ isIP should return IP version (0.235917ms)
✔ Server can be created (0.448791ms)
✔ Server can be created with options (0.150333ms)
✔ Server listen with callback (105.107084ms)
✔ Server listen and get address (51.839208ms)
✔ Socket can be created (0.806375ms)
✔ Promise::withResolvers resolve (1.917583ms)
✔ fs writeFile/readFile/stat (3.437042ms)
✔ fs mkdir/rm (1.856666ms)
✔ fs rename (2.3545ms)
✔ fs cp (3.280625ms)
✔ fs operations sequence (14.464458ms)
✔ concurrent file operations (2.336375ms)
✔ fs readFile non-existent file (0.298125ms)
✔ EventEmitter on/emit/off (52.725375ms)
✔ EventEmitter once (10.077208ms)
✔ EventEmitter eventNames (0.179208ms)
✔ EventEmitter multiple listeners (11.805833ms)
✔ EventEmitter with async handlers (21.481542ms)
✔ multiple promises concurrent (6.314791ms)
✔ timer and promise coordination (10.259042ms)
✔ EventEmitter stress test (21.712375ms)
✔ multiple EventEmitters (11.929916ms)
✔ EventEmitter with different payload types (11.401834ms)
✔ EventEmitter removeAllListeners specific event (11.403708ms)
✔ execSync executes command and returns output (31.046833ms)
✔ execSync with working directory option (27.689ms)
✔ execSync with input string (35.571667ms)
✔ spawnSync executes command and returns result (20.975083ms)
✔ spawnSync with shell option (27.109416ms)
✔ execFileSync executes file and returns output (19.69025ms)
✔ execFileSync with working directory (20.869666ms)
✔ spawn creates child process with valid PID (2.214167ms)
✔ spawn with shell option (0.513833ms)
✔ spawn with working directory (1.491333ms)
✔ ChildProcess has stdout and stderr streams (1.444667ms)
✔ ChildProcess exitCode is None for running process (0.97875ms)
✔ ChildProcess kill terminates process (1.837958ms)
✔ ChildProcess kill with signal (1.931792ms)
✔ ChildProcess unref and ref methods (1.835916ms)
✔ SpawnSyncResult has all properties (25.991416ms)
✔ SpawnSyncResult successful command has status 0 (20.090459ms)
✔ ChildProcess has EventEmitter methods (1.326333ms)
✔ spawnSync handles non-existent command with error (0.394042ms)
✔ spawnSync handles command not found (0.219916ms)
✔ execSync captures stdout correctly (26.762334ms)
✔ spawnSync captures output in result (20.280666ms)
✔ setTimeout (20.971875ms)
✔ clearTimeout (21.448667ms)
✔ sleep multiple times (17.525292ms)
✔ nested run_async (21.813917ms)
✔ setTimeout with zero delay (2.299458ms)
✔ multiple setTimeouts (26.464083ms)
✔ run_async with multiple sleep calls (32.767833ms)
✔ EventEmitter listenerCount for non-existent event (0.223375ms)
✔ setInterval immediate execution (11.857417ms)
✔ sleep with very short duration (1.490083ms)
✔ SubtleCrypto digest SHA-256 (1.423209ms)
✔ SubtleCrypto digest SHA-384 (0.305083ms)
✔ SubtleCrypto digest SHA-512 (0.280542ms)
✔ SubtleCrypto generateKey AES-GCM (1.659666ms)
✔ SubtleCrypto generateKey HMAC (1.248834ms)
✔ SubtleCrypto encrypt and decrypt with AES-GCM (1.628209ms)
✔ SubtleCrypto sign and verify with HMAC (1.141ms)
✔ SubtleCrypto exportKey and importKey with AES-GCM (1.123042ms)
✔ getCrypto returns Crypto instance (0.337083ms)
ℹ tests 137
ℹ suites 0
ℹ pass 137
ℹ fail 0
ℹ cancelled 0
ℹ skipped 0
ℹ todo 0
ℹ duration_ms 1444.604292
Total: 1485 uncovered line(s) in 89 file(s)

3 uncovered line(s) in src/_tests/main.mbt:

   | fn main {
 3 |   beforeEach(() => println("before each test"))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   it("sample test", fn(_) { assert_true(true) })
   |   it("sample test", fn(_) { assert_true(false) })
   |   // beforeEach(() => @promise.sleep(1))
 7 |   it("simple test", _ => assert_eq(2 + 2, 4))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   it("lazy test", _ => {
   |     @promise.sleep(100)
   |     assert_eq(2 + 2, 4)
   |   })
12 |   it("skip test", skip="skip this test", _ => assert_eq(2 + 2, 5))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   it("todo test", ctx => ctx.todo("this test is todo"))
   | }
   …

12 uncovered line(s) in src/builtins.mbt:

    | pub fn Symbol::asyncIterator() -> Symbol {
 40 |   symbol_class().get("asyncIterator") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Symbol::toStringTag() -> Symbol {
 58 |   symbol_class().get("toStringTag") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | fn string_instance() -> JsString {
 91 |   unsafe_cast(globalThis().get("String"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn JsString::fromCharCode(values : Array[Int]) -> String {
 97 |   string_instance().call("fromCharCode", values |> from_array |> unsafe_cast)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   |> unsafe_cast
    | }
    …

    | pub fn JsString::fromCodePoint(values : Array[Int]) -> String {
104 |   string_instance().call("fromCodePoint", values |> from_array |> unsafe_cast)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   |> unsafe_cast
    | }
    …

    | pub fn Object::is_(a : &JsImpl, b : &JsImpl) -> Js {
162 |   object_class().call2("create", a, b) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Object::isPrototypeOf(self : Self, target : Js) -> Bool {
216 |   ffi_is_prototype_of(self.to_js(), target)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Object::isExtensible(self : Self) -> Bool {
226 |   self.call0("isExtensible") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[T] JsArray::from(items : Array[T]) -> JsArray {
252 |   ffi_array_from(items |> unsafe_cast) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[T : JsImpl] JsArray::isArray(v : T) -> Bool {
276 |   ffi_is_array(v.to_js())
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Function::to_string(self : Self) -> String {
295 |   ffi_json_stringify(self.to_js(), undefined(), undefined())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Function::name(self : Self) -> String {
301 |   self.get("name") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

4 uncovered line(s) in src/cloudflare/cloudflare.mbt:

   | pub fn CloudflareRequest::cf(self : CloudflareRequest) -> CloudflareContext {
23 |   unsafe_cast(self.get("cf"))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn CloudflareRequest::url(self : CloudflareRequest) -> String {
28 |   unsafe_cast(self.get("url"))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | #alias(waitUntil)
   | pub fn CloudflareContext::wait_until(
   |   self : CloudflareContext,
   |   promise : Promise[Unit],
   | ) -> Unit {
37 |   unsafe_cast(self.get("waitUntil").call_self([promise |> unsafe_cast]))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | #alias(passThroughException)
   | pub fn CloudflareContext::pass_through_exception(
   |   self : CloudflareContext,
   | ) -> Unit {
45 |   self.get("passThroughException").call_self([]) |> ignore
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

22 uncovered line(s) in src/cloudflare/d1.mbt:

    | pub fn D1Database::prepare(self : Self, query : String) -> D1PreparedStatement {
 13 |   self.call("prepare", [query]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn D1Database::exec(self : Self, query : String) -> Promise[D1ExecResult] {
 19 |   self.call("exec", [query]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn D1Database::batch(
    |   self : Self,
    |   statements : Array[D1PreparedStatement],
    | ) -> Promise[Array[D1Result]] {
 28 |   let stmts_js = @js.JsArray::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let mut i = 0
    |   while i < statements.length() {
 31 |     stmts_js.call("push", [statements[i]]) |> ignore
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     i = i + 1
    |   }
 34 |   self.call("batch", [stmts_js]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn D1Database::dump(self : Self) -> Promise[Js] {
 40 |   self.call("dump", []) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn D1PreparedStatement::bind(self : Self, params : Array[Js]) -> Self {
    |   // Cloudflare's bind() expects variadic arguments, not an array
    |   // We need to spread the array when calling bind
 57 |   let stmt_js = self.to_js()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let bind_fn = stmt_js.get("bind")
    | 
    |   // Convert MoonBit array to JavaScript array
 61 |   let params_js = @js.JsArray::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let mut i = 0
    |   while i < params.length() {
 64 |     params_js.call("push", [params[i]]) |> ignore
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     i = i + 1
    |   }
    | 
    |   // Use apply to spread the array as individual arguments
 69 |   unsafe_cast(bind_fn.call("apply", [stmt_js, params_js]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn D1PreparedStatement::bind1(self : Self, param : Js) -> Self {
 75 |   self.bind([param])
    |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn D1PreparedStatement::bind2(self : Self, p1 : Js, p2 : Js) -> Self {
 81 |   self.bind([p1, p2])
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn D1PreparedStatement::bind3(
    |   self : Self,
    |   p1 : Js,
    |   p2 : Js,
    |   p3 : Js,
    | ) -> Self {
 92 |   self.bind([p1, p2, p3])
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn D1PreparedStatement::first(self : Self) -> Promise[Js?] {
 98 |   self.call("first", []) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn D1PreparedStatement::first_col(
    |   self : Self,
    |   col_name : String,
    | ) -> Promise[Js?] {
107 |   self.call1("first", col_name) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn D1PreparedStatement::all(self : Self) -> Promise[D1Result] {
113 |   self.call0("all") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn D1PreparedStatement::run(self : Self) -> Promise[D1Result] {
119 |   self.call0("run") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn D1PreparedStatement::raw(self : Self) -> Promise[Array[Js]] {
125 |   self.call0("raw") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn D1PreparedStatement::raw_with_options(
    |   self : Self,
    |   options : D1RawOptions,
    | ) -> Promise[Array[Js]] {
134 |   self.call1("raw", options) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl JsImpl for D1RawOptions with to_js(self) {
145 |   let obj = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match self.column_names {
    |     Some(val) => obj.set("columnNames", val)
    |     None => ()
    |   }
150 |   obj.to_js()
    |   ^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn D1Result::get_results(self : Self) -> Array[Js] {
168 |   match self.results {
    |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(r) => r
    |     None => []
    |   }
    | }
    …

92 uncovered line(s) in src/cloudflare/do.mbt:

    | pub fn DurableObjectNamespace::get(
    |   self : Self,
    |   id : DurableObjectId,
    | ) -> DurableObjectStub {
 16 |   self.call1("get", id) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectNamespace::get_by_id_string(
    |   self : Self,
    |   id : String,
    | ) -> DurableObjectStub {
 25 |   self.call1("get", id) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectNamespace::get_by_name(
    |   self : Self,
    |   name : String,
    | ) -> DurableObjectStub {
 34 |   self.call("get", [self.id_from_name(name).to_js()]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectNamespace::new_unique_id(self : Self) -> DurableObjectId {
 40 |   self.call("newUniqueId", []) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectNamespace::new_unique_id_with_options(
    |   self : Self,
    |   options : DurableObjectIdOptions,
    | ) -> DurableObjectId {
 49 |   self.call("newUniqueId", [options.to_js()]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectNamespace::id_from_name(
    |   self : Self,
    |   name : String,
    | ) -> DurableObjectId {
 58 |   self.call("idFromName", [name]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectNamespace::id_from_string(
    |   self : Self,
    |   id : String,
    | ) -> DurableObjectId {
 67 |   self.call("idFromString", [id]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl JsImpl for DurableObjectIdOptions with to_js(self) {
 78 |   let obj = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match self.jurisdiction {
    |     Some(j) => obj.set("jurisdiction", j)
    |     None => ()
    |   }
 83 |   obj.to_js()
    |   ^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectId::to_string(self : Self) -> String {
 97 |   self.call("toString", []) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectId::equals(self : Self, other : DurableObjectId) -> Bool {
103 |   self.call("equals", [other.to_js()]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectId::name(self : Self) -> String? {
109 |   unsafe_cast(self.get("name"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStub::id(self : Self) -> DurableObjectId {
123 |   unsafe_cast(self.get("id"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStub::name(self : Self) -> String? {
129 |   unsafe_cast(self.get("name"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStub::fetch(self : Self, request : Js) -> Promise[Js] {
135 |   self.call("fetch", [request]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStub::fetch_with_init(
    |   self : Self,
    |   request : Js,
    |   init : Js,
    | ) -> Promise[Js] {
145 |   self.call("fetch", [request, init]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStub::fetch_url(self : Self, url : String) -> Promise[Js] {
151 |   self.call("fetch", [url]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStub::fetch_url_with_init(
    |   self : Self,
    |   url : String,
    |   init : Js,
    | ) -> Promise[Js] {
161 |   self.call("fetch", [url, init]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectState::id(self : Self) -> DurableObjectId {
175 |   unsafe_cast(self.get("id"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectState::storage(self : Self) -> DurableObjectStorage {
181 |   unsafe_cast(self.get("storage"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectState::wait_until(self : Self, promise : Js) -> Unit {
187 |   self.call("waitUntil", [promise]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectState::block_concurrency_while(
    |   self : Self,
    |   callback : Js,
    | ) -> Promise[Unit] {
196 |   self.call("blockConcurrencyWhile", [callback]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::get(self : Self, key : String) -> Promise[Js?] {
210 |   self.call("get", [key]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::get_with_options(
    |   self : Self,
    |   key : String,
    |   options : DurableObjectGetOptions,
    | ) -> Promise[Js?] {
220 |   self.call("get", [key, options]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::get_multiple(
    |   self : Self,
    |   keys : Array[String],
    | ) -> Promise[Js] {
229 |   let keys_js = @js.JsArray::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let mut i = 0
    |   while i < keys.length() {
232 |     keys_js.call("push", [keys[i]]) |> ignore
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     i = i + 1
    |   }
235 |   self.call("get", [keys_js]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::get_multiple_with_options(
    |   self : Self,
    |   keys : Array[String],
    |   options : DurableObjectGetOptions,
    | ) -> Promise[Js] {
245 |   let keys_js = @js.JsArray::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let mut i = 0
    |   while i < keys.length() {
248 |     keys_js.call("push", [keys[i]]) |> ignore
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     i = i + 1
    |   }
251 |   self.call("get", [keys_js, options.to_js()]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::put(
    |   self : Self,
    |   key : String,
    |   value : Js,
    | ) -> Promise[Unit] {
261 |   self.call("put", [key, value]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::put_with_options(
    |   self : Self,
    |   key : String,
    |   value : Js,
    |   options : DurableObjectPutOptions,
    | ) -> Promise[Unit] {
272 |   self.call("put", [key, value, options]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::put_multiple(
    |   self : Self,
    |   entries : Js,
    | ) -> Promise[Unit] {
281 |   self.call("put", [entries]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::put_multiple_with_options(
    |   self : Self,
    |   entries : Js,
    |   options : DurableObjectPutOptions,
    | ) -> Promise[Unit] {
291 |   self.call("put", [entries, options.to_js()]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::delete(self : Self, key : String) -> Promise[Bool] {
297 |   self.call("delete", [key]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::delete_with_options(
    |   self : Self,
    |   key : String,
    |   options : DurableObjectPutOptions,
    | ) -> Promise[Bool] {
307 |   self.call("delete", [key, options]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::delete_multiple(
    |   self : Self,
    |   keys : Array[String],
    | ) -> Promise[Int] {
316 |   let keys_js = @js.JsArray::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let mut i = 0
    |   while i < keys.length() {
319 |     keys_js.call("push", [keys[i]]) |> ignore
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     i = i + 1
    |   }
322 |   self.call("delete", [keys_js]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::delete_multiple_with_options(
    |   self : Self,
    |   keys : Array[String],
    |   options : DurableObjectPutOptions,
    | ) -> Promise[Int] {
332 |   let keys_js = @js.JsArray::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let mut i = 0
    |   while i < keys.length() {
335 |     keys_js.call("push", [keys[i]]) |> ignore
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     i = i + 1
    |   }
338 |   self.call("delete", [keys_js, options.to_js()]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::delete_all(self : Self) -> Promise[Unit] {
344 |   self.call("deleteAll", []) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::delete_all_with_options(
    |   self : Self,
    |   options : DurableObjectPutOptions,
    | ) -> Promise[Unit] {
353 |   self.call("deleteAll", [options.to_js()]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::list(self : Self) -> Promise[Js] {
359 |   self.call0("list") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::list_with_options(
    |   self : Self,
    |   options : DurableObjectListOptions,
    | ) -> Promise[Js] {
368 |   self.call("list", [options.to_js()]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::transaction(
    |   self : Self,
    |   closure : Js,
    | ) -> Promise[Js] {
377 |   self.call("transaction", [closure]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::get_alarm(self : Self) -> Promise[Int?] {
383 |   self.call0("getAlarm") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::get_alarm_with_options(
    |   self : Self,
    |   options : DurableObjectGetAlarmOptions,
    | ) -> Promise[Int?] {
392 |   self.call("getAlarm", [options.to_js()]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::set_alarm(
    |   self : Self,
    |   scheduled_time : Int,
    | ) -> Promise[Unit] {
401 |   self.call("setAlarm", [scheduled_time]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::set_alarm_with_options(
    |   self : Self,
    |   scheduled_time : Int,
    |   options : DurableObjectSetAlarmOptions,
    | ) -> Promise[Unit] {
411 |   self.call("setAlarm", [scheduled_time, options]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::delete_alarm(self : Self) -> Promise[Unit] {
417 |   self.call0("deleteAlarm") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::delete_alarm_with_options(
    |   self : Self,
    |   options : DurableObjectSetAlarmOptions,
    | ) -> Promise[Unit] {
426 |   self.call("deleteAlarm", [options.to_js()]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectStorage::sync(self : Self) -> Promise[Unit] {
432 |   self.call0("sync") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl JsImpl for DurableObjectGetOptions with to_js(self) {
444 |   let obj = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match self.allow_concurrency {
    |     Some(val) => obj.set("allowConcurrency", val)
    |     None => ()
    |   }
449 |   match self.no_cache {
    |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(val) => obj.set("noCache", val)
    |     None => ()
    |   }
453 |   obj.to_js()
    |   ^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl JsImpl for DurableObjectPutOptions with to_js(self) {
466 |   let obj = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match self.allow_concurrency {
    |     Some(val) => obj.set("allowConcurrency", val)
    |     None => ()
    |   }
471 |   match self.allow_unconfirmed {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(val) => obj.set("allowUnconfirmed", val)
    |     None => ()
    |   }
475 |   match self.no_cache {
    |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(val) => obj.set("noCache", val)
    |     None => ()
    |   }
479 |   obj.to_js()
    |   ^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl JsImpl for DurableObjectListOptions with to_js(self) {
497 |   let obj = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match self.start {
    |     Some(val) => obj.set("start", val)
    |     None => ()
    |   }
502 |   match self.start_after {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(val) => obj.set("startAfter", val)
    |     None => ()
    |   }
506 |   match self.end {
    |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(val) => obj.set("end", val)
    |     None => ()
    |   }
510 |   match self.prefix {
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(val) => obj.set("prefix", val)
    |     None => ()
    |   }
514 |   match self.reverse {
    |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(val) => obj.set("reverse", val)
    |     None => ()
    |   }
518 |   match self.limit {
    |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(val) => obj.set("limit", val)
    |     None => ()
    |   }
522 |   match self.allow_concurrency {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(val) => obj.set("allowConcurrency", val)
    |     None => ()
    |   }
526 |   match self.no_cache {
    |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(val) => obj.set("noCache", val)
    |     None => ()
    |   }
530 |   obj.to_js()
    |   ^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl JsImpl for DurableObjectGetAlarmOptions with to_js(self) {
541 |   let obj = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match self.allow_concurrency {
    |     Some(val) => obj.set("allowConcurrency", val)
    |     None => ()
    |   }
546 |   obj.to_js()
    |   ^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl JsImpl for DurableObjectSetAlarmOptions with to_js(self) {
558 |   let obj = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match self.allow_concurrency {
    |     Some(val) => obj.set("allowConcurrency", val)
    |     None => ()
    |   }
563 |   match self.allow_unconfirmed {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(val) => obj.set("allowUnconfirmed", val)
    |     None => ()
    |   }
567 |   obj.to_js()
    |   ^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectTransaction::get(self : Self, key : String) -> Promise[Js?] {
581 |   self.call("get", [key]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectTransaction::get_multiple(
    |   self : Self,
    |   keys : Array[String],
    | ) -> Promise[Js] {
590 |   let keys_js = @js.JsArray::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let mut i = 0
    |   while i < keys.length() {
593 |     keys_js.call("push", [keys[i]]) |> ignore
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     i = i + 1
    |   }
596 |   self.call("get", [keys_js]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectTransaction::put(
    |   self : Self,
    |   key : String,
    |   value : Js,
    | ) -> Promise[Unit] {
606 |   self.call("put", [key, value]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectTransaction::put_multiple(
    |   self : Self,
    |   entries : Js,
    | ) -> Promise[Unit] {
615 |   self.call("put", [entries]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectTransaction::delete(
    |   self : Self,
    |   key : String,
    | ) -> Promise[Bool] {
624 |   self.call("delete", [key]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectTransaction::delete_multiple(
    |   self : Self,
    |   keys : Array[String],
    | ) -> Promise[Int] {
633 |   let keys_js = @js.JsArray::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let mut i = 0
    |   while i < keys.length() {
636 |     keys_js.call("push", [keys[i]]) |> ignore
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     i = i + 1
    |   }
639 |   self.call("delete", [keys_js]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectTransaction::delete_all(self : Self) -> Promise[Unit] {
645 |   self.call0("deleteAll") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectTransaction::list(self : Self) -> Promise[Js] {
651 |   self.call("list", []) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectTransaction::list_with_options(
    |   self : Self,
    |   options : DurableObjectListOptions,
    | ) -> Promise[Js] {
660 |   self.call("list", [options.to_js()]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectTransaction::rollback(self : Self) -> Unit {
666 |   self.call("rollback", []) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectTransaction::get_alarm(self : Self) -> Promise[Int?] {
672 |   self.call("getAlarm", []) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectTransaction::set_alarm(
    |   self : Self,
    |   scheduled_time : Int,
    | ) -> Promise[Unit] {
681 |   self.call("setAlarm", [scheduled_time]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DurableObjectTransaction::delete_alarm(self : Self) -> Promise[Unit] {
687 |   self.call0("deleteAlarm") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

21 uncovered line(s) in src/cloudflare/kv.mbt:

    | pub fn KVNamespace::get(
    |   self : Self,
    |   key : String,
    |   options : KVGetOptions?,
    | ) -> Promise[String?] {
 18 |   match options {
    |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => self.call("get", [key]) |> unsafe_cast
    |     Some(opts) => self.call("get", [key, opts]) |> unsafe_cast
    |   }
    | }
    …

    | pub fn KVNamespace::get_array_buffer(self : Self, key : String) -> Promise[Js?] {
 27 |   let opts_js = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   opts_js.set("type", "arrayBuffer")
    |   self.call("get", [key, opts_js]) |> unsafe_cast
    | }
    …

    | pub fn KVNamespace::get_json(self : Self, key : String) -> Promise[Js?] {
 35 |   let opts_js = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   opts_js.set("type", "json")
    |   self.call("get", [key, opts_js]) |> unsafe_cast
    | }
    …

    | pub fn KVNamespace::get_stream(self : Self, key : String) -> Promise[Js?] {
 43 |   let opts_js = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   opts_js.set("type", "stream")
    |   self.call("get", [key, opts_js]) |> unsafe_cast
    | }
    …

    | pub fn KVNamespace::get_with_metadata(
    |   self : Self,
    |   key : String,
    |   options : KVGetOptions?,
    | ) -> Promise[KVValueWithMetadata] {
 55 |   match options {
    |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => {
    |       let opts_js = @js.Object::new()
    |       opts_js.set("type", "text")
    |       self.call("getWithMetadata", [key, opts_js]) |> unsafe_cast
    |     }
 61 |     Some(opts) => self.call("getWithMetadata", [key, opts]) |> unsafe_cast
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub fn KVNamespace::put(
    |   self : Self,
    |   key : String,
    |   value : String,
    |   options : KVPutOptions?,
    | ) -> Promise[Unit] {
 73 |   match options {
    |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => self.call("put", [key, value]) |> unsafe_cast
    |     Some(opts) => self.call("put", [key, value, opts]) |> unsafe_cast
    |   }
    | }
    …

    | pub fn KVNamespace::put_with_metadata(
    |   self : Self,
    |   key : String,
    |   value : String,
    |   metadata : Js,
    | ) -> Promise[Unit] {
 87 |   let opts_js = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   opts_js.set("metadata", metadata)
    |   self.call("put", [key, value, opts_js]) |> unsafe_cast
    | }
    …

    | pub fn KVNamespace::delete(self : Self, key : String) -> Promise[Unit] {
 95 |   self.call("delete", [key]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn KVNamespace::list(
    |   self : Self,
    |   options : KVListOptions?,
    | ) -> Promise[KVListResult] {
104 |   match options {
    |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => self.call0("list") |> unsafe_cast
    |     Some(opts) => self.call("list", [opts.to_js()]) |> unsafe_cast
    |   }
    | }
    …

    | pub impl JsImpl for KVGetOptions with to_js(self) {
119 |   let obj = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match self.type_ {
    |     Some(t) => obj.set("type", t)
    |     None => ()
    |   }
124 |   match self.cache_ttl {
    |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(ttl) => obj.set("cacheTtl", ttl)
    |     None => ()
    |   }
128 |   obj.to_js()
    |   ^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl JsImpl for KVPutOptions with to_js(self) {
141 |   let obj = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match self.expiration {
    |     Some(exp) => obj.set("expiration", exp)
    |     None => ()
    |   }
146 |   match self.expiration_ttl {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(ttl) => obj.set("expirationTtl", ttl)
    |     None => ()
    |   }
150 |   match self.metadata {
    |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(meta) => obj.set("metadata", meta)
    |     None => ()
    |   }
154 |   obj.to_js()
    |   ^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl JsImpl for KVListOptions with to_js(self) {
167 |   let obj = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match self.prefix {
    |     Some(p) => obj.set("prefix", p)
    |     None => ()
    |   }
172 |   match self.limit {
    |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(l) => obj.set("limit", l)
    |     None => ()
    |   }
176 |   match self.cursor {
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(c) => obj.set("cursor", c)
    |     None => ()
    |   }
180 |   obj.to_js()
    |   ^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

73 uncovered line(s) in src/cloudflare/r2.mbt:

    | pub fn R2Bucket::get(self : Self, key : String) -> Promise[R2Object?] {
 13 |   self.call("get", [key]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Bucket::get_with_options(
    |   self : Self,
    |   key : String,
    |   options : R2GetOptions,
    | ) -> Promise[R2Object?] {
 23 |   self.call("get", [key, options]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Bucket::head(self : Self, key : String) -> Promise[R2Object?] {
 29 |   self.call("head", [key]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Bucket::put(
    |   self : Self,
    |   key : String,
    |   value : Js,
    | ) -> Promise[R2Object] {
 39 |   self.call("put", [key, value]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Bucket::put_with_options(
    |   self : Self,
    |   key : String,
    |   value : Js,
    |   options : R2PutOptions,
    | ) -> Promise[R2Object] {
 50 |   self.call("put", [key, value, options]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Bucket::delete(self : Self, key : String) -> Promise[Unit] {
 56 |   self.call("delete", [key]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Bucket::delete_multiple(
    |   self : Self,
    |   keys : Array[String],
    | ) -> Promise[Unit] {
 65 |   let keys_js = @js.JsArray::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let mut i = 0
    |   while i < keys.length() {
 68 |     keys_js.call("push", [keys[i]]) |> ignore
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     i = i + 1
    |   }
 71 |   self.call("delete", [keys_js]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Bucket::list(self : Self) -> Promise[R2Objects] {
 77 |   self.call("list", []) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Bucket::list_with_options(
    |   self : Self,
    |   options : R2ListOptions,
    | ) -> Promise[R2Objects] {
 86 |   self.call("list", [options]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Bucket::create_multipart_upload(
    |   self : Self,
    |   key : String,
    | ) -> Promise[R2MultipartUpload] {
 95 |   self.call("createMultipartUpload", [key]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Bucket::create_multipart_upload_with_options(
    |   self : Self,
    |   key : String,
    |   options : R2PutOptions,
    | ) -> Promise[R2MultipartUpload] {
105 |   self.call("createMultipartUpload", [key, options]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Bucket::resume_multipart_upload(
    |   self : Self,
    |   key : String,
    |   upload_id : String,
    | ) -> R2MultipartUpload {
115 |   self.call("resumeMultipartUpload", [key, upload_id]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl JsImpl for R2GetOptions with to_js(self) {
127 |   let obj = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match self.only_if {
    |     Some(cond) => {
    |       let cond_obj = @js.Object::new()
    |       match cond.etag_matches {
    |         Some(etag) => cond_obj.set("etagMatches", etag)
    |         None => ()
    |       }
135 |       match cond.etag_does_not_match {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Some(etag) => cond_obj.set("etagDoesNotMatch", etag)
    |         None => ()
    |       }
139 |       match cond.uploaded_before {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Some(date) => cond_obj.set("uploadedBefore", date)
    |         None => ()
    |       }
143 |       match cond.uploaded_after {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Some(date) => cond_obj.set("uploadedAfter", date)
    |         None => ()
    |       }
147 |       obj.set("onlyIf", cond_obj)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
149 |     None => ()
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
151 |   match self.range {
    |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(r) => {
    |       let range_obj = @js.Object::new()
    |       match r.offset {
    |         Some(offset) => range_obj.set("offset", offset)
    |         None => ()
    |       }
158 |       match r.length {
    |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Some(length) => range_obj.set("length", length)
    |         None => ()
    |       }
162 |       match r.suffix {
    |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Some(suffix) => range_obj.set("suffix", suffix)
    |         None => ()
    |       }
166 |       obj.set("range", range_obj)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
168 |     None => ()
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
170 |   obj.to_js()
    |   ^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl JsImpl for R2PutOptions with to_js(self) {
204 |   let obj = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match self.http_metadata {
    |     Some(meta) => obj.set("httpMetadata", meta.to_js())
    |     None => ()
    |   }
209 |   match self.custom_metadata {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(meta) => obj.set("customMetadata", meta)
    |     None => ()
    |   }
213 |   match self.md5 {
    |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(hash) => obj.set("md5", hash)
    |     None => ()
    |   }
217 |   match self.sha1 {
    |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(hash) => obj.set("sha1", hash)
    |     None => ()
    |   }
221 |   match self.sha256 {
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(hash) => obj.set("sha256", hash)
    |     None => ()
    |   }
225 |   match self.sha384 {
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(hash) => obj.set("sha384", hash)
    |     None => ()
    |   }
229 |   match self.sha512 {
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(hash) => obj.set("sha512", hash)
    |     None => ()
    |   }
233 |   obj.to_js()
    |   ^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl JsImpl for R2HttpMetadata with to_js(self) {
249 |   let obj = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match self.content_type {
    |     Some(val) => obj.set("contentType", val)
    |     None => ()
    |   }
254 |   match self.content_language {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(val) => obj.set("contentLanguage", val)
    |     None => ()
    |   }
258 |   match self.content_disposition {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(val) => obj.set("contentDisposition", val)
    |     None => ()
    |   }
262 |   match self.content_encoding {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(val) => obj.set("contentEncoding", val)
    |     None => ()
    |   }
266 |   match self.cache_control {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(val) => obj.set("cacheControl", val)
    |     None => ()
    |   }
270 |   match self.cache_expiry {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(val) => obj.set("cacheExpiry", val)
    |     None => ()
    |   }
274 |   obj.to_js()
    |   ^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl JsImpl for R2ListOptions with to_js(self) {
290 |   let obj = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match self.limit {
    |     Some(l) => obj.set("limit", l)
    |     None => ()
    |   }
295 |   match self.prefix {
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(p) => obj.set("prefix", p)
    |     None => ()
    |   }
299 |   match self.cursor {
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(c) => obj.set("cursor", c)
    |     None => ()
    |   }
303 |   match self.delimiter {
    |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(d) => obj.set("delimiter", d)
    |     None => ()
    |   }
307 |   match self.start_after {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(s) => obj.set("startAfter", s)
    |     None => ()
    |   }
311 |   match self.include_ {
    |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(inc) => {
    |       let arr = @js.JsArray::new()
    |       let mut i = 0
    |       while i < inc.length() {
316 |         arr.call("push", [inc[i]]) |> ignore
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         i = i + 1
    |       }
319 |       obj.set("include", arr)
    |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
321 |     None => ()
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
323 |   obj.to_js()
    |   ^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Object::key(self : Self) -> String {
337 |   unsafe_cast(self.get("key"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Object::version(self : Self) -> String {
343 |   unsafe_cast(self.get("version"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Object::size(self : Self) -> Int {
349 |   unsafe_cast(self.get("size"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Object::etag(self : Self) -> String {
355 |   unsafe_cast(self.get("etag"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Object::http_metadata(self : Self) -> Js {
361 |   self.get("httpMetadata")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Object::custom_metadata(self : Self) -> Js {
367 |   self.get("customMetadata")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Object::uploaded(self : Self) -> Js {
373 |   self.get("uploaded")
    |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Object::array_buffer(self : Self) -> Promise[Js] {
379 |   self.call("arrayBuffer", []) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Object::text(self : Self) -> Promise[String] {
385 |   self.call("text", []) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Object::json(self : Self) -> Promise[Js] {
391 |   self.call("json", []) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Object::blob(self : Self) -> Promise[Js] {
397 |   self.call("blob", []) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Object::body(self : Self) -> Js {
403 |   self.get("body")
    |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Object::body_used(self : Self) -> Bool {
409 |   unsafe_cast(self.get("bodyUsed"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2Object::write_http_metadata(self : Self, headers : Js) -> Unit {
415 |   self.call("writeHttpMetadata", [headers]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2MultipartUpload::key(self : Self) -> String {
441 |   unsafe_cast(self.get("key"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2MultipartUpload::upload_id(self : Self) -> String {
447 |   unsafe_cast(self.get("uploadId"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2MultipartUpload::upload_part(
    |   self : Self,
    |   part_number : Int,
    |   value : Js,
    | ) -> Promise[R2UploadedPart] {
457 |   self.call("uploadPart", [part_number, value]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2MultipartUpload::abort(self : Self) -> Promise[Unit] {
463 |   self.call("abort", []) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn R2MultipartUpload::complete(
    |   self : Self,
    |   parts : Array[R2UploadedPart],
    | ) -> Promise[R2Object] {
472 |   let parts_js = @js.JsArray::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let mut i = 0
    |   while i < parts.length() {
475 |     parts_js.call("push", [parts[i]]) |> ignore
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     i = i + 1
    |   }
478 |   self.call("complete", [parts_js]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl JsImpl for R2UploadedPart with to_js(self) {
490 |   let obj = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   obj.set("partNumber", self.part_number)
    |   obj.set("etag", self.etag)
    |   obj.to_js()
    | }
    …

22 uncovered line(s) in src/crypto/crypto.mbt:

    | pub fn SubtleCrypto::encrypt(
    |   self : Self,
    |   algorithm : &JsImpl,
    |   key : &JsImpl,
    |   data : &JsImpl,
    | ) -> Promise[Js] {
 17 |   unsafe_cast(
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self.to_js().call("encrypt", [algorithm.to_js(), key.to_js(), data.to_js()]),
    |   )
    | }
    …

    | pub fn SubtleCrypto::decrypt(
    |   self : Self,
    |   algorithm : &JsImpl,
    |   key : &JsImpl,
    |   data : &JsImpl,
    | ) -> Promise[Js] {
 29 |   unsafe_cast(
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self.to_js().call("decrypt", [algorithm.to_js(), key.to_js(), data.to_js()]),
    |   )
    | }
    …

    | pub fn SubtleCrypto::sign(
    |   self : Self,
    |   algorithm : &JsImpl,
    |   key : &JsImpl,
    |   data : &JsImpl,
    | ) -> Promise[Js] {
 42 |   unsafe_cast(self.call("sign", [algorithm.to_js(), key.to_js(), data.to_js()]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SubtleCrypto::verify(
    |   self : Self,
    |   algorithm : &JsImpl,
    |   key : &JsImpl,
    |   signature : &JsImpl,
    |   data : &JsImpl,
    | ) -> Promise[Bool] {
 53 |   unsafe_cast(
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self
 55 |     .to_js()
    |     ^^^^^^^^ 	<-- UNCOVERED
    |     .call("verify", [
    |       algorithm.to_js(),
    |       key.to_js(),
    |       signature.to_js(),
    |       data.to_js(),
    |     ]),
    |   )
    | }
    …

    | pub fn SubtleCrypto::digest(
    |   self : Self,
    |   algorithm : String,
    |   data : &JsImpl,
    | ) -> Promise[Js] {
 72 |   self.call("digest", [algorithm |> js, data.to_js()]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(generate_key)
    | pub fn SubtleCrypto::generateKey(
    |   self : Self,
    |   algorithm : &JsImpl,
    |   extractable : Bool,
    |   key_usages : Array[String],
    | ) -> Promise[Js] {
 84 |   unsafe_cast(
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self
 86 |     .to_js()
    |     ^^^^^^^^ 	<-- UNCOVERED
    |     .call("generateKey", [algorithm, extractable, key_usages |> @js.from_array]),
    |   )
    | }
    …

    | #alias(derive_key)
    | pub fn SubtleCrypto::deriveKey(
    |   self : Self,
    |   algorithm : &JsImpl,
    |   base_key : &JsImpl,
    |   derived_key_type : &JsImpl,
    |   extractable : Bool,
    |   key_usages : Array[String],
    | ) -> Promise[Js] {
101 |   unsafe_cast(
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self
103 |     .to_js()
    |     ^^^^^^^^ 	<-- UNCOVERED
    |     .call("deriveKey", [
    |       algorithm,
    |       base_key,
    |       derived_key_type,
    |       extractable,
109 |       key_usages |> @js.from_array,
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ]),
    |   )
    | }
    …

    | #alias(derive_bits)
    | pub fn SubtleCrypto::deriveBits(
    |   self : Self,
    |   algorithm : &JsImpl,
    |   base_key : &JsImpl,
    |   length : Int,
    | ) -> Promise[Js] {
122 |   unsafe_cast(self.call("deriveBits", [algorithm, base_key, length]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(import_key)
    | pub fn SubtleCrypto::importKey(
    |   self : Self,
    |   format : String,
    |   key_data : &JsImpl,
    |   algorithm : &JsImpl,
    |   extractable : Bool,
    |   key_usages : Array[String],
    | ) -> Promise[Js] {
136 |   unsafe_cast(
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self
138 |     .to_js()
    |     ^^^^^^^^ 	<-- UNCOVERED
    |     .call("importKey", [
    |       format,
    |       key_data,
    |       algorithm,
    |       extractable,
144 |       key_usages |> @js.from_array,
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ]),
    |   )
    | }
    …

    | #alias(export_key)
    | pub fn SubtleCrypto::exportKey(
    |   self : Self,
    |   format : String,
    |   key : &JsImpl,
    | ) -> Promise[Js] {
156 |   self.call("exportKey", [format, key]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(wrap_key)
    | pub fn SubtleCrypto::wrapKey(
    |   self : Self,
    |   format : String,
    |   key : &JsImpl,
    |   wrapping_key : &JsImpl,
    |   wrap_algorithm : &JsImpl,
    | ) -> Promise[Js] {
169 |   unsafe_cast(
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self.to_js().call("wrapKey", [format, key, wrapping_key, wrap_algorithm]),
    |   )
    | }
    …

    | #alias(unwrap_key)
    | pub fn SubtleCrypto::unwrapKey(
    |   self : Self,
    |   format : String,
    |   wrapped_key : &JsImpl,
    |   unwrapping_key : &JsImpl,
    |   unwrap_algorithm : &JsImpl,
    |   unwrapped_key_algorithm : &JsImpl,
    |   extractable : Bool,
    |   key_usages : Array[String],
    | ) -> Promise[Js] {
186 |   unsafe_cast(
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     self
188 |     .to_js()
    |     ^^^^^^^^ 	<-- UNCOVERED
    |     .call("unwrapKey", [
    |       format,
    |       wrapped_key,
    |       unwrapping_key,
    |       unwrap_algorithm,
    |       unwrapped_key_algorithm,
    |       extractable,
196 |       key_usages |> @js.from_array,
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ]),
    |   )
    | }
    …

    | pub fn Crypto::subtle(self : Self) -> SubtleCrypto {
212 |   unsafe_cast(self.get("subtle"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(get_crypto)
    | pub fn getCrypto() -> Crypto {
223 |   unsafe_cast(ffi_get_crypto())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

1 uncovered line(s) in src/deno/deno.mbt:

   | pub fn Deno::test_(
   |   self : Self,
   |   name : String,
   |   f : (TestContext) -> Unit,
   | ) -> Unit {
27 |   self.call("test", [name, @js.from_fn1(f)]) |> ignore
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

3 uncovered line(s) in src/dom/blob/blob.mbt:

   | pub fn Blob::slice(
   |   self : Self,
   |   start? : Int,
   |   end? : Int,
   |   content_type? : String,
   | ) -> Blob {
   |   match (start, end, content_type) {
   |     (None, None, None) => self.call("slice", []) |> unsafe_cast
   |     (Some(s), None, None) => self.call("slice", [s]) |> unsafe_cast
   |     (Some(s), Some(e), None) => self.call("slice", [s, e]) |> unsafe_cast
   |     (Some(s), Some(e), Some(ct)) =>
72 |       self.call("slice", [s, e, ct]) |> unsafe_cast
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     (None, Some(e), ct) =>
74 |       match ct {
   |       ^^^^^^^^^^ 	<-- UNCOVERED
   |         Some(t) => self.call("slice", [0, e, t]) |> unsafe_cast
   |         None => self.call("slice", [0, e]) |> unsafe_cast
   |       }
78 |     (Some(s), None, Some(ct)) => {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       let size = self.size()
   |       self.call("slice", [s, size, ct]) |> unsafe_cast
   |     }
   |     (None, None, Some(ct)) => {
   |       let size = self.size()
   |       self.call("slice", [0, size, ct]) |> unsafe_cast
   |     }
   |   }
   | }
   …

61 uncovered line(s) in src/dom/canvas/canvas.mbt:

    | pub fn CanvasRenderingContext2D::canvas(self : Self) -> HTMLCanvasElement {
 12 |   unsafe_cast(self.get("canvas"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::fillStyle(self : Self) -> String {
 17 |   unsafe_cast(self.get("fillStyle"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::setFillStyle(
    |   self : Self,
    |   value : String,
    | ) -> Unit {
 25 |   self.set("fillStyle", value)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::strokeStyle(self : Self) -> String {
 30 |   unsafe_cast(self.get("strokeStyle"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::setStrokeStyle(
    |   self : Self,
    |   value : String,
    | ) -> Unit {
 38 |   self.set("strokeStyle", value)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::lineWidth(self : Self) -> Double {
 43 |   unsafe_cast(self.get("lineWidth"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::setLineWidth(
    |   self : Self,
    |   value : Double,
    | ) -> Unit {
 51 |   self.set("lineWidth", value)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::font(self : Self) -> String {
 56 |   unsafe_cast(self.get("font"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::setFont(self : Self, value : String) -> Unit {
 61 |   self.set("font", value)
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::textAlign(self : Self) -> String {
 66 |   unsafe_cast(self.get("textAlign"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::setTextAlign(
    |   self : Self,
    |   value : String,
    | ) -> Unit {
 74 |   self.set("textAlign", value)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::textBaseline(self : Self) -> String {
 79 |   unsafe_cast(self.get("textBaseline"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::setTextBaseline(
    |   self : Self,
    |   value : String,
    | ) -> Unit {
 87 |   self.set("textBaseline", value)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::globalAlpha(self : Self) -> Double {
 92 |   unsafe_cast(self.get("globalAlpha"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::setGlobalAlpha(
    |   self : Self,
    |   value : Double,
    | ) -> Unit {
100 |   self.set("globalAlpha", value)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(fill_rect)
    | pub fn CanvasRenderingContext2D::fillRect(
    |   self : Self,
    |   x : Double,
    |   y : Double,
    |   width : Double,
    |   height : Double,
    | ) -> Unit {
113 |   self.call("fillRect", [x, y, width, height]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(stroke_rect)
    | pub fn CanvasRenderingContext2D::strokeRect(
    |   self : Self,
    |   x : Double,
    |   y : Double,
    |   width : Double,
    |   height : Double,
    | ) -> Unit {
125 |   self.call("strokeRect", [x, y, width, height]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(clear_rect)
    | pub fn CanvasRenderingContext2D::clearRect(
    |   self : Self,
    |   x : Double,
    |   y : Double,
    |   width : Double,
    |   height : Double,
    | ) -> Unit {
137 |   self.call("clearRect", [x, y, width, height]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(begin_path)
    | pub fn CanvasRenderingContext2D::beginPath(self : Self) -> Unit {
144 |   self.call("beginPath", []) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(close_path)
    | pub fn CanvasRenderingContext2D::closePath(self : Self) -> Unit {
150 |   self.call("closePath", []) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(move_to)
    | pub fn CanvasRenderingContext2D::moveTo(
    |   self : Self,
    |   x : Double,
    |   y : Double,
    | ) -> Unit {
160 |   self.call("moveTo", [x, y]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(line_to)
    | pub fn CanvasRenderingContext2D::lineTo(
    |   self : Self,
    |   x : Double,
    |   y : Double,
    | ) -> Unit {
170 |   self.call("lineTo", [x, y]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::arc(
    |   self : Self,
    |   x : Double,
    |   y : Double,
    |   radius : Double,
    |   start_angle : Double,
    |   end_angle : Double,
    |   counterclockwise? : Bool,
    | ) -> Unit {
183 |   match counterclockwise {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(ccw) =>
185 |       self.call("arc", [x, y, radius, start_angle, end_angle, ccw]) |> ignore
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => self.call("arc", [x, y, radius, start_angle, end_angle]) |> ignore
    |   }
    | }
    …

    | pub fn CanvasRenderingContext2D::arcTo(
    |   self : Self,
    |   x1 : Double,
    |   y1 : Double,
    |   x2 : Double,
    |   y2 : Double,
    |   radius : Double,
    | ) -> Unit {
199 |   self.call("arcTo", [x1, y1, x2, y2, radius]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::bezierCurveTo(
    |   self : Self,
    |   cp1x : Double,
    |   cp1y : Double,
    |   cp2x : Double,
    |   cp2y : Double,
    |   x : Double,
    |   y : Double,
    | ) -> Unit {
212 |   self.call("bezierCurveTo", [cp1x, cp1y, cp2x, cp2y, x, y]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::quadraticCurveTo(
    |   self : Self,
    |   cpx : Double,
    |   cpy : Double,
    |   x : Double,
    |   y : Double,
    | ) -> Unit {
223 |   self.call("quadraticCurveTo", [cpx, cpy, x, y]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::rect(
    |   self : Self,
    |   x : Double,
    |   y : Double,
    |   width : Double,
    |   height : Double,
    | ) -> Unit {
234 |   self.call("rect", [x, y, width, height]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::fill(self : Self) -> Unit {
239 |   self.call("fill", []) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::stroke(self : Self) -> Unit {
244 |   self.call("stroke", []) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::clip(self : Self) -> Unit {
249 |   self.call("clip", []) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::fillText(
    |   self : Self,
    |   text : String,
    |   x : Double,
    |   y : Double,
    |   max_width? : Double,
    | ) -> Unit {
261 |   match max_width {
    |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(w) => self.call("fillText", [text, x, y, w]) |> ignore
    |     None => self.call("fillText", [text, x, y]) |> ignore
    |   }
    | }
    …

    | pub fn CanvasRenderingContext2D::strokeText(
    |   self : Self,
    |   text : String,
    |   x : Double,
    |   y : Double,
    |   max_width? : Double,
    | ) -> Unit {
275 |   match max_width {
    |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(w) => self.call("strokeText", [text, x, y, w]) |> ignore
    |     None => self.call("strokeText", [text, x, y]) |> ignore
    |   }
    | }
    …

    | pub fn CanvasRenderingContext2D::measureText(
    |   self : Self,
    |   text : String,
    | ) -> TextMetrics {
286 |   self.call("measureText", [text]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::scale(
    |   self : Self,
    |   x : Double,
    |   y : Double,
    | ) -> Unit {
296 |   self.call("scale", [x, y]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::rotate(self : Self, angle : Double) -> Unit {
301 |   self.call("rotate", [angle]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::translate(
    |   self : Self,
    |   x : Double,
    |   y : Double,
    | ) -> Unit {
310 |   self.call("translate", [x, y]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::transform(
    |   self : Self,
    |   a : Double,
    |   b : Double,
    |   c : Double,
    |   d : Double,
    |   e : Double,
    |   f : Double,
    | ) -> Unit {
323 |   self.call("transform", [a, b, c, d, e, f]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::setTransform(
    |   self : Self,
    |   a : Double,
    |   b : Double,
    |   c : Double,
    |   d : Double,
    |   e : Double,
    |   f : Double,
    | ) -> Unit {
336 |   self.call("setTransform", [a, b, c, d, e, f]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::resetTransform(self : Self) -> Unit {
341 |   self.call("resetTransform", []) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::drawImage(
    |   self : Self,
    |   image : &JsImpl,
    |   dx : Double,
    |   dy : Double,
    | ) -> Unit {
352 |   self.call("drawImage", [image.to_js(), dx, dy]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::drawImageScaled(
    |   self : Self,
    |   image : &JsImpl,
    |   dx : Double,
    |   dy : Double,
    |   d_width : Double,
    |   d_height : Double,
    | ) -> Unit {
364 |   self.call("drawImage", [image.to_js(), dx, dy, d_width, d_height]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::drawImageSub(
    |   self : Self,
    |   image : &JsImpl,
    |   sx : Double,
    |   sy : Double,
    |   s_width : Double,
    |   s_height : Double,
    |   dx : Double,
    |   dy : Double,
    |   d_width : Double,
    |   d_height : Double,
    | ) -> Unit {
380 |   self
    |   ^^^^ 	<-- UNCOVERED
    |   .to_js()
    |   .call("drawImage", [
    |     image.to_js(),
    |     sx,
    |     sy,
    |     s_width,
    |     s_height,
    |     dx,
    |     dy,
    |     d_width,
    |     d_height,
    |   ])
393 |   |> ignore
    |   ^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::getImageData(
    |   self : Self,
    |   sx : Double,
    |   sy : Double,
    |   sw : Double,
    |   sh : Double,
    | ) -> ImageData {
405 |   self.call("getImageData", [sx, sy, sw, sh]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::putImageData(
    |   self : Self,
    |   image_data : ImageData,
    |   dx : Double,
    |   dy : Double,
    | ) -> Unit {
415 |   self.call("putImageData", [image_data.to_js(), dx, dy]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::createImageData(
    |   self : Self,
    |   width : Int,
    |   height : Int,
    | ) -> ImageData {
424 |   self.call("createImageData", [width, height]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::save(self : Self) -> Unit {
430 |   self.call("save", []) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CanvasRenderingContext2D::restore(self : Self) -> Unit {
435 |   self.call("restore", []) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn TextMetrics::width(self : Self) -> Double {
448 |   unsafe_cast(self.get("width"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ImageData::new(width : Int, height : Int) -> ImageData {
473 |   unsafe_cast(ffi_new_image_data(width |> js, height |> js))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ImageData::from_data(
    |   data : Uint8Array,
    |   width : Int,
    |   height : Int,
    | ) -> ImageData {
482 |   unsafe_cast(
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ffi_new_image_data_with_data(data.to_js(), width |> js, height |> js),
    |   )
    | }
    …

    | pub fn ImageData::width(self : Self) -> Int {
489 |   unsafe_cast(self.get("width"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ImageData::height(self : Self) -> Int {
494 |   unsafe_cast(self.get("height"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ImageData::data(self : Self) -> Uint8Array {
499 |   unsafe_cast(self.get("data"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl Transferable for ImageBitmap with to_transferable(self) -> Js {
512 |   self.to_js()
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ImageBitmap::width(self : Self) -> Int {
517 |   unsafe_cast(self.get("width"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ImageBitmap::height(self : Self) -> Int {
522 |   unsafe_cast(self.get("height"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ImageBitmap::close(self : Self) -> Unit {
527 |   self.call("close", []) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(create_image_bitmap)
    | pub fn createImageBitmap(image : &JsImpl) -> ImageBitmap {
548 |   unsafe_cast(ffi_create_image_bitmap(image.to_js()))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(create_image_bitmap_rect)
    | pub fn createImageBitmapRect(
    |   image : &JsImpl,
    |   sx : Int,
    |   sy : Int,
    |   sw : Int,
    |   sh : Int,
    | ) -> Promise[ImageBitmap] {
560 |   unsafe_cast(
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ffi_create_image_bitmap_with_rect(
    |       image.to_js(),
    |       sx |> js,
    |       sy |> js,
    |       sw |> js,
    |       sh |> js,
    |     ),
    |   )
    | }
    …

9 uncovered line(s) in src/dom/canvas/offscreen_canvas.mbt:

   | pub impl Transferable for OffscreenCanvas with to_transferable(self) -> Js {
11 |   self.to_js()
   |   ^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn OffscreenCanvas::new(width : Int, height : Int) -> OffscreenCanvas {
20 |   unsafe_cast(ffi_new_offscreen_canvas(width |> js, height |> js))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn OffscreenCanvas::width(self : Self) -> Int {
25 |   unsafe_cast(self.get("width"))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn OffscreenCanvas::setWidth(self : Self, value : Int) -> Unit {
30 |   self.set("width", value)
   |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn OffscreenCanvas::height(self : Self) -> Int {
35 |   unsafe_cast(self.get("height"))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn OffscreenCanvas::setHeight(self : Self, value : Int) -> Unit {
40 |   self.set("height", value)
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn OffscreenCanvas::getContext(
   |   self : Self,
   |   context_type : String,
   | ) -> CanvasRenderingContext2D {
48 |   self.call("getContext", [context_type]) |> unsafe_cast
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn OffscreenCanvas::convertToBlob(
   |   self : Self,
   |   options? : String,
   | ) -> Promise[Blob] {
56 |   match options {
   |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     Some(opts) => self.call("convertToBlob", [opts]) |> unsafe_cast
   |     None => self.call("convertToBlob", []) |> unsafe_cast
   |   }
   | }
   …

   | pub fn OffscreenCanvas::transferToImage_bitmap(self : Self) -> ImageBitmap {
64 |   self.call("transferToImageBitmap", []) |> unsafe_cast
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

38 uncovered line(s) in src/dom/css.mbt:

    | pub fn css_style_from_val(val : Js) -> CSSStyleDeclaration {
 17 |   unsafe_cast(val)
    |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleDeclaration::get_property_value(
    |   self : Self,
    |   property : String,
    | ) -> String {
 26 |   self.call("getPropertyValue", [property]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleDeclaration::set_property(
    |   self : Self,
    |   property : String,
    |   value : String,
    | ) -> Unit {
 36 |   self.call("setProperty", [property, value]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleDeclaration::set_property_priority(
    |   self : Self,
    |   property : String,
    |   value : String,
    |   priority : String,
    | ) -> Unit {
 47 |   self.call("setProperty", [property, value, priority]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleDeclaration::remove_property(
    |   self : Self,
    |   property : String,
    | ) -> String {
 56 |   self.call("removeProperty", [property]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleDeclaration::get_property_priority(
    |   self : Self,
    |   property : String,
    | ) -> String {
 65 |   self.call("getPropertyPriority", [property]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleDeclaration::css_text(self : Self) -> String {
 71 |   unsafe_cast(self.get("cssText"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleDeclaration::set_css_text(self : Self, text : String) -> Unit {
 77 |   self.set("cssText", text) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleDeclaration::length(self : Self) -> Int {
 83 |   unsafe_cast(self.get("length"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleDeclaration::parent_rule(self : Self) -> CSSRule? {
 89 |   self.get("parentRule") |> @js.unsafe_cast_option
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSRule::css_text(self : Self) -> String {
104 |   unsafe_cast(self.get("cssText"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSRule::set_css_text(self : Self, text : String) -> Unit {
110 |   self.set("cssText", text) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSRule::parent_rule(self : Self) -> CSSRule? {
116 |   self.get("parentRule") |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSRule::parent_stylesheet(self : Self) -> CSSStyleSheet? {
122 |   self.get("parentStyleSheet") |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSRule::rule_type(self : Self) -> Int {
128 |   unsafe_cast(self.get("type"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleSheet::css_rules(self : Self) -> Js {
144 |   self.get("cssRules")
    |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleSheet::insert_rule(self : Self, rule : String) -> Int {
151 |   self.call("insertRule", [rule]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleSheet::insert_rule_at(
    |   self : Self,
    |   rule : String,
    |   index : Int,
    | ) -> Int {
161 |   self.call("insertRule", [rule, index]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleSheet::delete_rule(self : Self, index : Int) -> Unit {
168 |   self.call("deleteRule", [index]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleSheet::owner_node(self : Self) -> Js? {
174 |   self.get("ownerNode") |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleSheet::disabled(self : Self) -> Bool {
180 |   unsafe_cast(self.get("disabled"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleSheet::set_disabled(self : Self, disabled : Bool) -> Unit {
186 |   self.set("disabled", disabled) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleSheet::href(self : Self) -> String? {
192 |   self.get("href") |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleSheet::title(self : Self) -> String? {
198 |   self.get("title") |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CSSStyleSheet::media(self : Self) -> Js {
204 |   self.get("media")
    |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(match_media)
    | pub fn matchMedia(query : String) -> MediaQueryList {
221 |   unsafe_cast(@js.global_this().call("matchMedia", [query]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MediaQueryList::media(self : Self) -> String {
227 |   unsafe_cast(self.get("media"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MediaQueryList::matches(self : Self) -> Bool {
233 |   unsafe_cast(self.get("matches"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MediaQueryList::add_listener(
    |   self : Self,
    |   listener : (MediaQueryList) -> Unit,
    | ) -> Unit {
243 |   self.call("addListener", [listener |> @js.from_fn1]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MediaQueryList::remove_listener(
    |   self : Self,
    |   listener : (MediaQueryList) -> Unit,
    | ) -> Unit {
253 |   self.call("removeListener", [listener |> @js.from_fn1]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MediaQueryList::add_change_listener(
    |   self : Self,
    |   listener : (Event) -> Unit,
    | ) -> Unit {
262 |   self.call("addEventListener", ["change", listener |> @js.from_fn1]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MediaQueryList::remove_change_listener(
    |   self : Self,
    |   listener : (Event) -> Unit,
    | ) -> Unit {
271 |   self.call("removeEventListener", ["change", listener |> @js.from_fn1])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   |> ignore
    | }
    …

    | #alias(css_escape)
    | pub fn cssEscape(value : String) -> String {
283 |   let css_obj = @js.global_this().get("CSS")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   unsafe_cast(css_obj.call("escape", [value]))
    | }
    …

    | #alias(css_supports)
    | pub fn cssSupports(property : String, value : String) -> Bool {
292 |   let css_obj = @js.global_this().get("CSS")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   unsafe_cast(css_obj.call("supports", [property, value]))
    | }
    …

    | #alias(css_supports_condition)
    | pub fn cssSupportsCondition(condition : String) -> Bool {
300 |   let css_obj = @js.global_this().get("CSS")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   unsafe_cast(css_obj.call("supports", [condition]))
    | }
    …

    | pub fn Document::style_sheets(self : Self) -> Js {
308 |   self.get("styleSheets")
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Document::create_stylesheet(self : Self) -> CSSStyleSheet {
314 |   let style = self.create_element("style")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match self.head() {
    |     Some(head) => head.call("appendChild", [style]) |> ignore
    |     None => ()
    |   }
319 |   unsafe_cast(style.get("sheet"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

9 uncovered line(s) in src/dom/custom_elements.mbt:

    | #alias(custom_elements)
    | pub fn customElements() -> CustomElementRegistry {
 19 |   unsafe_cast(@js.global_this().get("customElements"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CustomElementRegistry::define_(
    |   self : Self,
    |   name : String,
    |   callbacks : CustomElementCallbacks,
    | ) -> Unit {
 62 |   let element_class = create_custom_element_class(callbacks)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ignore(self.call("define", [name, element_class]))
    | }
    …

    | pub fn CustomElementRegistry::define_element_with_attributes(
    |   self : Self,
    |   name : String,
    |   callbacks : CustomElementCallbacks,
    |   observed_attributes : Array[String],
    | ) -> Unit {
101 |   let element_class = create_custom_element_class_with_attributes(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     callbacks, observed_attributes,
    |   )
104 |   ignore(self.call("define", [name, element_class]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CustomElementRegistry::get(self : Self, name : String) -> Js? {
111 |   self.call("get", [name]) |> @js.unsafe_cast_option
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CustomElementRegistry::getName(
    |   self : Self,
    |   element_constructor : Js,
    | ) -> String? {
121 |   self.call("getName", [element_constructor]) |> @js.unsafe_cast_option
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CustomElementRegistry::whenDefined(
    |   self : Self,
    |   name : String,
    | ) -> Promise[Unit] {
131 |   self.call("whenDefined", [name]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CustomElementRegistry::upgrade(self : Self, root : Node) -> Unit {
138 |   ignore(self.call("upgrade", [root.to_js()]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn CustomElementCallbacks::new(
    |   onConnected? : () -> Unit = fn() { () },
    |   onDisconnected? : () -> Unit = fn() { () },
    |   onAdopted? : () -> Unit = fn() { () },
    |   onAttributeChanged? : (String, String?, String?, String?) -> Unit = fn(
    |     _,
    |     _,
    |     _,
    |     _,
    |   ) {
    |     ()
    |   },
    | ) -> CustomElementCallbacks {
156 |   { onConnected, onDisconnected, onAdopted, onAttributeChanged }
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

12 uncovered line(s) in src/dom/document.mbt:

    | #alias(get_elements_by_class_name)
    | pub fn Document::getElementsByClassName(self : Self, class_name : String) -> Js {
 80 |   self.call("getElementsByClassName", [class_name])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(get_elements_by_tag_name)
    | pub fn Document::getElementsByTagName(self : Self, tagName : String) -> Js {
 88 |   self.call("getElementsByTagName", [tagName])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(set_body)
    | pub fn Document::setBody(self : Self, body : HTMLBodyElement) -> Unit {
113 |   self.set("body", body) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Document::url(self : Self) -> String {
141 |   unsafe_cast(self.get("URL"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Document::domain(self : Self) -> String {
148 |   unsafe_cast(self.get("domain"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Document::referrer(self : Self) -> String {
155 |   unsafe_cast(self.get("referrer"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(document_uri)
    | pub fn Document::documentURI(self : Self) -> String {
187 |   unsafe_cast(self.get("documentURI"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Document::doctype(self : Self) -> Js? {
210 |   self.get("doctype") |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(adopt_node)
    | pub fn Document::adoptNode(self : Self, node : Node) -> Node {
218 |   self.call("adoptNode", [node.to_js()]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(import_node)
    | pub fn Document::importNode(self : Self, node : Node, deep : Bool) -> Node {
226 |   self.call("importNode", [node.to_js(), deep]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Document::elementFromPoint(
    |   self : Self,
    |   x : Double,
    |   y : Double,
    | ) -> Element? {
245 |   self.call("elementFromPoint", [x, y]) |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Document::elementsFromPoint(
    |   self : Self,
    |   x : Double,
    |   y : Double,
    | ) -> Array[Element] {
256 |   @js.array_from(self.call("elementsFromPoint", [x, y])).map(fn(v) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     unsafe_cast(v)
    |   })
    | }
    …

1 uncovered line(s) in src/dom/element.mbt:

    | impl ElementImpl with removeAttribute(self, name) -> Unit {
 78 |   ignore(self.call("removeAttribute", [name]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

77 uncovered line(s) in src/dom/event.mbt:

    | impl EventImpl with preventDefault(self) -> Unit {
 17 |   ignore(self.call("preventDefault", []))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | impl EventImpl with stopPropagation(self) -> Unit {
 22 |   ignore(self.call("stopPropagation", []))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | impl EventImpl with stopImmediatePropagation(self) -> Unit {
 27 |   ignore(self.call("stopImmediatePropagation", []))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | impl EventImpl with target(self) -> Element {
 32 |   unsafe_cast(self.get("target"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | impl EventImpl with currentTarget(self) -> Element {
 37 |   unsafe_cast(self.get("currentTarget"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | impl EventImpl with eventType(self) -> String {
 42 |   unsafe_cast(self.get("type"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | impl EventImpl with bubbles(self) -> Bool {
 47 |   unsafe_cast(self.get("bubbles"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | impl EventImpl with cancelable(self) -> Bool {
 52 |   unsafe_cast(self.get("cancelable"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | impl EventImpl with defaultPrevented(self) -> Bool {
 57 |   unsafe_cast(self.get("defaultPrevented"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn PointerEvent::width(self : Self) -> Double {
 87 |   unsafe_cast(self.get("width"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn PointerEvent::height(self : Self) -> Double {
 93 |   unsafe_cast(self.get("height"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn PointerEvent::pointer_id(self : Self) -> Int {
 99 |   unsafe_cast(self.get("pointerId"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn PointerEvent::pointer_type(self : Self) -> String {
105 |   unsafe_cast(self.get("pointerType"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn PointerEvent::is_primary(self : Self) -> Bool {
111 |   unsafe_cast(self.get("isPrimary"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MouseEvent::clientX(self : Self) -> Int {
130 |   unsafe_cast(self.get("clientX"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MouseEvent::clientY(self : Self) -> Int {
137 |   unsafe_cast(self.get("clientY"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MouseEvent::screenX(self : MouseEvent) -> Int {
144 |   unsafe_cast(self.get("screenX"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MouseEvent::screenY(self : MouseEvent) -> Int {
151 |   unsafe_cast(self.get("screenY"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MouseEvent::offsetX(self : Self) -> Int {
158 |   unsafe_cast(self.get("offsetX"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MouseEvent::offsetY(self : Self) -> Int {
165 |   unsafe_cast(self.get("offsetY"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MouseEvent::pageX(self : Self) -> Int {
172 |   unsafe_cast(self.get("pageX"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MouseEvent::pageY(self : Self) -> Int {
179 |   unsafe_cast(self.get("pageY"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MouseEvent::button(self : Self) -> Int {
186 |   unsafe_cast(self.get("button"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MouseEvent::buttons(self : Self) -> Int {
193 |   unsafe_cast(self.get("buttons"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MouseEvent::ctrlKey(self : Self) -> Bool {
199 |   unsafe_cast(self.get("ctrlKey"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MouseEvent::shiftKey(self : Self) -> Bool {
205 |   unsafe_cast(self.get("shiftKey"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MouseEvent::altKey(self : Self) -> Bool {
211 |   unsafe_cast(self.get("altKey"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MouseEvent::metaKey(self : Self) -> Bool {
217 |   unsafe_cast(self.get("metaKey"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn KeyboardEvent::key(self : KeyboardEvent) -> String {
236 |   unsafe_cast(self.get("key"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn KeyboardEvent::keyCode(self : KeyboardEvent) -> Int {
243 |   unsafe_cast(self.get("keyCode"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn KeyboardEvent::which(self : KeyboardEvent) -> Int {
249 |   unsafe_cast(self.get("which"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn KeyboardEvent::code(self : KeyboardEvent) -> String {
256 |   unsafe_cast(self.get("code"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn KeyboardEvent::ctrl_key(self : KeyboardEvent) -> Bool {
262 |   unsafe_cast(self.get("ctrlKey"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn KeyboardEvent::altKey(self : KeyboardEvent) -> Bool {
268 |   unsafe_cast(self.get("altKey"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn KeyboardEvent::shiftKey(self : KeyboardEvent) -> Bool {
274 |   unsafe_cast(self.get("shiftKey"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn KeyboardEvent::metaKey(self : KeyboardEvent) -> Bool {
280 |   unsafe_cast(self.get("metaKey"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn KeyboardEvent::repeat(self : KeyboardEvent) -> Bool {
286 |   unsafe_cast(self.get("repeat"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn KeyboardEvent::location(self : KeyboardEvent) -> Int {
292 |   unsafe_cast(self.get("location"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn FocusEvent::relatedTarget(self : FocusEvent) -> Element? {
321 |   self.get("relatedTarget") |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn FormEvent::formData(self : FormEvent) -> Js {
338 |   self.get("formData")
    |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DragEvent::dataTransfer(self : Self) -> Js {
357 |   self.get("dataTransfer")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn InputEvent::data(self : Self) -> String? {
375 |   self.get("data") |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn InputEvent::inputType(self : Self) -> String {
381 |   unsafe_cast(self.get("inputType"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn WheelEvent::delta_x(self : Self) -> Double {
399 |   unsafe_cast(self.get("deltaX"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn WheelEvent::delta_y(self : Self) -> Double {
405 |   unsafe_cast(self.get("deltaY"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn WheelEvent::delta_z(self : Self) -> Double {
411 |   unsafe_cast(self.get("deltaZ"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn WheelEvent::delta_mode(self : Self) -> Int {
417 |   unsafe_cast(self.get("deltaMode"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn TouchEvent::touches(self : Self) -> Js {
436 |   self.get("touches")
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn TouchEvent::targetTouches(self : Self) -> Js {
443 |   self.get("targetTouches")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn TouchEvent::changedTouches(self : Self) -> Js {
450 |   self.get("changedTouches")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn TouchEvent::altKey(self : Self) -> Bool {
456 |   unsafe_cast(self.get("altKey"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn TouchEvent::ctrlKey(self : Self) -> Bool {
462 |   unsafe_cast(self.get("ctrlKey"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn TouchEvent::shiftKey(self : Self) -> Bool {
468 |   unsafe_cast(self.get("shiftKey"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn TouchEvent::metaKey(self : Self) -> Bool {
474 |   unsafe_cast(self.get("metaKey"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Touch::identifier(self : Self) -> Int {
489 |   unsafe_cast(self.get("identifier"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Touch::clientX(self : Self) -> Double {
495 |   unsafe_cast(self.get("clientX"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Touch::clientY(self : Self) -> Double {
501 |   unsafe_cast(self.get("clientY"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Touch::screenX(self : Self) -> Double {
507 |   unsafe_cast(self.get("screenX"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Touch::screenY(self : Self) -> Double {
513 |   unsafe_cast(self.get("screenY"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Touch::pageX(self : Self) -> Double {
519 |   unsafe_cast(self.get("pageX"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Touch::pageY(self : Self) -> Double {
525 |   unsafe_cast(self.get("pageY"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Touch::radiusX(self : Self) -> Double {
531 |   unsafe_cast(self.get("radiusX"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Touch::radiusY(self : Self) -> Double {
537 |   unsafe_cast(self.get("radiusY"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Touch::rotationAngle(self : Self) -> Double {
543 |   unsafe_cast(self.get("rotationAngle"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Touch::force(self : Self) -> Double {
549 |   unsafe_cast(self.get("force"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Touch::target(self : Self) -> Element {
555 |   unsafe_cast(self.get("target"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ClipboardEvent::clipboardData(self : Self) -> Js? {
574 |   self.get("clipboardData") |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn TransitionEvent::propertyName(self : Self) -> String {
592 |   unsafe_cast(self.get("propertyName"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn TransitionEvent::elapsedTime(self : Self) -> Double {
598 |   unsafe_cast(self.get("elapsedTime"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn TransitionEvent::pseudoElement(self : Self) -> String {
604 |   unsafe_cast(self.get("pseudoElement"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn AnimationEvent::animationName(self : Self) -> String {
622 |   unsafe_cast(self.get("animationName"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn AnimationEvent::elapsedTime(self : Self) -> Double {
628 |   unsafe_cast(self.get("elapsedTime"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn AnimationEvent::pseudoElement(self : Self) -> String {
634 |   unsafe_cast(self.get("pseudoElement"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MessageEvent::data(self : Self) -> Js {
664 |   unsafe_cast(self.get("data"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MessageEvent::origin(self : Self) -> String {
671 |   unsafe_cast(self.get("origin"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MessageEvent::source(self : Self) -> Window? {
678 |   self.get("source") |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MessageEvent::ports(self : Self) -> Array[Js] {
685 |   @js.array_from(self.get("ports")).map(fn(v) { unsafe_cast(v) })
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

13 uncovered line(s) in src/dom/file/file.mbt:

    | pub fn File::slice(self : Self, start? : Int, end? : Int) -> Blob {
    |   match (start, end) {
 92 |     (None, None) => self.call("slice", []) |> unsafe_cast
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(s), None) => self.call("slice", [s]) |> unsafe_cast
    |     (Some(s), Some(e)) => self.call("slice", [s, e]) |> unsafe_cast
 95 |     (None, Some(e)) => self.call("slice", [0, e]) |> unsafe_cast
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub fn FileReader::new() -> FileReader {
117 |   unsafe_cast(ffi_new_file_reader())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(readyState)
    | pub fn FileReader::ready_state(self : Self) -> Int {
124 |   unsafe_cast(self.get("readyState"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn FileReader::result(self : Self) -> Js? {
130 |   self.get("result") |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn FileReader::error(self : Self) -> Js? {
136 |   self.get("error") |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(readAsArrayBuffer)
    | pub fn FileReader::read_as_array_buffer(self : Self, blob : Blob) -> Unit {
143 |   self.call("readAsArrayBuffer", [blob.to_js()]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(readAsText)
    | pub fn FileReader::read_as_text(
    |   self : Self,
    |   blob : Blob,
    |   encoding? : String,
    | ) -> Unit {
154 |   match encoding {
    |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(enc) => self.call("readAsText", [blob, enc]) |> ignore
    |     None => self.call("readAsText", [blob.to_js()]) |> ignore
    |   }
    | }
    …

    | #alias(readAsDataURL)
    | pub fn FileReader::read_as_data_url(self : Self, blob : Blob) -> Unit {
164 |   self.call("readAsDataURL", [blob.to_js()]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn FileReader::abort(self : Self) -> Unit {
170 |   self.call("abort", []) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn FileReader::set_onload(
    |   self : Self,
    |   callback : (Js) -> Unit noraise,
    | ) -> Unit {
179 |   self.set("onload", @js.unsafe_cast(callback))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn FileReader::set_onerror(
    |   self : Self,
    |   callback : (Js) -> Unit noraise,
    | ) -> Unit {
188 |   self.set("onerror", @js.unsafe_cast(callback))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn FileReader::set_onloadend(
    |   self : Self,
    |   callback : (Js) -> Unit noraise,
    | ) -> Unit {
197 |   self.set("onloadend", @js.unsafe_cast(callback))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

3 uncovered line(s) in src/dom/html_element.mbt:

   | impl HTMLElementImpl with setOuterHTML(self, html) -> Unit {
66 |   self.set("outerHTML", html)
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | impl HTMLElementImpl with focus(self) -> Unit {
71 |   ignore(self.call("focus", []))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | impl HTMLElementImpl with click(self) -> Unit {
76 |   ignore(self.call("click", []))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

61 uncovered line(s) in src/dom/html_elements.mbt:

    | pub fn HTMLCanvasElement::width(self : Self) -> Int {
 42 |   unsafe_cast(self.get("width"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLCanvasElement::setWidth(self : Self, value : Int) -> Unit {
 47 |   self.set("width", value)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLCanvasElement::height(self : Self) -> Int {
 52 |   unsafe_cast(self.get("height"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLCanvasElement::setHeight(self : Self, value : Int) -> Unit {
 57 |   self.set("height", value)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLCanvasElement::getContext(self : Self, context_type : String) -> Js {
 63 |   self.call("getContext", [context_type])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLCanvasElement::toDataURL(
    |   self : Self,
    |   image_type? : String,
    |   quality? : Double,
    | ) -> String {
 72 |   match (image_type, quality) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(t), Some(q)) => self.call("toDataURL", [t, q]) |> unsafe_cast
    |     (Some(t), None) => self.call("toDataURL", [t]) |> unsafe_cast
    |     (None, _) => self.call("toDataURL", []) |> unsafe_cast
    |   }
    | }
    …

    | pub fn HTMLCanvasElement::toBlob(
    |   self : Self,
    |   image_type? : String,
    |   quality? : Double,
    | ) -> Promise[Blob] {
 85 |   match (image_type, quality) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(t), Some(q)) => self.call("toBlob", [t, q]) |> unsafe_cast
    |     (Some(t), None) => self.call("toBlob", [t]) |> unsafe_cast
    |     (None, _) => self.call("toBlob", []) |> unsafe_cast
    |   }
    | }
    …

    | pub fn HTMLAnchorElement::href(self : Self) -> String {
191 |   unsafe_cast(self.get("href"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLAnchorElement::setHref(self : Self, href : String) -> Unit {
197 |   self.set("href", href)
    |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLAnchorElement::target(self : Self) -> String {
204 |   unsafe_cast(self.get("target"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLAnchorElement::setTarget(self : Self, target : String) -> Unit {
210 |   self.set("target", target)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLButtonElement::disabled(self : Self) -> Bool {
235 |   unsafe_cast(self.get("disabled"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLButtonElement::setDisabled(self : Self, disabled : Bool) -> Unit {
241 |   self.set("disabled", disabled)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLInputElement::value(self : Self) -> String {
266 |   unsafe_cast(self.get("value"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLInputElement::setValue(self : Self, value : String) -> Unit {
272 |   self.set("value", value)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLInputElement::type_(self : Self) -> String {
278 |   unsafe_cast(self.get("type"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLInputElement::setType(self : Self, input_type : String) -> Unit {
284 |   self.set("type", input_type)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLInputElement::disabled(self : Self) -> Bool {
290 |   unsafe_cast(self.get("disabled"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLInputElement::setDisabled(self : Self, disabled : Bool) -> Unit {
296 |   self.set("disabled", disabled)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLInputElement::checked(self : Self) -> Bool {
302 |   unsafe_cast(self.get("checked"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLInputElement::setChecked(self : Self, checked : Bool) -> Unit {
308 |   self.set("checked", checked)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLInputElement::placeholder(self : Self) -> String {
314 |   unsafe_cast(self.get("placeholder"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLInputElement::setPlaceholder(
    |   self : Self,
    |   placeholder : String,
    | ) -> Unit {
323 |   self.set("placeholder", placeholder)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLTextAreaElement::value(self : Self) -> String {
349 |   unsafe_cast(self.get("value"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLTextAreaElement::setValue(self : Self, value : String) -> Unit {
355 |   self.set("value", value)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLTextAreaElement::placeholder(self : Self) -> String {
362 |   unsafe_cast(self.get("placeholder"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLTextAreaElement::setPlaceholder(
    |   self : Self,
    |   placeholder : String,
    | ) -> Unit {
371 |   self.set("placeholder", placeholder)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLTextAreaElement::disabled(self : Self) -> Bool {
378 |   unsafe_cast(self.get("disabled"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLTextAreaElement::setDisabled(self : Self, disabled : Bool) -> Unit {
384 |   self.set("disabled", disabled)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLTextAreaElement::rows(self : Self) -> Int {
391 |   unsafe_cast(self.get("rows"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLTextAreaElement::setRows(self : Self, rows : Int) -> Unit {
397 |   self.set("rows", rows)
    |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLTextAreaElement::cols(self : Self) -> Int {
404 |   unsafe_cast(self.get("cols"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLTextAreaElement::setCols(self : Self, cols : Int) -> Unit {
410 |   self.set("cols", cols)
    |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLTextAreaElement::readOnly(self : Self) -> Bool {
417 |   unsafe_cast(self.get("readOnly"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLTextAreaElement::setReadOnly(self : Self, read_only : Bool) -> Unit {
423 |   self.set("readOnly", read_only)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLIFrameElement::src(self : Self) -> String {
449 |   unsafe_cast(self.get("src"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLIFrameElement::setSrc(self : Self, src : String) -> Unit {
455 |   self.set("src", src)
    |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLIFrameElement::contentWindow(self : Self) -> Window? {
462 |   self.get("contentWindow") |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLIFrameElement::contentDocument(self : Self) -> Document? {
469 |   self.get("contentDocument") |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLIFrameElement::width(self : Self) -> String {
476 |   unsafe_cast(self.get("width"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLIFrameElement::setWidth(self : Self, width : String) -> Unit {
482 |   self.set("width", width)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLIFrameElement::height(self : Self) -> String {
489 |   unsafe_cast(self.get("height"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLIFrameElement::setHeight(self : Self, height : String) -> Unit {
495 |   self.set("height", height)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLIFrameElement::name(self : Self) -> String {
502 |   unsafe_cast(self.get("name"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLIFrameElement::setName(self : Self, name : String) -> Unit {
508 |   self.set("name", name)
    |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLIFrameElement::sandbox(self : Self) -> String {
515 |   unsafe_cast(self.get("sandbox"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLIFrameElement::setSandbox(self : Self, sandbox : String) -> Unit {
521 |   self.set("sandbox", sandbox)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLSelectElement::value(self : Self) -> String {
565 |   unsafe_cast(self.get("value"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLSelectElement::setValue(self : Self, value : String) -> Unit {
571 |   self.set("value", value)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLSelectElement::disabled(self : Self) -> Bool {
577 |   unsafe_cast(self.get("disabled"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLSelectElement::setDisabled(self : Self, disabled : Bool) -> Unit {
583 |   self.set("disabled", disabled)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLOptionElement::value(self : Self) -> String {
608 |   unsafe_cast(self.get("value"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLOptionElement::setValue(self : Self, value : String) -> Unit {
614 |   self.set("value", value)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLOptionElement::selected(self : Self) -> Bool {
620 |   unsafe_cast(self.get("selected"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLOptionElement::setSelected(self : Self, selected : Bool) -> Unit {
626 |   self.set("selected", selected)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLLabelElement::htmlFor(self : Self) -> String {
651 |   unsafe_cast(self.get("htmlFor"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLLabelElement::setHtmlFor(self : Self, html_for : String) -> Unit {
657 |   self.set("htmlFor", html_for)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLImageElement::src(self : Self) -> String {
682 |   unsafe_cast(self.get("src"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLImageElement::setSrc(self : Self, src : String) -> Unit {
688 |   self.set("src", src)
    |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLImageElement::alt(self : Self) -> String {
694 |   unsafe_cast(self.get("alt"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLImageElement::setAlt(self : Self, alt : String) -> Unit {
700 |   self.set("alt", alt)
    |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

14 uncovered line(s) in src/dom/navigator.mbt:

    | pub fn Navigator::language(self : Self) -> String {
 31 |   unsafe_cast(self.get("language"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Navigator::languages(self : Self) -> Js {
 38 |   self.get("languages")
    |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Navigator::platform(self : Self) -> String {
 45 |   unsafe_cast(self.get("platform"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Navigator::hardwareConcurrency(self : Self) -> Int {
 52 |   unsafe_cast(self.get("hardwareConcurrency"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Navigator::deviceMemory(self : Self) -> Double? {
 59 |   self.get("deviceMemory") |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Navigator::maxTouchPoints(self : Self) -> Int {
 66 |   unsafe_cast(self.get("maxTouchPoints"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Navigator::vendor(self : Self) -> String {
 73 |   unsafe_cast(self.get("vendor"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Navigator::cookieEnabled(self : Self) -> Bool {
 80 |   unsafe_cast(self.get("cookieEnabled"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Navigator::doNotTrack(self : Self) -> String? {
 87 |   self.get("doNotTrack") |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Navigator::connection(self : Self) -> Js? {
 94 |   self.get("connection") |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Navigator::permissions(self : Self) -> Js {
101 |   self.get("permissions")
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Navigator::clipboard(self : Self) -> Js {
108 |   self.get("clipboard")
    |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Navigator::geolocation(self : Self) -> Js {
115 |   self.get("geolocation")
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Navigator::vibrate(self : Self, pattern : Int) -> Bool {
122 |   self.call("vibrate", [pattern]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

3 uncovered line(s) in src/dom/node.mbt:

    | impl NodeImpl with previousSibling(self) -> Node? {
 68 |   @js.unsafe_cast_option(self.get("previousSibling"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | impl NodeImpl with nextSibling(self) -> Node? {
 73 |   @js.unsafe_cast_option(self.get("nextSibling"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | impl NodeImpl with insertBefore(self, new_node, ref_node) -> Node {
    |   match ref_node {
    |     Some(node) =>
    |       unsafe_cast(self.call("insertBefore", [new_node.to_js(), node.to_js()]))
    |     None =>
 92 |       unsafe_cast(self.call("insertBefore", [new_node.to_js(), @js.null_()]))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

34 uncovered line(s) in src/dom/observer/observer.mbt:

    | pub fn new_mutation_observer(
    |   callback : (Js?, MutationObserver) -> Unit,
    | ) -> MutationObserver {
 20 |   let ctor = @js.global_this().get("MutationObserver")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @js.unsafe_cast(@js.new_(ctor, [callback |> @js.from_fn2]))
    | }
    …

    | pub fn MutationObserver::observe(
    |   self : Self,
    |   target : Element,
    |   options : Js,
    | ) -> Unit {
 32 |   self.call("observe", [target |> js, options]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MutationObserver::disconnect(self : Self) -> Unit {
 39 |   self.call("disconnect", []) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MutationObserver::take_records(self : Self) -> Js {
 46 |   self.call("takeRecords", [])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MutationRecord::mutation_type(self : Self) -> String {
 61 |   @js.unsafe_cast(self.get("type"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MutationRecord::target(self : Self) -> Js {
 67 |   self.get("target")
    |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MutationRecord::added_nodes(self : Self) -> Js {
 73 |   self.get("addedNodes")
    |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MutationRecord::removed_nodes(self : Self) -> Js {
 79 |   self.get("removedNodes")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MutationRecord::previous_sibling(self : Self) -> Element? {
 85 |   self.get("previousSibling") |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MutationRecord::next_sibling(self : Self) -> Element? {
 91 |   self.get("nextSibling") |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MutationRecord::attribute_name(self : Self) -> String? {
 97 |   self.get("attributeName") |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MutationRecord::old_value(self : Self) -> String? {
103 |   self.get("oldValue") |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn new_intersection_observer(
    |   callback : (Js?, IntersectionObserver) -> Unit,
    | ) -> IntersectionObserver {
121 |   let ctor = @js.global_this().get("IntersectionObserver")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @js.unsafe_cast(@js.new_(ctor, [callback |> @js.from_fn2]))
    | }
    …

    | pub fn new_intersection_observer_with_options(
    |   callback : (Js?, IntersectionObserver) -> Unit,
    |   options : Js,
    | ) -> IntersectionObserver {
131 |   let ctor = @js.global_this().get("IntersectionObserver")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @js.unsafe_cast(@js.new_(ctor, [callback |> @js.from_fn2, options]))
    | }
    …

    | pub fn IntersectionObserver::observe(self : Self, target : Element) -> Unit {
139 |   self.call("observe", [target]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn IntersectionObserver::unobserve(self : Self, target : Element) -> Unit {
146 |   self.call("unobserve", [target]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn IntersectionObserver::disconnect(self : Self) -> Unit {
153 |   self.call("disconnect", []) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn IntersectionObserver::take_records(self : Self) -> Js {
160 |   self.call("takeRecords", [])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn IntersectionObserverEntry::target(self : Self) -> Js {
175 |   @js.unsafe_cast(self.get("target"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn IntersectionObserverEntry::bounding_client_rect(self : Self) -> Js {
181 |   self.get("boundingClientRect")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn IntersectionObserverEntry::intersection_rect(self : Self) -> Js {
187 |   self.get("intersectionRect")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn IntersectionObserverEntry::root_bounds(self : Self) -> Element? {
193 |   self.get("rootBounds") |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn IntersectionObserverEntry::intersection_ratio(self : Self) -> Double {
199 |   @js.unsafe_cast(self.get("intersectionRatio"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn IntersectionObserverEntry::is_intersecting(self : Self) -> Bool {
205 |   @js.unsafe_cast(self.get("isIntersecting"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn IntersectionObserverEntry::time(self : Self) -> Double {
211 |   @js.unsafe_cast(self.get("time"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn new_resize_observer(
    |   callback : (Js?, ResizeObserver) -> Unit,
    | ) -> ResizeObserver {
229 |   let ctor = @js.global_this().get("ResizeObserver")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   @js.unsafe_cast(@js.new_(ctor, [callback |> @js.from_fn2]))
    | }
    …

    | pub fn ResizeObserver::observe(self : Self, target : Element) -> Unit {
237 |   self.call("observe", [target |> js]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ResizeObserver::observe_with_options(
    |   self : Self,
    |   target : Element,
    |   options : Js,
    | ) -> Unit {
247 |   self.call("observe", [target |> js, options]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ResizeObserver::unobserve(self : Self, target : Element) -> Unit {
254 |   self.call("unobserve", [target |> js]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ResizeObserver::disconnect(self : Self) -> Unit {
261 |   self.call("disconnect", []) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ResizeObserverEntry::target(self : Self) -> Element {
276 |   @js.unsafe_cast(self.get("target"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ResizeObserverEntry::contentRect(self : Self) -> @dom.DOMRectReadOnly {
282 |   @js.unsafe_cast(self.get("contentRect"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ResizeObserverEntry::borderBoxSize(self : Self) -> Js {
288 |   self.get("borderBoxSize")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ResizeObserverEntry::contentBoxSize(self : Self) -> Js {
294 |   self.get("contentBoxSize")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

4 uncovered line(s) in src/dom/request_animation_frame.mbt:

   | pub async fn requestAnimationFrame(f : () -> Unit raise) -> Unit noraise {
13 |   suspend(fn(ok, _err) {
   |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     ffi_request_animation_frame(() => {
   |       f() catch {
   |         _ => ()
   |       }
18 |       ok(())
   |       ^^^^^^ 	<-- UNCOVERED
   |     })
   |   }) catch {
21 |     _ => ()
   |     ^^^^^^^ 	<-- UNCOVERED
   |   }
   | }
   …

   | pub async fn wait_animation_frame() -> Unit noraise {
27 |   suspend((ok, _) => ffi_request_animation_frame(() => ok(()))) catch {
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     _ => ()
   |   }
   | }
   …

13 uncovered line(s) in src/dom/shadow_dom.mbt:

    | pub fn ShadowRoot::mode(self : Self) -> String {
 24 |   unsafe_cast(self.get("mode"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ShadowRoot::host(self : Self) -> Element {
 31 |   unsafe_cast(self.get("host"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ShadowRoot::delegatesFocus(self : Self) -> Bool {
 38 |   unsafe_cast(self.get("delegatesFocus"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ShadowRoot::slotAssignment(self : Self) -> String {
 45 |   unsafe_cast(self.get("slotAssignment"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ShadowRoot::innerHTML(self : Self) -> String {
 52 |   unsafe_cast(self.get("innerHTML"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ShadowRoot::setInnerHTML(self : Self, html : String) -> Unit {
 58 |   self.set("innerHTML", html)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ShadowRoot::activeElement(self : Self) -> Element? {
 65 |   self.get("activeElement") |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ShadowRoot::elementFromPoint(
    |   self : Self,
    |   x : Double,
    |   y : Double,
    | ) -> Element? {
 76 |   self.call("elementFromPoint", [x, y]) |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ShadowRoot::elementsFromPoint(
    |   self : Self,
    |   x : Double,
    |   y : Double,
    | ) -> Array[Element] {
 87 |   @js.array_from(self.call("elementsFromPoint", [x, y])).map(fn(v) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     unsafe_cast(v)
    |   })
    | }
    …

    | pub fn ShadowRootInit::new(
    |   mode : String,
    |   delegatesFocus? : Bool = false,
    |   slotAssignment? : String = "named",
    | ) -> ShadowRootInit {
107 |   { mode, delegatesFocus, slotAssignment }
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLElement::attachShadow(
    |   self : Self,
    |   init : ShadowRootInit,
    | ) -> ShadowRoot {
117 |   let options = @js.from_map({
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     "mode": js(init.mode),
    |     "delegatesFocus": js(init.delegatesFocus),
    |     "slotAssignment": js(init.slotAssignment),
    |   })
122 |   self.call("attachShadow", [options]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn HTMLElement::shadowRoot(self : Self) -> ShadowRoot? {
129 |   self.get("shadowRoot") |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

14 uncovered line(s) in src/dom/storage/storage.mbt:

    | pub fn Storage::clear(self : Storage) -> Unit {
 55 |   self.call("clear", []) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Storage::length(self : Storage) -> Int {
 62 |   unsafe_cast(self.get("length"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Storage::key(self : Storage, index : Int) -> String? {
 69 |   self.call("key", [index |> js]) |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Storage::hasItem(self : Storage, key : String) -> Bool {
 75 |   match self.getItem(key) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(_) => true
    |     None => false
    |   }
    | }
    …

    | pub fn Storage::keys(self : Storage) -> Array[String] {
 84 |   let len = self.length()
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let result = []
 86 |   for i = 0; i < len; i = i + 1 {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     match self.key(i) {
    |       Some(k) => result.push(k)
    |       None => ()
    |     }
    |   }
    |   result
    | }
    …

    | pub fn Storage::values(self : Storage) -> Array[String] {
 98 |   let len = self.length()
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let result = []
100 |   for i = 0; i < len; i = i + 1 {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     match self.key(i) {
    |       Some(k) =>
103 |         match self.getItem(k) {
    |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           Some(v) => result.push(v)
    |           None => ()
    |         }
107 |       None => ()
    |       ^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    |   result
    | }
    …

    | pub fn Storage::entries(self : Storage) -> Array[(String, String)] {
116 |   let len = self.length()
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let result = []
118 |   for i = 0; i < len; i = i + 1 {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     match self.key(i) {
    |       Some(k) =>
121 |         match self.getItem(k) {
    |         ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           Some(v) => result.push((k, v))
    |           None => ()
    |         }
125 |       None => ()
    |       ^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    |   result
    | }
    …

39 uncovered line(s) in src/dom/window.mbt:

    | pub impl JsImpl for Window with to_js(self) {
  9 |   self |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Window::document(self : Self) -> Document {
 24 |   unsafe_cast(self.get("document"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Window::navigator(self : Self) -> Js {
 31 |   unsafe_cast(self.get("navigator"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Window::location(self : Self) -> Js {
 38 |   unsafe_cast(self.get("location"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(local_storage)
    | pub fn Window::localStorage(self : Self) -> Js {
 46 |   unsafe_cast(self.get("localStorage"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(session_storage)
    | pub fn Window::sessionStorage(self : Self) -> Js {
 54 |   unsafe_cast(self.get("sessionStorage"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Window::console(self : Self) -> Js {
 61 |   unsafe_cast(self.get("console"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Window::history(self : Self) -> Js {
 68 |   unsafe_cast(self.get("history"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(inner_width)
    | pub fn Window::innerWidth(self : Self) -> Int {
 76 |   unsafe_cast(self.get("innerWidth"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(inner_height)
    | pub fn Window::innerHeight(self : Self) -> Int {
 84 |   unsafe_cast(self.get("innerHeight"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(outer_width)
    | pub fn Window::outerWidth(self : Self) -> Int {
 92 |   unsafe_cast(self.get("outerWidth"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(outer_height)
    | pub fn Window::outerHeight(self : Self) -> Int {
100 |   unsafe_cast(self.get("outerHeight"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Window::screen(self : Self) -> Js {
107 |   unsafe_cast(self.get("screen"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(device_pixel_ratio)
    | pub fn Window::devicePixelRatio(self : Self) -> Double {
115 |   unsafe_cast(self.get("devicePixelRatio"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Window::alert(self : Self, message : String) -> Unit {
122 |   ignore(self.call("alert", [message]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Window::confirm(self : Self, message : String) -> Bool {
129 |   self.call("confirm", [message]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Window::prompt(
    |   self : Self,
    |   message : String,
    |   default? : String,
    | ) -> String? {
140 |   match default {
    |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(d) => self.call("prompt", [message, d]) |> @js.unsafe_cast_option()
    |     None => self.call("prompt", [message]) |> @js.unsafe_cast_option()
    |   }
    | }
    …

    | pub fn Window::open(
    |   self : Self,
    |   url? : String,
    |   target? : String,
    |   features? : String,
    | ) -> Window? {
155 |   match (url, target, features) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(u), Some(t), Some(f)) =>
157 |       self.call("open", [u, t, f]) |> @js.unsafe_cast_option
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(u), Some(t), None) =>
159 |       self.call("open", [u, t]) |> @js.unsafe_cast_option
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(u), None, _) => self.call("open", [u]) |> @js.unsafe_cast_option
    |     (None, _, _) => self.call("open", []) |> @js.unsafe_cast_option
    |   }
    | }
    …

    | pub fn Window::close(self : Self) -> Unit {
169 |   ignore(self.call("close", []))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(scroll_to)
    | pub fn Window::scrollTo(self : Self, x : Int, y : Int) -> Unit {
177 |   ignore(self.call("scrollTo", [x, y]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(scroll_by)
    | pub fn Window::scrollBy(self : Self, x : Int, y : Int) -> Unit {
185 |   ignore(self.call("scrollBy", [x, y]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(scroll_x)
    | pub fn Window::scrollX(self : Self) -> Double {
193 |   unsafe_cast(self.get("scrollX"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(scroll_y)
    | pub fn Window::scrollY(self : Self) -> Double {
201 |   unsafe_cast(self.get("scrollY"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(set_timeout)
    | pub fn Window::setTimeout(
    |   self : Self,
    |   handler : () -> Unit,
    |   delay : Int,
    | ) -> Int {
213 |   self.call("setTimeout", [@js.from_fn0(handler), delay]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(clear_timeout)
    | pub fn Window::clearTimeout(self : Self, id : Int) -> Unit {
221 |   ignore(self.call("clearTimeout", [id]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(set_interval)
    | pub fn Window::setInterval(
    |   self : Self,
    |   handler : () -> Unit,
    |   delay : Int,
    | ) -> Int {
233 |   self.call("setInterval", [@js.from_fn0(handler), delay]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(clear_interval)
    | pub fn Window::clearInterval(self : Self, id : Int) -> Unit {
241 |   ignore(self.call("clearInterval", [id]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(request_animation_frame)
    | pub fn Window::requestAnimationFrame(
    |   self : Self,
    |   callback : (Double) -> Unit,
    | ) -> Int {
252 |   self.call("requestAnimationFrame", [@js.unsafe_js(callback)]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(cancel_animation_frame)
    | pub fn Window::cancelAnimationFrame(self : Self, id : Int) -> Unit {
260 |   ignore(self.call("cancelAnimationFrame", [id]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Window::fetch(self : Self, input : String, init? : Js) -> Promise[Js] {
267 |   match init {
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(i) => self.call("fetch", [input, i]) |> unsafe_cast
    |     None => self.call("fetch", [input]) |> unsafe_cast
    |   }
    | }
    …

    | #alias(get_selection)
    | pub fn Window::getSelection(self : Self) -> Js? {
278 |   self.call("getSelection", []) |> @js.unsafe_cast_option
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(get_computed_style)
    | pub fn Window::getComputedStyle(
    |   self : Self,
    |   element : Element,
    |   pseudo_elt? : String,
    | ) -> Js {
290 |   match pseudo_elt {
    |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(p) =>
292 |       self.call("getComputedStyle", [element.to_js(), p]) |> unsafe_cast
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => self.call("getComputedStyle", [element.to_js()]) |> unsafe_cast
    |   }
    | }
    …

    | #alias(match_media)
    | pub fn Window::matchMedia(self : Self, query : String) -> Js {
302 |   self.call("matchMedia", [query]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(post_message)
    | pub fn Window::postMessage(
    |   self : Self,
    |   message : Js,
    |   target_origin : String,
    | ) -> Unit {
314 |   ignore(self.call("postMessage", [message, target_origin]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[T : Transferable] Window::post_message_with_transfer(
    |   self : Self,
    |   message : Js,
    |   target_origin : String,
    |   transfer : Array[T],
    | ) -> Unit {
326 |   let transfer_vals = transfer.map(fn(t) { t.to_transferable() })
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ignore(
    |     self
329 |     .to_js()
    |     ^^^^^^^^ 	<-- UNCOVERED
    |     .call("postMessage", [message, target_origin, @js.unsafe_js(transfer_vals)]),
    |   )
    | }
    …

5 uncovered line(s) in src/error.mbt:

    | pub impl Show for JsThrowError with output(self, logger) {
 40 |   logger.write_string(self.to_string())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl Show for JsThrowError with to_string(self) {
    |   match self {
    |     Error(err) => err.message()
 47 |     Value(val) => val.to_string()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub impl Show for JsError with output(self, logger) {
 53 |   logger.write_string(self.to_string())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn JsError::stack(self : Self) -> String {
 70 |   unsafe_cast(self.get("stack"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn throw_(v : &JsImpl) -> Unit {
 85 |   ffi_throw(v.to_js())
    |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

1 uncovered line(s) in src/event/event_target.mbt:

   | impl EventTargetImpl with addEventListener(
   |   self,
   |   event_type,
   |   handler,
   |   capture? : Bool = false,
   |   once? : Bool = false,
   |   passive? : Bool = false,
   |   signal? : AbortSignal,
   | ) -> Unit {
   |   let options = @js.Object::new()
   |   options.set("capture", capture)
   |   options.set("once", once)
   |   options.set("passive", passive)
   |   if signal is Some(sig) {
58 |     options.set("signal", sig)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
   |   self.call("addEventListener", [event_type, @js.from_fn1(handler), options])
   |   |> ignore
   | }
   …

4 uncovered line(s) in src/examples/cfw/main.mbt:

   | pub fn get_fetch_handler() -> @cloudflare.CloudflareFetchHandler {
 9 |   let async_handler = async fn(
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     _req : @cloudflare.CloudflareRequest,
   |     _env : @cloudflare.CloudflareEnv,
   |     _ctx : @cloudflare.CloudflareContext,
   |   ) -> Response {
14 |     let res = fetch(
   |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       "https://jsonplaceholder.typicode.com/todos/1",
   |       method_="GET",
17 |     ).unwrap() catch {
   |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       e => {
   |         log("Error: " + e.to_string())
   |         panic()
   |         // Response::new("Internal Server Error", 500)
   |       }
   |     }
   |     res
   |   }
26 |   @promise.promisify3(async_handler)
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

3 uncovered line(s) in src/examples/for-ts-user/main.mbt:

  8 | fn main {
    | ^^^^^^^^^ 	<-- UNCOVERED
    | 
    | }
    …

    | fn param_func(a~ : Int, b~ : Int) -> (Int, Int) {
197 |   (a, b)
    |   ^^^^^^ 	<-- UNCOVERED
    | }
    …

    | fn param_func2(a? : Int = 1, b? : Int) -> (Int, Int) {
203 |   (a, b.unwrap_or(-1))
    |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

1 uncovered line(s) in src/examples/js_examples/main.mbt:

  | fn main {
3 |   let obj = @js.Object::new()
  |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
  |   obj.set("name", "MoonBit")
  |   @js.log(obj)
  |   obj.hasOwnProperty("name") |> @js.log
  |   obj.call("hasOwnProperty", ["nothing"]) |> @js.log
  | }
  …

3 uncovered line(s) in src/examples/node_examples/main.mbt:

   | fn main {
 3 |   @promise.run_async(() => try {
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     let tmpdir = @os.tmpdir()
   |     let outpath = @path.join([tmpdir, "moonbit_example.txt"])
   |     let content =
   |       #|This is an example file created by Moonbit.
 8 |     println("Writing to file: " + outpath)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     @fs.writeFile(outpath, content).unwrap()
   |     let read_content = @fs.readFile(outpath).unwrap()
   |     @js.log("Read content: " + read_content)
   |     assert_eq(content, read_content)
   |     let stat = @fs.stat(outpath).unwrap()
   |     @js.log(stat.size())
   |     assert_true(stat.isFile())
   |   } catch {
17 |     e => @js.log(e)
   |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   })
   | }
   …

39 uncovered line(s) in src/examples/react_app/main.mbt:

    | fn item_component(props : ItemViewProps) -> @react.Element {
 60 |   createElement(
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     "div",
    |     style={ "padding": "5px", "borderBottom": "1px solid #ccc" },
    |     [props.name],
    |   )
    | }
    …

    | fn init_myctx() -> Unit {
 72 |   myctx.val = Some(createContext(None))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | fn use_myctx() -> MyContextProps {
 77 |   guard myctx.val is Some(ctx)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   useContext(ctx)
    | }
    …

    | fn ctx_consumer(_ : EmptyProps) -> @react.Element {
 83 |   let ctx_value = use_myctx()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   createElement("div", props={ "className": "context-value" |> js }, [
    |     "Context value: \{ctx_value.v}",
    |   ])
    | }
    …

    | fn counter(_ : EmptyProps) -> @react.Element {
 96 |   let (count, dispatch) = useReducer(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (state : Int, action : CounterAction) => match action {
    |       CounterAction::Increment => state + 1
    |     },
    |     0,
    |   )
102 |   let on_click = useCallback(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     () => {
    |       dispatch(CounterAction::Increment)
    |       log("Counter clicked: \{count + 1}")
    |     },
    |     [count],
    |   )
109 |   createElement("button", props={ "onClick": on_click |> unsafe_cast }, [
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     "Count: \{count}",
    |   ])
    | }
    …

    | fn async_counter(_ : EmptyProps) -> @react.Element {
116 |   let (count, dispatch, is_pending) = useActionState(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     async fn(state : Int, action : CounterAction) -> Int noraise {
118 |       match action {
    |       ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         Increment => state + 1
    |       }
    |     },
    |     0,
    |   )
124 |   let on_click = useCallback(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     _ => run_async(async fn() noraise {
    |       sleep(500)
    |       @react.startTransition(() => dispatch(Increment))
    |     }),
    |     [count],
    |   )
131 |   button(on_click~, [
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     "Async Count: \{count}",
    |     if is_pending {
134 |       " (Updating...)"
    |       ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     } else {
136 |       ""
    |       ^^ 	<-- UNCOVERED
    |     },
    |   ])
    | }
    …

    | fn app(props : AppProps) -> @react.Element {
149 |   let (cnt, set_cnt) = useState(props.x)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let textarea_ref : @react.ReactRef[@dom.HTMLTextAreaElement] = @react.useRef(
    |     None,
    |   )
153 |   let handler = useCallback(_ => set_cnt(cnt + 1), [cnt])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   useEffect(
    |     () => {
    |       log("mounted with x = \{props.x}")
    |       () => log("unmounted")
    |     },
    |     [cnt, textarea_ref],
    |   )
161 |   useEffect(
    |   ^^^^^^^^^^ 	<-- UNCOVERED
    |     () => {
    |       run_async(async fn() noraise {
    |         sleep(300)
    |         if textarea_ref.current() is Some(textarea) {
166 |           textarea.focus()
    |           ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         }
168 |         log("Starting async operation...")
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       })
170 |       () => log("Component unmounted")
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     },
    |     [],
    |   )
174 |   let (input_text, set_text) = useState("")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let on_change : @dom.ChangeEventHandler = useCallback(
    |     ev => {
    |       let target : @dom.HTMLTextAreaElement = unsafe_cast(ev.target().to_js())
    |       let value : String = target.value()
    |       set_text(value)
    |       log("Textarea changed: \{value}")
    |     },
    |     [input_text],
    |   )
    |   guard myctx.val is Some(myctx)
185 |   provider(myctx, value={ v: "xxx" }, [
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     h1(["Hello, Moonbit React!"]),
    |     div(
    |       id="foo",
    |       class="foo bar",
    |       style={ "border": "1px solid black", "padding": "10px" },
    |       on_click=handler,
    |       [
193 |         h2(["Counter: \{cnt}"]),
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         "x = \{cnt}",
195 |         fragment([createElement("h1", ["xxx"])]),
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         div(id="textarea-container", [
    |           textarea(
    |             id="my-textarea",
    |             on_change~,
    |             props={
201 |               let obj = @js.Object::new()
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |               obj.set("rows", 4)
    |               obj.set("cols", 40)
    |               obj
    |             },
    |             ref_=textarea_ref,
    |             value=input_text,
    |             [],
    |           ),
210 |           div(class="textarea-value", ["Textarea value: \{input_text}"]),
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         ]),
    |         // ]
213 |         ul(
    |         ^^^ 	<-- UNCOVERED
    |           props.items.mapi((idx, item) => createElement(
    |             "li",
216 |             key=idx.to_string(),
    |             ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             [component(item_component, { name: item }, key=idx.to_string())],
    |           )),
    |         ),
220 |         component(ctx_consumer, EmptyProps::default()),
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         component(counter, EmptyProps::default()),
    |         component(async_counter, EmptyProps::default()),
    |         hr(),
    |         form(
    |           method_="post",
    |           style={ "marginTop": "10px" },
    |           enc_type="application/x-www-form-urlencoded",
228 |           action=form => {
    |           ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             log(form)
    |             let v : String = unsafe_cast(form.get("username"))
    |             log("Username: \{v}")
    |           },
    |           [
234 |             input(type_="text", name="username"),
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             input(type_="submit", value="Submit"),
    |           ],
    |         ),
238 |         svg(width=500, height=100, [
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           circle(cx=50, cy=50, r=40, stroke="black", stroke_width=3, fill="red"),
    |           rect(
    |             x=120,
    |             y=10,
    |             width=80,
    |             height=80,
    |             stroke="blue",
    |             stroke_width=3,
    |             fill="green",
    |           ),
249 |           text(x=100, y=30, dx="50%", dy="50%", ["Hello, SVG Text!"]),
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           line(x1=220, y1=10, x2=300, y2=90, stroke="black", stroke_width=2),
    |         ]),
    |       ],
    |     ),
    |   ])
    | }
    …

    | fn main {
    |   // lazy init context
260 |   run_async(() => try {
    |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     @react.init_react_async()
    |     @react_router.init_react_router_async()
    |     let client = @react_dom.import_react_dom_client().unwrap()
    |     guard @dom.document().querySelector("#app") is Some(app_root)
265 |     init_myctx()
    |     ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let index = (_props : @react_router.RouteProps) => component(app, {
    |       x: 42,
    |       items: ["Item 1", "Item 2", "Item 3"],
    |     })
270 |     let routes = @react_router.create_browser_router([
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       Component(path="/", component=index),
    |       Element(
    |         path="/about",
274 |         element=createElement("div", [
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |           "About page",
276 |           @react_router.link(to="/", ["Go to Top"]),
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         ]),
    |       ),
    |     ])
280 |     client.create_root(app_root).render(router_provider(routes))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   } catch {
282 |     err => log("Error during React initialization: \{err}")
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   })
    | }
    …

14 uncovered line(s) in src/from.mbt:

    | pub fn[A, B, C, R] from_fn3(f : (A, B, C) -> R) -> Js {
 47 |   unsafe_cast(f)
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl ToJson for Js with to_json(self) -> Json {
 57 |   if is_nullish(self) {
    |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     return null
    |   }
 60 |   match typeof_(self) {
    |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     "boolean" => {
    |       // let v : Bool = unsafe_cast(self)
 63 |       let v : Bool = unsafe_cast(self)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       return v.to_json()
    |     }
 66 |     "number" => {
    |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let v : Double = unsafe_cast(self)
    |       return v.to_json()
    |     }
 70 |     "string" => {
    |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let v : String = unsafe_cast(self)
    |       return v.to_json()
    |     }
 74 |     _ => ()
    |     ^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if is_array(self) {
 77 |     let len : Int = unsafe_cast(self.call("length", []))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let arr : Array[Json] = []
 79 |     for i = 0; i < len; i = i + 1 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let v = self.get(i.to_string())
    |       arr.push(v.to_json())
    |     }
 83 |     return arr.to_json()
    |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if typeof_(self) == "object" {
 86 |     let out : Map[String, Json] = {}
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let keys = self |> ffi_object_keys()
    |     for k in keys {
 89 |       let v = self.get(k)
    |       ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       out[k] = v.to_json()
    |     }
 92 |     return out.to_json()
    |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   return {}
    | }
    …

    | pub impl JsImpl for Json with to_js(self) -> Js {
    |   match self {
    |     Null => null_()
    |     String(s) => js(s)
    |     Number(n, ..) => js(n)
103 |     True => js(true)
    |     ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     False => js(false)
    |     Object(o) => {
    |       let obj = Object::new()
    |       for k, v in o {
    |         let v : Js = JsImpl::to_js(v)
    |         obj.set(k, v)
    |       }
    |       obj.to_js()
    |     }
    |     Array(a) => {
    |       let arr = JsArray::new()
    |       for v in a {
    |         let v : Js = JsImpl::to_js(v)
    |         arr.call("push", [v]) |> ignore
    |       }
    |       arr.to_js()
    |     }
    |   }
    | }
    …

8 uncovered line(s) in src/global.mbt:

    | #alias(dynamic_import)
    | pub fn dynamicImport(module_name : String) -> Js {
 60 |   ffi_dynamic_import(module_name)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(set_timeout)
    | pub fn setTimeout(f : () -> Unit, duration : Int) -> JsTimer {
 73 |   ffi_set_timeout(f, duration)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(clear_timeout)
    | pub fn clearTimeout(timer : JsTimer) -> Unit {
 80 |   ffi_clear_timeout(timer)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(set_interval)
    | pub fn setInterval(f : () -> Unit noraise, duration : Int) -> JsTimer {
 87 |   ffi_set_interval(f, duration)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(clear_interval)
    | pub fn clearInterval(timer : JsTimer) -> Unit {
 94 |   ffi_clear_timeout(timer)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn JSON::parse(s : String, reviver? : Js? = None) -> Js raise JsThrowError {
115 |   throwable(() => ffi_json_parse(s, reviver?))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn AbortController::abort(self : Self) -> AbortController {
134 |   self.call("abort", []) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn AbortController::signal(self : Self) -> AbortSignal {
148 |   self.get("signal") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

15 uncovered line(s) in src/http/fetch.mbt:

   | pub fn fetch(
   |   url : String,
   |   method_~ : String,
   |   headers? : Map[String, String] = {},
   |   cache? : String,
   |   mode? : String,
   |   body? : &JsImpl, // String, ArrayBuffer, FormData, etc.
   |   credentials? : String,
   |   integrity? : String,
   |   keepalive? : Bool,
   |   priority? : String,
   |   redirect? : String,
   |   referrer? : String,
   |   referrerPolicy? : String,
   |   signal? : AbortSignal,
   | ) -> Promise[Response] {
26 |   let init_obj = @js.Object::new()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   init_obj.set("method", method_)
   |   let header_obj = @js.Object::new()
   |   for k, v in headers {
30 |     header_obj.set(k, v)
   |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
   |   if body is Some(body) {
33 |     init_obj.set("body", body)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
   |   if cache is Some(c) {
36 |     init_obj.set("cache", c)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
   |   if mode is Some(m) {
39 |     init_obj.set("mode", m)
   |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
   |   if credentials is Some(c) {
42 |     init_obj.set("credentials", c)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
   |   if integrity is Some(i) {
45 |     init_obj.set("integrity", i)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
   |   if keepalive is Some(k) {
48 |     init_obj.set("keepalive", k)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
   |   if priority is Some(p) {
51 |     init_obj.set("priority", p)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
   |   if redirect is Some(r) {
54 |     init_obj.set("redirect", r)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
   |   if referrer is Some(r) {
57 |     init_obj.set("referrer", r)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
   |   if referrerPolicy is Some(rp) {
60 |     init_obj.set("referrerPolicy", rp)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
   |   if signal is Some(s) {
63 |     init_obj.set("signal", s)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
65 |   ffi_fetch(url, init_obj.to_js())
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn fetch_request(request : Request) -> Promise[Response] {
70 |   ffi_fetch_request(request)
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

3 uncovered line(s) in src/http/form_data.mbt:

   | pub fn FormData::append(self : Self, name : String, value : String) -> Unit {
10 |   self.call("append", [name, value]) |> unsafe_cast
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn FormData::delete(self : Self, name : String) -> Unit {
15 |   self.call("delete", [name]) |> unsafe_cast
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn FormData::get(self : Self, name : String) -> String {
20 |   self.call("get", [name]) |> unsafe_cast
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

11 uncovered line(s) in src/http/request.mbt:

   | pub fn Request::new(url : String) -> Request {
14 |   let req = ffi_request_new(url)
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   unsafe_cast(req)
   | }
   …

   | #alias(bodyUsed)
   | pub fn Request::body_used(self : Request) -> Bool {
21 |   unsafe_cast(self.get("bodyUsed"))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Request::url(self : Request) -> String {
26 |   unsafe_cast(self.get("url"))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Request::method_(self : Request) -> String {
31 |   unsafe_cast(self.get("method"))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Request::credentials(self : Request) -> String {
36 |   unsafe_cast(self.get("credentials"))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Request::clone(self : Request) -> Request {
41 |   self.call("clone", []) |> unsafe_cast
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Request::json(self : Request) -> Promise[Js] {
46 |   self.call("json", []) |> unsafe_cast
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Request::text(self : Request) -> Promise[String] {
51 |   self.call("text", []) |> unsafe_cast
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Request::arraybuffer(
   |   self : Request,
   | ) -> Promise[@arraybuffer.ArrayBuffer] {
58 |   self.call("arrayBuffer", []) |> unsafe_cast
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Request::blob(self : Request) -> Promise[Js] {
63 |   self.call("blob", []) |> unsafe_cast
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Request::bytes(self : Request) -> Promise[Js] {
68 |   self.call("bytes", []) |> unsafe_cast
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

3 uncovered line(s) in src/iterator/async_iterator.mbt:

   | pub async fn[T] AsyncIterator::next(self : AsyncIterator[T]) -> T? {
12 |   let v : Promise[Js] = unsafe_cast(self.call("next", []))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   let v : Js = v.unwrap()
   |   if unsafe_cast(v.get("done")) {
15 |     None
   |     ^^^^ 	<-- UNCOVERED
   |   } else {
17 |     Some(unsafe_cast(v.get("value")))
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
   | }
   …

7 uncovered line(s) in src/js.mbt:

    | pub impl Show for Js with output(self, logger) {
 19 |   logger.write_string(self.to_string())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[T : JsImpl] instanceof_(v : T, cls : T) -> Bool {
 41 |   ffi_instance_of(v.to_js(), cls.to_js())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | impl JsImpl with call_self0(self) -> Js {
160 |   ffi_call_self0(self.to_js())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | impl JsImpl with call_self_throwable(self, args) -> Js raise JsThrowError {
165 |   throwable(() => ffi_call_self(self.to_js(), args.map(_.to_js())))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl JsImpl for Map[String, &JsImpl] with to_js(self) {
216 |   let v = Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   for k, val in self {
218 |     v.set(k, val.to_js())
    |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
220 |   v.to_js()
    |   ^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

1 uncovered line(s) in src/js_bench.mbt:

    | fn get_test_obj() -> Js {
 20 |   ffi_create_test_function()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

12 uncovered line(s) in src/node/buffer/buffer.mbt:

    | pub fn Buffer::from_arraybuffer(
    |   ab : ArrayBuffer,
    |   byte_offset? : Int = 0,
    |   length? : Int,
    | ) -> Buffer {
 44 |   let ctor = buffer_constructor()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match length {
    |     Some(len) => ctor.call("from", [ab, byte_offset, len]) |> unsafe_cast
    |     None => ctor.call("from", [ab, byte_offset]) |> unsafe_cast
    |   }
    | }
    …

    | pub fn Buffer::concat(list : Array[Buffer], total_length? : Int) -> Buffer {
    |   let ctor = buffer_constructor()
    |   let list_js = @js.JsArray::new()
    |   let mut i = 0
    |   while i < list.length() {
    |     list_js.call("push", [list[i]]) |> ignore
    |     i = i + 1
    |   }
    |   match total_length {
114 |     Some(len) => ctor.call("concat", [list_js, len]) |> unsafe_cast
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ctor.call("concat", [list_js]) |> unsafe_cast
    |   }
    | }
    …

    | pub fn Buffer::write(
    |   self : Self,
    |   str : String,
    |   offset? : Int = 0,
    |   length? : Int,
    |   encoding? : String = "utf-8",
    | ) -> Int {
    |   let buf_js = self.to_js()
    |   match length {
    |     Some(len) =>
160 |       buf_js.call("write", [str, offset, len, encoding]) |> unsafe_cast
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => buf_js.call("write", [str, offset, encoding]) |> unsafe_cast
    |   }
    | }
    …

    | pub fn Buffer::subarray(self : Self, start? : Int = 0, end? : Int) -> Buffer {
    |   let buf_js = self.to_js()
    |   match end {
    |     Some(e) => buf_js.call("subarray", [start, e]) |> unsafe_cast
181 |     None => buf_js.call("subarray", [start]) |> unsafe_cast
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub fn Buffer::copy(
    |   self : Self,
    |   target : Buffer,
    |   target_start? : Int = 0,
    |   source_start? : Int = 0,
    |   source_end? : Int,
    | ) -> Int {
    |   let buf_js = self.to_js()
    |   match source_end {
    |     Some(se) =>
197 |       buf_js.call("copy", [target, target_start, source_start, se])
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       |> unsafe_cast
    |     None =>
    |       buf_js.call("copy", [target, target_start, source_start]) |> unsafe_cast
    |   }
    | }
    …

    | pub fn Buffer::compare_with(
    |   self : Self,
    |   target : Buffer,
    |   target_start? : Int = 0,
    |   target_end? : Int,
    |   source_start? : Int = 0,
    |   source_end? : Int,
    | ) -> Int {
236 |   let buf_js = self.to_js()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let args = @js.JsArray::new()
    |   args.call("push", [target]) |> ignore
    |   args.call("push", [target_start]) |> ignore
    |   match target_end {
    |     Some(te) => args.call("push", [te]) |> ignore
    |     None => ()
    |   }
244 |   args.call("push", [source_start]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match source_end {
    |     Some(se) => args.call("push", [se]) |> ignore
    |     None => ()
    |   }
249 |   let compare_fn = buf_js.get("compare")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let apply = compare_fn.get("apply")
    |   apply.call("call", [compare_fn, buf_js, args]) |> unsafe_cast
    | }
    …

    | #alias(last_index_of)
    | pub fn Buffer::lastIndexOf(
    |   self : Self,
    |   value : Js,
    |   byte_offset? : Int,
    |   encoding? : String = "utf-8",
    | ) -> Int {
286 |   let buf_js = self.to_js()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   match byte_offset {
    |     Some(offset) =>
289 |       buf_js.call("lastIndexOf", [value, offset, encoding]) |> unsafe_cast
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => buf_js.call("lastIndexOf", [value, encoding]) |> unsafe_cast
    |   }
    | }
    …

    | pub fn Buffer::buffer(self : Self) -> ArrayBuffer {
317 |   self.get("buffer") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(byte_offset)
    | pub fn Buffer::byteOffset(self : Self) -> Int {
324 |   self.get("byteOffset") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

63 uncovered line(s) in src/node/child_process/child_process.mbt:

    | pub fn ChildProcess::on_stderr_data(
    |   self : Self,
    |   callback : (Js) -> Unit noraise,
    | ) -> Unit {
 24 |   match self.stderr() {
    |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(stream) =>
 26 |       stream.call("on", ["data", @js.from_fn1(callback)]) |> ignore
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => ()
    |   }
    | }
    …

    | pub fn ChildProcess::exitCode(self : Self) -> Int? {
 48 |   self.get("exitCode") |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ChildProcess::signalCode(self : Self) -> String? {
 54 |   self.get("signalCode") |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ChildProcess::stdin(self : Self) -> WritableStream? {
 60 |   self.get("stdin") |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ChildProcess::stdout(self : Self) -> ReadableStream? {
 66 |   self.get("stdout") |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ChildProcess::stderr(self : Self) -> ReadableStream? {
 72 |   self.get("stderr") |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ChildProcess::kill(self : Self, signal? : String) -> Bool {
    |   match signal {
 81 |     Some(sig) => self.call("kill", [sig]) |> unsafe_cast
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => self.call("kill", []) |> unsafe_cast
    |   }
    | }
    …

    | pub fn ChildProcess::send(self : Self, message : &JsImpl) -> Bool {
 89 |   self.call("send", [message.to_js()]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ChildProcess::disconnect(self : Self) -> Unit {
 95 |   self.call("disconnect", []) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn spawn(
    |   command : String,
    |   args? : Array[String],
    |   cwd? : String,
    |   env? : Js,
    |   shell? : Bool,
    |   timeout? : Int,
    |   signal? : AbortSignal,
    | ) -> ChildProcess {
    |   let cp = ffi_require_child_process()
    |   let options = @js.Object::new()
    |   if args is Some(_) {
    |     // args will be passed separately
    |   }
    |   if cwd is Some(c) {
133 |     options.set("cwd", c)
    |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if env is Some(e) {
136 |     options.set("env", e)
    |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if shell is Some(s) {
139 |     options.set("shell", s)
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if timeout is Some(t) {
142 |     options.set("timeout", t)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if signal is Some(sig) {
145 |     options.set("signal", sig.to_js())
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   match args {
    |     Some(a) =>
    |       unsafe_cast(
    |         cp.call("spawn", [command |> js, a |> @js.from_array, options]),
    |       )
152 |     None => unsafe_cast(cp.call("spawn", [command |> js, options]))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub fn exec(
    |   command : String,
    |   callback : (Js?, String, String) -> Unit noraise,
    |   cwd? : String,
    |   env? : Js,
    |   shell? : String,
    |   timeout? : Int,
    |   max_buffer? : Int,
    |   signal? : AbortSignal,
    | ) -> ChildProcess {
169 |   let cp = ffi_require_child_process()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let options = @js.Object::new()
    |   if cwd is Some(c) {
172 |     options.set("cwd", c)
    |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if env is Some(e) {
175 |     options.set("env", e)
    |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if shell is Some(s) {
178 |     options.set("shell", s)
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if timeout is Some(t) {
181 |     options.set("timeout", t)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if max_buffer is Some(mb) {
184 |     options.set("maxBuffer", mb)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if signal is Some(sig) {
187 |     options.set("signal", sig.to_js())
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
189 |   unsafe_cast(cp.call("exec", [command |> js, options, unsafe_cast(callback)]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(exec_file)
    | pub fn execFile(
    |   file : String,
    |   args : Array[String],
    |   callback : (Js?, String, String) -> Unit noraise,
    |   cwd? : String,
    |   env? : Js,
    |   timeout? : Int,
    |   max_buffer? : Int,
    |   signal? : AbortSignal,
    | ) -> ChildProcess {
206 |   let cp = ffi_require_child_process()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let options = @js.Object::new()
    |   if cwd is Some(c) {
209 |     options.set("cwd", c)
    |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if env is Some(e) {
212 |     options.set("env", e)
    |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if timeout is Some(t) {
215 |     options.set("timeout", t)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if max_buffer is Some(mb) {
218 |     options.set("maxBuffer", mb)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if signal is Some(sig) {
221 |     options.set("signal", sig.to_js())
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
223 |   unsafe_cast(
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     cp.call("execFile", [
    |       file,
226 |       args |> @js.from_array,
    |       ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       options,
228 |       unsafe_cast(callback),
    |       ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ]),
    |   )
    | }
    …

    | pub fn fork(
    |   module_path : String,
    |   args? : Array[String],
    |   cwd? : String,
    |   env? : Js,
    |   silent? : Bool,
    |   timeout? : Int,
    |   signal? : AbortSignal,
    | ) -> ChildProcess {
245 |   let cp = ffi_require_child_process()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let options = @js.Object::new()
    |   if cwd is Some(c) {
248 |     options.set("cwd", c)
    |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if env is Some(e) {
251 |     options.set("env", e)
    |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if silent is Some(s) {
254 |     options.set("silent", s)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if timeout is Some(t) {
257 |     options.set("timeout", t)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if signal is Some(sig) {
260 |     options.set("signal", sig.to_js())
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
262 |   match args {
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(a) =>
264 |       unsafe_cast(
    |       ^^^^^^^^^^^^ 	<-- UNCOVERED
    |         cp.call("fork", [module_path |> js, a |> @js.from_array, options]),
    |       )
267 |     None => unsafe_cast(cp.call("fork", [module_path |> js, options]))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub fn SpawnSyncResult::signal(self : Self) -> String? {
293 |   self.get("signal") |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SpawnSyncResult::error(self : Self) -> Js? {
308 |   self.get("error") |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(spawn_sync)
    | pub fn spawnSync(
    |   command : String,
    |   args? : Array[String],
    |   cwd? : String,
    |   env? : Js,
    |   shell? : Bool,
    |   timeout? : Int,
    |   input? : String,
    | ) -> SpawnSyncResult {
    |   let cp = ffi_require_child_process()
    |   let options = @js.Object::new()
    |   if cwd is Some(c) {
327 |     options.set("cwd", c)
    |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if env is Some(e) {
330 |     options.set("env", e)
    |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if shell is Some(s) {
333 |     options.set("shell", s)
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if timeout is Some(t) {
336 |     options.set("timeout", t)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if input is Some(i) {
339 |     options.set("input", i)
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   match args {
    |     Some(a) =>
    |       unsafe_cast(cp.call("spawnSync", [command, a |> @js.from_array, options]))
344 |     None => unsafe_cast(cp.call("spawnSync", [command |> js, options]))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | #alias(exec_sync)
    | pub fn execSync(
    |   command : String,
    |   cwd? : String,
    |   env? : Js,
    |   shell? : String,
    |   timeout? : Int,
    |   maxBuffer? : Int,
    |   input? : String,
    |   encoding? : String,
    | ) -> String {
    |   let cp = ffi_require_child_process()
    |   let options = @js.Object::new()
    |   if cwd is Some(c) {
    |     options.set("cwd", c)
    |   }
    |   if env is Some(e) {
368 |     options.set("env", e)
    |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if shell is Some(s) {
371 |     options.set("shell", s)
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if timeout is Some(t) {
374 |     options.set("timeout", t)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if maxBuffer is Some(mb) {
377 |     options.set("maxBuffer", mb)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if input is Some(i) {
380 |     options.set("input", i)
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if encoding is Some(enc) {
383 |     options.set("encoding", enc)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   } else {
    |     options.set("encoding", "utf8")
    |   }
    |   unsafe_cast(cp.call("execSync", [command |> js, options]))
    | }
    …

    | #alias(exec_file_sync)
    | pub fn execFileSync(
    |   file : String,
    |   args? : Array[String],
    |   cwd? : String,
    |   env? : Js,
    |   timeout? : Int,
    |   maxBuffer? : Int,
    |   input? : String,
    |   encoding? : String,
    | ) -> String {
    |   let cp = ffi_require_child_process()
    |   let options = @js.Object::new()
    |   if cwd is Some(c) {
407 |     options.set("cwd", c)
    |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if env is Some(e) {
410 |     options.set("env", e)
    |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if timeout is Some(t) {
413 |     options.set("timeout", t)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if maxBuffer is Some(mb) {
416 |     options.set("maxBuffer", mb)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if input is Some(i) {
419 |     options.set("input", i)
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if encoding is Some(enc) {
422 |     options.set("encoding", enc)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   } else {
    |     options.set("encoding", "utf8")
    |   }
    |   match args {
    |     Some(a) =>
    |       unsafe_cast(cp.call("execFileSync", [file, a |> @js.from_array, options]))
429 |     None => unsafe_cast(cp.call("execFileSync", [file, options]))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

13 uncovered line(s) in src/node/child_process/typed_listener.mbt:

   | pub fn ChildProcess::on_exit(
   |   self : Self,
   |   callback : (Int?, String?) -> Unit noraise,
   | ) -> Unit {
10 |   self.call("on", [
   |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     "exit",
12 |     unsafe_cast(fn(code : Js, signal : Js) {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       callback(
   |         code |> @js.unsafe_cast_option(),
   |         signal |> @js.unsafe_cast_option(),
   |       )
   |     }),
   |   ])
19 |   |> ignore
   |   ^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn ChildProcess::on_close(
   |   self : Self,
   |   callback : (Int?, String?) -> Unit noraise,
   | ) -> Unit {
29 |   self.call("on", [
   |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     "close",
31 |     unsafe_cast(fn(code : Js, signal : Js) {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       callback(
   |         code |> @js.unsafe_cast_option(),
   |         signal |> @js.unsafe_cast_option(),
   |       )
   |     }),
   |   ])
38 |   |> ignore
   |   ^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn ChildProcess::on_error(
   |   self : Self,
   |   callback : (Js) -> Unit noraise,
   | ) -> Unit {
48 |   self.call("on", ["error", unsafe_cast(callback)]) |> ignore
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn ChildProcess::on_message(
   |   self : Self,
   |   callback : (Js, Js?) -> Unit noraise,
   | ) -> Unit {
58 |   self.call("on", [
   |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     "message",
60 |     unsafe_cast(fn(message : Js, sendHandle : Js) {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       callback(message, sendHandle |> @js.unsafe_cast_option())
   |     }),
   |   ])
64 |   |> ignore
   |   ^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn ChildProcess::on_disconnect(
   |   self : Self,
   |   callback : () -> Unit noraise,
   | ) -> Unit {
74 |   self.call("on", ["disconnect", unsafe_cast(callback)]) |> ignore
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn ChildProcess::on_spawn(
   |   self : Self,
   |   callback : () -> Unit noraise,
   | ) -> Unit {
84 |   self.call("on", ["spawn", unsafe_cast(callback)]) |> ignore
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn ChildProcess::on_stdout_data(
   |   self : Self,
   |   callback : (Js) -> Unit noraise,
   | ) -> Unit {
94 |   match self.stdout() {
   |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     Some(stream) => stream.call("on", ["data", unsafe_cast(callback)]) |> ignore
   |     None => ()
   |   }
   | }
   …

9 uncovered line(s) in src/node/events/event_emitter.mbt:

   | impl EventEmitterImpl with on2(
   |   self,
   |   name : String,
   |   callback : (Js?, Js) -> Unit,
   | ) -> Unit {
33 |   self.call("on", [name, callback |> @js.from_fn2]) |> unsafe_cast
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | impl EventEmitterImpl with eventNames(self) {
43 |   self.call("eventNames", []) |> unsafe_cast
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | impl EventEmitterImpl with listenerCount(self, eventName) {
48 |   self.call("listenerCount", [eventName]) |> unsafe_cast
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | impl EventEmitterImpl with listeners(self, event? : String) {
53 |   match event {
   |   ^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     Some(name) => self.call("listenerCount", [name]) |> unsafe_cast
   |     None => self.call("listenerCount", []) |> unsafe_cast
   |   }
   | }
   …

   | impl EventEmitterImpl with off(self, name : String, callback : (Js) -> Unit) -> Unit {
61 |   self.call("off", [name, callback |> @js.from_fn1]) |> unsafe_cast
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | impl EventEmitterImpl with removeListener(
   |   self,
   |   name : String,
   |   callback : (Js) -> Unit,
   | ) -> Unit {
70 |   self.call("removeListener", [name, callback |> unsafe_cast]) |> unsafe_cast
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | impl EventEmitterImpl with removeAllListeners(self) -> Unit {
76 |   self.call("removeAllListeners", []) |> unsafe_cast
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | impl EventEmitterImpl with emit(self, name : String, payload : Js) -> Unit {
81 |   self.call("emit", [name, payload]) |> unsafe_cast
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn EventEmitter::new() -> EventEmitter {
97 |   let ee = @node.require("events").get("EventEmitter")
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   unsafe_cast(@js.new_(ee, []))
   | }
   …

5 uncovered line(s) in src/node/fs/fs.mbt:

    | #alias(rm_sync)
    | pub fn rmSync(path : String, recursive? : Bool, force? : Bool) -> Unit {
    |   let fs = fs_module()
    |   match (recursive, force) {
115 |     (Some(r), Some(f)) => {
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let options = @js.Object::new()
    |       options.set("recursive", r)
    |       options.set("force", f)
    |       fs.call("rmSync", [path, options]) |> ignore
    |     }
    |     (Some(r), None) => {
    |       let options = @js.Object::new()
    |       options.set("recursive", r)
    |       fs.call("rmSync", [path, options]) |> ignore
    |     }
126 |     (None, Some(f)) => {
    |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let options = @js.Object::new()
    |       options.set("force", f)
    |       fs.call("rmSync", [path, options]) |> ignore
    |     }
131 |     (None, None) => fs.call("rmSync", [path]) |> ignore
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub fn createReadStream(path : String) -> @stream.Readable {
137 |   let fs = fs_module()
    |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   fs.call("createReadStream", [path]) |> unsafe_cast
    | }
    …

    | pub fn createWriteStream(path : String) -> @stream.Writable {
143 |   let fs = fs_module()
    |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   fs.call("createWriteStream", [path]) |> unsafe_cast
    | }
    …

4 uncovered line(s) in src/node/fs/stat.mbt:

   | pub fn Stat::isFile(self : Self) -> Bool {
10 |   self.call("isFile", []) |> unsafe_cast
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Stat::isDirectory(self : Self) -> Bool {
15 |   self.call("isFile", []) |> unsafe_cast
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Stat::size(self : Self) -> Int {
20 |   unsafe_cast(self.get("size"))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Stat::mtime_ms(self : Self) -> Float {
25 |   let mtime = self.get("mtime")
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   unsafe_cast(mtime.get("getTime").call("call", [mtime]))
   | }
   …

26 uncovered line(s) in src/node/fs_promises/promises.mbt:

    | pub fn stat(path : String) -> Promise[Stat] {
 16 |   let fs = @node.require("node:fs/promises")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   unsafe_cast(fs.call("stat", [path]))
    | }
    …

    | pub fn mkdir(path : String, recursive? : Bool) -> Promise[Unit] {
 23 |   let fs = @node.require("node:fs/promises")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let options = @js.Object::new()
    |   if recursive is Some(r) {
 26 |     options.set("recursive", r)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
 28 |   unsafe_cast(fs.call("mkdir", [path, options]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn glob(
    |   path : String,
    |   cwd? : String,
    |   exclude? : Array[String],
    |   exclude_fn? : (String) -> Bool,
    | ) -> AsyncIterator[String] {
 39 |   let fs = @node.require("node:fs/promises")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let opts = @js.Object::new()
    |   if cwd is Some(c) {
 42 |     opts.set("cwd", c)
    |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if exclude is Some(e) {
 45 |     opts.set("exclude", e |> @js.from_array)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if exclude_fn is Some(f) {
 48 |     opts.set("exclude", f |> @js.from_fn1)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
 50 |   unsafe_cast(fs.call("glob", [path]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(is_file)
    | pub fn Dirent::isFile(self : Self) -> Bool {
 63 |   self.call("isFile", []) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(is_directory)
    | pub fn Dirent::isDirectory(self : Self) -> Bool {
 69 |   self.call("isDirectory", []) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Dirent::name(self : Self) -> String {
 74 |   unsafe_cast(self.get("name"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn glob_with_filetype(
    |   path : String,
    |   cwd? : String,
    |   exclude? : Array[String],
    |   exclude_fn? : (String) -> Bool,
    | ) -> AsyncIterator[Dirent] {
 84 |   let fs = @node.require("node:fs/promises")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let opts = @js.Object::new()
    |   opts.set("withFileTypes", true)
    |   if cwd is Some(c) {
 88 |     opts.set("cwd", c)
    |     ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if exclude is Some(e) {
 91 |     opts.set("exclude", e |> @js.from_array)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if exclude_fn is Some(f) {
 94 |     opts.set("exclude", f |> @js.from_fn1)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
 96 |   unsafe_cast(fs.call("glob", [path]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn open(path : String) -> Promise[FileHandle] {
106 |   let fs = @node.require("node:fs/promises")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   unsafe_cast(fs.call("open", [path]))
    | }
    …

    | #alias(read_file)
    | pub fn readFile(path : String, encoding? : String = "utf-8") -> Promise[String] {
113 |   let fs = @node.require("node:fs/promises")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   unsafe_cast(fs.call("readFile", [path, encoding]))
    | }
    …

    | #alias(write_file)
    | pub fn writeFile(
    |   path : String,
    |   content : String,
    |   encoding? : String = "utf-8",
    |   mode? : Int = 0o666,
    |   flag? : String = "w",
    |   flush? : Bool = false,
    |   signal? : AbortSignal,
    | ) -> Promise[Unit] {
128 |   let fs = @node.require("node:fs/promises")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let opts = @js.Object::new()
    |   opts.set("encoding", encoding)
    |   opts.set("mode", mode)
    |   opts.set("flag", flag)
    |   opts.set("flush", flush)
    |   if signal is Some(s) {
135 |     opts.set("signal", s)
    |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
137 |   let promise = fs.call("writeFile", [path, content, opts])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   unsafe_cast(promise)
    | }
    …

    | pub fn rename(path : String, dest : String) -> Promise[Unit] {
143 |   let fs = @node.require("node:fs/promises")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   unsafe_cast(fs.call("rename", [path, dest]))
    | }
    …

    | pub fn rm(path : String, recursive? : Bool, force? : Bool) -> Promise[Unit] {
    |   let fs = @node.require("node:fs/promises")
    |   let opts = @js.Object::new()
    |   if recursive is Some(r) {
152 |     opts.set("recursive", r)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if force is Some(f) {
155 |     opts.set("force", f)
    |     ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let promise = fs.call("rm", [path, opts])
    |   unsafe_cast(promise)
    | }
    …

    | pub fn cp(path : String, dest : String) -> Promise[Unit] {
163 |   let fs = @node.require("node:fs/promises")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let promise = fs.call("cp", [path, dest])
    |   unsafe_cast(promise)
    | }
    …

12 uncovered line(s) in src/node/module/module.mbt:

    | #alias(enable_compile_cache)
    | pub fn enableCompileCache(cache_dir? : String) -> Unit {
    |   let mod = ffi_require_module()
    |   match cache_dir {
 60 |     Some(dir) => {
    |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let options = @js.Object::new()
    |       options.set("cacheDir", dir)
    |       mod.call("enableCompileCache", [options]) |> ignore
    |     }
    |     None => mod.call("enableCompileCache", []) |> ignore
    |   }
    | }
    …

    | #alias(strip_typescript_types)
    | pub fn stripTypeScriptTypes(
    |   code : String,
    |   mode? : String,
    |   source_map? : Bool,
    |   source_url? : String,
    | ) -> String {
    |   let mod = ffi_require_module()
    |   match (mode, source_map, source_url) {
    |     (None, None, None) => unsafe_cast(mod.call("stripTypeScriptTypes", [code]))
    |     _ => {
    |       let options = @js.Object::new()
    |       match mode {
    |         Some(m) => options.set("mode", m)
107 |         None => ()
    |         ^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |       match source_map {
110 |         Some(sm) => options.set("sourceMap", sm)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         None => ()
    |       }
    |       match source_url {
114 |         Some(url) => options.set("sourceUrl", url)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         None => ()
    |       }
    |       unsafe_cast(mod.call("stripTypeScriptTypes", [code, options]))
    |     }
    |   }
    | }
    …

    | pub fn SourceMap::payload(self : Self) -> Js {
135 |   self.get("payload")
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(find_entry)
    | pub fn SourceMap::findEntry(
    |   self : Self,
    |   line_number : Int,
    |   column_number : Int,
    | ) -> SourceMapEntry? {
147 |   self.call("findEntry", [line_number, column_number])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   |> @js.unsafe_cast_option()
    | }
    …

    | #alias(original_line)
    | pub fn SourceMapEntry::originalLine(self : Self) -> Int {
165 |   unsafe_cast(self.get("originalLine"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(original_column)
    | pub fn SourceMapEntry::originalColumn(self : Self) -> Int {
172 |   unsafe_cast(self.get("originalColumn"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(original_source)
    | pub fn SourceMapEntry::originalSource(self : Self) -> String {
179 |   unsafe_cast(self.get("originalSource"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(generated_line)
    | pub fn SourceMapEntry::generatedLine(self : Self) -> Int {
186 |   unsafe_cast(self.get("generatedLine"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(generated_column)
    | pub fn SourceMapEntry::generatedColumn(self : Self) -> Int {
193 |   unsafe_cast(self.get("generatedColumn"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SourceMapEntry::name(self : Self) -> String? {
199 |   self.get("name") |> @js.unsafe_cast_option()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

39 uncovered line(s) in src/node/net/net.mbt:

    | fn net_module() -> Js {
  4 |   @node.require("node:net")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Socket::as_duplex(self : Socket) -> Duplex {
 22 |   unsafe_cast(self)
    |   ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Socket::connect(self : Socket, port : Int, host? : String) -> Socket {
 28 |   match host {
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(h) => self.call("connect", [port, h]) |> unsafe_cast
    |     None => self.call("connect", [port]) |> unsafe_cast
    |   }
    | }
    …

    | pub fn Socket::write(self : Socket, data : String) -> Bool {
 37 |   self.call("write", [data]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Socket::end(self : Socket) -> Socket {
 43 |   self.call("end", []) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Socket::destroy(self : Socket) -> Socket {
 49 |   self.call("destroy", []) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Socket::pause(self : Socket) -> Socket {
 55 |   self.call("pause", []) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Socket::resume_(self : Socket) -> Socket {
 61 |   self.call("resume", []) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Socket::setEncoding(self : Socket, encoding : String) -> Socket {
 67 |   self.call("setEncoding", [encoding]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Socket::setKeepAlive(self : Socket, enable : Bool) -> Socket {
 73 |   self.call("setKeepAlive", [enable]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Socket::setNoDelay(self : Socket, noDelay : Bool) -> Socket {
 79 |   self.call("setNoDelay", [noDelay]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Socket::setTimeout(self : Socket, timeout : Int) -> Socket {
 85 |   self.call("setTimeout", [timeout]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Socket::remoteAddress(self : Socket) -> String? {
 91 |   self.get("remoteAddress") |> @js.unsafe_cast_option
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Socket::remotePort(self : Socket) -> Int? {
 97 |   self.get("remotePort") |> @js.unsafe_cast_option
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Socket::localAddress(self : Socket) -> String? {
103 |   self.get("localAddress") |> @js.unsafe_cast_option
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Socket::localPort(self : Socket) -> Int? {
109 |   self.get("localPort") |> @js.unsafe_cast_option
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Socket::destroyed(self : Socket) -> Bool {
115 |   self.get("destroyed") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Socket::bytesRead(self : Socket) -> Int {
121 |   self.get("bytesRead") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Socket::bytesWritten(self : Socket) -> Int {
127 |   self.get("bytesWritten") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Server::listen(
    |   self : Server,
    |   port : Int,
    |   host? : String,
    |   backlog? : Int,
    |   callback? : () -> Unit,
    | ) -> Server {
    |   // Register callback as 'listening' event listener if provided
152 |   match callback {
    |   ^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(cb) => self.once("listening", fn(_) { cb() })
    |     None => ()
    |   }
    | 
    |   // Call listen with port, host, and backlog
158 |   match (host, backlog) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(h), Some(b)) => self.call("listen", [port, h, b]) |> unsafe_cast
    |     (Some(h), None) => self.call("listen", [port, h]) |> unsafe_cast
    |     (None, Some(b)) => self.call("listen", [port, b]) |> unsafe_cast
    |     (None, None) => self.call("listen", [port]) |> unsafe_cast
    |   }
    | }
    …

    | pub fn Server::close(self : Server) -> Server {
169 |   self.call("close", []) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Server::address(self : Server) -> Js? {
175 |   self.call("address", []) |> @js.unsafe_cast_option
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Server::listening(self : Server) -> Bool {
181 |   self.get("listening") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Server::maxConnections(self : Server) -> Int? {
187 |   self.get("maxConnections") |> @js.unsafe_cast_option
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Server::set_maxConnections(self : Server, max : Int) -> Unit {
193 |   self.set("maxConnections", max |> @js.js)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn createConnection(port : Int, host? : String) -> Socket {
201 |   match host {
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(h) => net_module().call("createConnection", [port, h]) |> unsafe_cast
    |     None => net_module().call("createConnection", [port]) |> unsafe_cast
    |   }
    | }
    …

    | pub fn connect(port : Int, host? : String) -> Socket {
210 |   createConnection(port, host?)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn createServer(
    |   allowHalfOpen? : Bool,
    |   pauseOnConnect? : Bool,
    |   noDelay? : Bool,
    |   keepAlive? : Bool,
    |   keepAliveInitialDelay? : Int,
    | ) -> Server {
222 |   let has_options = not(allowHalfOpen.is_empty()) ||
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     not(pauseOnConnect.is_empty()) ||
    |     not(noDelay.is_empty()) ||
    |     not(keepAlive.is_empty()) ||
    |     not(keepAliveInitialDelay.is_empty())
    |   if has_options {
228 |     let options = @js.Object::new()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     match allowHalfOpen {
    |       Some(v) => options.set("allowHalfOpen", v)
    |       None => ()
    |     }
233 |     match pauseOnConnect {
    |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       Some(v) => options.set("pauseOnConnect", v)
    |       None => ()
    |     }
237 |     match noDelay {
    |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       Some(v) => options.set("noDelay", v)
    |       None => ()
    |     }
241 |     match keepAlive {
    |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       Some(v) => options.set("keepAlive", v)
    |       None => ()
    |     }
245 |     match keepAliveInitialDelay {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       Some(v) => options.set("keepAliveInitialDelay", v)
    |       None => ()
    |     }
249 |     net_module().call("createServer", [options]) |> unsafe_cast
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   } else {
251 |     net_module().call("createServer", []) |> unsafe_cast
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub fn isIPv4(input : String) -> Bool {
258 |   net_module().call("isIPv4", [input]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn isIPv6(input : String) -> Bool {
264 |   net_module().call("isIPv6", [input]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn isIP(input : String) -> Int {
270 |   net_module().call("isIP", [input]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

3 uncovered line(s) in src/node/os/os.mbt:

    | #alias(userinfo_with_encoding)
    | pub fn userInfoWithEncoding(encoding : String) -> Js {
145 |   let options = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   options.set("encoding", encoding)
    |   os_module().call("userInfo", [options])
    | }
    …

    | #alias(get_priority)
    | pub fn getPriority(pid~ : Int?) -> Int {
    |   match pid {
173 |     Some(p) => unsafe_cast(os_module().call("getPriority", [p]))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => unsafe_cast(os_module().call("getPriority", []))
    |   }
    | }
    …

    | #alias(set_priority)
    | pub fn setPriority(priority : Int, pid~ : Int?) -> Unit {
182 |   match pid {
    |   ^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(p) => os_module().call("setPriority", [p, priority]) |> ignore
    |     None => os_module().call("setPriority", [priority]) |> ignore
    |   }
    | }
    …

5 uncovered line(s) in src/node/process/process.mbt:

   | pub fn versions() -> @js.Object {
40 |   unsafe_cast(process().get("version"))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn isTTY() -> Bool {
46 |   unsafe_cast(process().get("isTTY"))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn chdir(path : String) -> Unit {
52 |   unsafe_cast(process().get("chdir").call_self([path]))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn exit(code : Int) -> Unit {
58 |   process().get("exit").call_self([code]) |> ignore
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn on(sig : String, listener : () -> Unit) -> Unit {
85 |   unsafe_cast(process().call("on", [sig, @js.from_fn0(listener)]))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

19 uncovered line(s) in src/node/readline_promises/readline.mbt:

    | #alias(create_interface)
    | pub fn createInterface(
    |   input~ : @stream.Stream,
    |   output? : @stream.Stream,
    |   completer? : (String) -> Array[String],
    |   terminator? : String,
    |   history? : Array[String],
    |   removeHistoryDuplicates? : Bool,
    |   prompt? : String,
    |   crlfDelay? : Int,
    |   escapeCodeTimeout? : Int,
    |   tabSize? : Int,
    |   signal? : AbortSignal,
    | ) -> Interface {
 36 |   let opts = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   opts.set("input", input.to_js())
    |   if output is Some(v) {
 39 |     opts.set("output", v)
    |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   // opts.set("output", output.to_js())
    |   if completer is Some(v) {
 43 |     opts.set("completer", v |> @js.from_fn1)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if terminator is Some(v) {
 46 |     opts.set("terminator", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if history is Some(v) {
 49 |     opts.set("history", v |> @js.from_array)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if removeHistoryDuplicates is Some(v) {
 52 |     opts.set("removeHistoryDuplicates", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if prompt is Some(v) {
 55 |     opts.set("prompt", v)
    |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if crlfDelay is Some(v) {
 58 |     opts.set("crlfDelay", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if escapeCodeTimeout is Some(v) {
 61 |     opts.set("escapeCodeTimeout", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if tabSize is Some(v) {
 64 |     opts.set("tabSize", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if signal is Some(v) {
 67 |     opts.set("signal", v)
    |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
 69 |   unsafe_cast(
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     @node.require("node:readline/promises")
    |     .get("createInterface")
    |     .call_self([opts]),
    |   )
    | }
    …

    | pub fn Interface::question(self : Self, query : String) -> Promise[String] {
 78 |   self.call("question", [query]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Interface::commit(self : Self) -> Promise[Unit] {
 83 |   self.call("commit", []) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Interface::rollback(self : Self) -> Self {
 88 |   self.call("rollback", []) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(cursor_to)
    | pub fn Interface::cursorTo(self : Self, x : Int, y? : Int) -> Promise[Unit] {
 94 |   self.call("cursorTo", [x, y]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(move_cursor)
    | pub fn Interface::moveCursor(self : Self, dx : Int, dy? : Int) -> Promise[Unit] {
100 |   self.call("moveCursor", [dx, dy]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(clear_line)
    | pub fn Interface::clearLine(self : Self, dir : Int) -> Self {
106 |   self.call("clearLine", [dir]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(clear_screen_down)
    | pub fn Interface::clearScreenDown(self : Self, dir : Int) -> Self {
112 |   self.call("clearScreenDown", [dir]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

94 uncovered line(s) in src/node/sqlite/sqlite.mbt:

    | pub fn DatabaseSync::new(
    |   path : String,
    |   open? : Bool,
    |   readOnly? : Bool,
    |   enableForeignKeyConstraints? : Bool,
    |   allowExtension? : Bool,
    |   timeout? : Int,
    |   readBigInts? : Bool,
    |   returnArrays? : Bool,
    |   allowBareNamedParameters? : Bool,
    |   allowUnknownNamedParameters? : Bool,
    |   defensive? : Bool,
    | ) -> DatabaseSync {
    |   let opts = @js.Object::new()
    |   if open is Some(v) {
 68 |     opts.set("open", v)
    |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if readOnly is Some(v) {
 71 |     opts.set("readOnly", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if allowExtension is Some(v) {
 74 |     opts.set("allowExtension", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if enableForeignKeyConstraints is Some(v) {
 77 |     opts.set("enableForeignKeyConstraints", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if timeout is Some(v) {
 80 |     opts.set("timeout", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if readBigInts is Some(v) {
    |     opts.set("readBigInts", v)
    |   }
    |   if returnArrays is Some(v) {
 86 |     opts.set("returnArrays", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if allowBareNamedParameters is Some(v) {
 89 |     opts.set("allowBareNamedParameters", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if allowUnknownNamedParameters is Some(v) {
 92 |     opts.set("allowUnknownNamedParameters", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if defensive is Some(v) {
 95 |     opts.set("defensive", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let v = @node.require("node:sqlite").get("DatabaseSync")
    |     |> @js.new_([path, opts])
    |   unsafe_cast(v)
    | }
    …

    | pub fn[T, U] DatabaseSync::aggregate(
    |   self : Self,
    |   name : String,
    |   deterministic? : Bool,
    |   directOnly? : Bool,
    |   useBigIntArguments? : Bool,
    |   varargs? : Bool,
    |   start? : U,
    |   step? : (T, U) -> T,
    |   inverse? : (T, U) -> T,
    |   result? : (T) -> Js,
    | ) -> Unit {
    |   let opts = @js.Object::new()
    |   if deterministic is Some(v) {
117 |     opts.set("deterministic", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if directOnly is Some(v) {
120 |     opts.set("directOnly", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if useBigIntArguments is Some(v) {
123 |     opts.set("useBigIntArguments", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if varargs is Some(v) {
126 |     opts.set("varargs", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if start is Some(v) {
    |     opts.set("start", v |> @js.unsafe_js)
    |   }
    |   if step is Some(v) {
    |     opts.set("step", v |> @js.unsafe_js)
    |   }
    |   if inverse is Some(v) {
135 |     opts.set("inverse", v |> @js.unsafe_js)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if result is Some(v) {
    |     opts.set("result", v |> @js.unsafe_js)
    |   }
    |   self.call("aggregate", [name, opts]) |> ignore
    | }
    …

    | pub fn DatabaseSync::function(
    |   self : Self,
    |   name : String,
    |   func : (Array[Js]) -> Js,
    |   deterministic? : Bool,
    |   directOnly? : Bool,
    |   useBigIntArguments? : Bool,
    |   varargs? : Bool,
    | ) -> Unit {
153 |   let opts = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   if deterministic is Some(v) {
155 |     opts.set("deterministic", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if directOnly is Some(v) {
158 |     opts.set("directOnly", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if useBigIntArguments is Some(v) {
161 |     opts.set("useBigIntArguments", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if varargs is Some(v) {
164 |     opts.set("varargs", v)
    |     ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
166 |   self.call("function", [name, opts, func |> unsafe_cast]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(set_authorizer)
    | pub fn DatabaseSync::setAuthorizer(
    |   self : Self,
    |   callback : (Int, String?, String?, String?, String?) -> Int,
    | ) -> Unit {
175 |   self.call("setAuthorizer", [callback |> @js.unsafe_js]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DatabaseSync::location(self : Self, db_name? : String) -> String? {
    |   let args : Array[&JsImpl] = if db_name is Some(name) { [name] } else { [] }
    |   let result = self.call("location", args)
    |   if @js.is_null(result) {
    |     None
    |   } else {
185 |     Some(unsafe_cast(result))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | #alias(load_extension)
    | pub fn DatabaseSync::loadExtension(self : Self, path : String) -> Unit {
192 |   self.call("loadExtension", [path]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(enable_load_extension)
    | pub fn DatabaseSync::enableLoadExtension(self : Self, allow : Bool) -> Unit {
198 |   self.call("enableLoadExtension", [allow]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn DatabaseSync::open(self : Self) -> Unit {
215 |   self.call("open", []) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(create_tag_store)
    | pub fn DatabaseSync::createTagStore(
    |   self : Self,
    |   max_size? : Int,
    | ) -> SQLTagStore {
229 |   let args : Array[&JsImpl] = if max_size is Some(size) { [size] } else { [] }
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   self.call("createTagStore", args) |> unsafe_cast
    | }
    …

    | #alias(create_session)
    | pub fn DatabaseSync::createSession(
    |   self : Self,
    |   table? : String,
    |   db? : String,
    | ) -> Session {
    |   let v = @js.Object::new()
    |   if table is Some(t) {
242 |     v.set("table", t)
    |     ^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if db is Some(d) {
245 |     v.set("db", d)
    |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   self.call("createSession", [v]) |> unsafe_cast
    | }
    …

    | #alias(apply_changeset)
    | pub fn DatabaseSync::applyChangeset(
    |   self : Self,
    |   changeset : Uint8Array,
    |   filter? : (Js) -> Bool,
    |   onConflict? : (Js?, Js) -> Bool,
    | ) -> Bool {
    |   let opts = @js.Object::new()
    |   if filter is Some(f) {
270 |     opts.set("filter", f |> @js.from_fn1)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if onConflict is Some(oc) {
273 |     opts.set("onConflict", oc |> @js.from_fn2)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   self.call("applyChangeset", [changeset, opts]) |> unsafe_cast
    | }
    …

    | pub fn StatementSync::iterate(
    |   self : Self,
    |   named_parameters? : Map[String, &JsImpl],
    |   anonymous_parameters? : Array[&JsImpl],
    | ) -> JsIterator[Js] {
    |   let args : Array[&JsImpl] = []
    |   if named_parameters is Some(params) {
371 |     let obj = @js.Object::new()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     for key, value in params {
373 |       obj.set(key, value.to_js())
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
375 |     args.push(obj)
    |     ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if anonymous_parameters is Some(params_arr) {
    |     for param in params_arr {
    |       args.push(param)
    |     }
    |   }
    |   self.call("iterate", args) |> unsafe_cast
    | }
    …

    | #alias(expanded_sql)
    | pub fn StatementSync::expandedSQL(self : Self) -> String {
388 |   unsafe_cast(self.get("expandedSQL"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(set_allow_bare_named_parameters)
    | pub fn StatementSync::setAllowBareNamedParameters(
    |   self : Self,
    |   enabled : Bool,
    | ) -> Unit {
403 |   self.call("setAllowBareNamedParameters", [enabled]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(set_allow_unknown_named_parameters)
    | pub fn StatementSync::setAllowUnknownNamedParameters(
    |   self : Self,
    |   enabled : Bool,
    | ) -> Unit {
412 |   self.call("setAllowUnknownNamedParameters", [enabled]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(set_return_arrays)
    | pub fn StatementSync::setReturnArrays(self : Self, enabled : Bool) -> Unit {
418 |   self.call("setReturnArrays", [enabled]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(set_read_big_ints)
    | pub fn StatementSync::setReadBigInts(self : Self, enabled : Bool) -> Unit {
424 |   self.call("setReadBigInts", [enabled]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Session::patchset(self : Self) -> Uint8Array {
450 |   self.call("patchset", []) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SQLTagStore::capacity(self : Self) -> Int {
467 |   unsafe_cast(self.get("capacity"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SQLTagStore::size(self : Self) -> Int {
472 |   self.call("size", []) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SQLTagStore::clear(self : Self) -> Unit {
477 |   self.call("clear", []) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn SQLTagStore::db(self : Self) -> DatabaseSync {
482 |   unsafe_cast(self.get("db"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn backup(
    |   source_db : DatabaseSync,
    |   db_path : String,
    |   rate? : Int,
    |   source? : String,
    |   target? : String,
    |   progress? : (BackupProgress) -> Unit,
    | ) -> Unit {
500 |   let opts = @js.Object::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   if rate is Some(v) {
502 |     opts.set("rate", v)
    |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if source is Some(v) {
505 |     opts.set("source", v)
    |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if target is Some(v) {
508 |     opts.set("target", v)
    |     ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if progress is Some(f) {
511 |     opts.set("progress", f |> @js.from_fn1)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
513 |   let backup : Js = @node.require("node:sqlite").get("backup")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   backup.call_self([source_db.to_js(), db_path, opts]) |> ignore
    | }
    …

    | fn get_constants() -> Js {
520 |   let sqlite = @node.require("node:sqlite")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   sqlite.get("constants")
    | }
    …

    | pub fn sqlite_changeset_data() -> Int {
526 |   unsafe_cast(get_constants().get("SQLITE_CHANGESET_DATA"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_changeset_notfound() -> Int {
531 |   unsafe_cast(get_constants().get("SQLITE_CHANGESET_NOTFOUND"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_changeset_conflict() -> Int {
536 |   unsafe_cast(get_constants().get("SQLITE_CHANGESET_CONFLICT"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_changeset_foreign_key() -> Int {
541 |   unsafe_cast(get_constants().get("SQLITE_CHANGESET_FOREIGN_KEY"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_changeset_omit() -> Int {
546 |   unsafe_cast(get_constants().get("SQLITE_CHANGESET_OMIT"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_changeset_replace() -> Int {
551 |   unsafe_cast(get_constants().get("SQLITE_CHANGESET_REPLACE"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_changeset_abort() -> Int {
556 |   unsafe_cast(get_constants().get("SQLITE_CHANGESET_ABORT"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_deny() -> Int {
561 |   unsafe_cast(get_constants().get("SQLITE_DENY"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_ignore() -> Int {
566 |   unsafe_cast(get_constants().get("SQLITE_IGNORE"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_ok() -> Int {
571 |   unsafe_cast(get_constants().get("SQLITE_OK"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_create_index() -> Int {
576 |   unsafe_cast(get_constants().get("SQLITE_CREATE_INDEX"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_create_table() -> Int {
581 |   unsafe_cast(get_constants().get("SQLITE_CREATE_TABLE"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_create_temp_index() -> Int {
586 |   unsafe_cast(get_constants().get("SQLITE_CREATE_TEMP_INDEX"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_create_temp_table() -> Int {
591 |   unsafe_cast(get_constants().get("SQLITE_CREATE_TEMP_TABLE"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_create_temp_trigger() -> Int {
596 |   unsafe_cast(get_constants().get("SQLITE_CREATE_TEMP_TRIGGER"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_create_temp_view() -> Int {
601 |   unsafe_cast(get_constants().get("SQLITE_CREATE_TEMP_VIEW"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_create_trigger() -> Int {
606 |   unsafe_cast(get_constants().get("SQLITE_CREATE_TRIGGER"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_create_view() -> Int {
611 |   unsafe_cast(get_constants().get("SQLITE_CREATE_VIEW"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_delete() -> Int {
616 |   unsafe_cast(get_constants().get("SQLITE_DELETE"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_drop_index() -> Int {
621 |   unsafe_cast(get_constants().get("SQLITE_DROP_INDEX"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_drop_table() -> Int {
626 |   unsafe_cast(get_constants().get("SQLITE_DROP_TABLE"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_drop_temp_index() -> Int {
631 |   unsafe_cast(get_constants().get("SQLITE_DROP_TEMP_INDEX"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_drop_temp_table() -> Int {
636 |   unsafe_cast(get_constants().get("SQLITE_DROP_TEMP_TABLE"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_drop_temp_trigger() -> Int {
641 |   unsafe_cast(get_constants().get("SQLITE_DROP_TEMP_TRIGGER"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_drop_temp_view() -> Int {
646 |   unsafe_cast(get_constants().get("SQLITE_DROP_TEMP_VIEW"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_drop_trigger() -> Int {
651 |   unsafe_cast(get_constants().get("SQLITE_DROP_TRIGGER"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_drop_view() -> Int {
656 |   unsafe_cast(get_constants().get("SQLITE_DROP_VIEW"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_insert() -> Int {
661 |   unsafe_cast(get_constants().get("SQLITE_INSERT"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_pragma() -> Int {
666 |   unsafe_cast(get_constants().get("SQLITE_PRAGMA"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_read() -> Int {
671 |   unsafe_cast(get_constants().get("SQLITE_READ"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_select() -> Int {
676 |   unsafe_cast(get_constants().get("SQLITE_SELECT"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_transaction() -> Int {
681 |   unsafe_cast(get_constants().get("SQLITE_TRANSACTION"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_update() -> Int {
686 |   unsafe_cast(get_constants().get("SQLITE_UPDATE"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_attach() -> Int {
691 |   unsafe_cast(get_constants().get("SQLITE_ATTACH"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_detach() -> Int {
696 |   unsafe_cast(get_constants().get("SQLITE_DETACH"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_alter_table() -> Int {
701 |   unsafe_cast(get_constants().get("SQLITE_ALTER_TABLE"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_reindex() -> Int {
706 |   unsafe_cast(get_constants().get("SQLITE_REINDEX"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_analyze() -> Int {
711 |   unsafe_cast(get_constants().get("SQLITE_ANALYZE"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_create_vtable() -> Int {
716 |   unsafe_cast(get_constants().get("SQLITE_CREATE_VTABLE"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_drop_vtable() -> Int {
721 |   unsafe_cast(get_constants().get("SQLITE_DROP_VTABLE"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_function() -> Int {
726 |   unsafe_cast(get_constants().get("SQLITE_FUNCTION"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_savepoint() -> Int {
731 |   unsafe_cast(get_constants().get("SQLITE_SAVEPOINT"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_copy() -> Int {
736 |   unsafe_cast(get_constants().get("SQLITE_COPY"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn sqlite_recursive() -> Int {
741 |   unsafe_cast(get_constants().get("SQLITE_RECURSIVE"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

2 uncovered line(s) in src/node/stream/promises/pipeline.mbt:

   | pub fn pipeline(streams : Array[Js]) -> @promise.Promise[Stream] {
23 |   ffi_stream_promises_pipeline(unsafe_cast(streams)) |> unsafe_cast
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn finished(stream : Js) -> @promise.Promise[Unit] {
28 |   ffi_stream_promises_finished(stream) |> unsafe_cast
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

52 uncovered line(s) in src/node/stream/stream.mbt:

    | fn stream_module() -> Js {
 10 |   @node.require("node:stream")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Readable::read(self : Readable, size? : Int) -> Js {
 48 |   self.call("read", [size])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Readable::pause(self : Readable) -> Readable {
 53 |   self.call("pause", []) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Readable::resume_(self : Readable) -> Readable {
 58 |   self.call("resume", []) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Readable::isPaused(self : Readable) -> Bool {
 63 |   self.call("isPaused", []) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Readable::pipe(self : Readable, destination : Writable) -> Writable {
 68 |   self.call("pipe", [destination]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Readable::unpipe(self : Readable, destination? : Writable) -> Readable {
 73 |   self.call("unpipe", [destination]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Readable::setEncoding(self : Readable, encoding : String) -> Readable {
 78 |   self.call("setEncoding", [encoding]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Readable::destroy(self : Readable, error? : Js) -> Readable {
 83 |   self.call("destroy", [error]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Readable::unshift(
    |   self : Readable,
    |   chunk : Js,
    |   encoding? : String,
    | ) -> Unit {
 92 |   ignore(self.call("unshift", [chunk, encoding]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Readable::readable(self : Readable) -> Bool {
 98 |   self.get("readable") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Readable::readableEncoding(self : Readable) -> Js {
103 |   self.get("readableEncoding")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Readable::readableEnded(self : Readable) -> Bool {
108 |   self.get("readableEnded") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Readable::readableFlowing(self : Readable) -> Js {
113 |   self.get("readableFlowing")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Readable::readableHighWaterMark(self : Readable) -> Int {
118 |   self.get("readableHighWaterMark") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Readable::readableLength(self : Readable) -> Int {
123 |   self.get("readableLength") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Readable::readableObjectMode(self : Readable) -> Bool {
128 |   self.get("readableObjectMode") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Readable::closed(self : Readable) -> Bool {
133 |   self.get("closed") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Readable::errored(self : Readable) -> Js {
138 |   self.get("errored")
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Readable::toWeb(self : Readable) -> @web.ReadableStream {
144 |   stream_module().get("Readable").call("toWeb", [self]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Readable::fromWeb(s : @web.ReadableStream) -> Readable {
149 |   stream_module().get("Readable").call("fromWeb", [s]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Readable::from(iterable : Js) -> Readable {
154 |   stream_module().get("Readable").call("from", [iterable]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Writable::write(
    |   self : Writable,
    |   chunk : Js,
    |   encoding? : String,
    |   callback? : Js,
    | ) -> Bool {
178 |   self.call("write", [chunk, encoding, callback]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Writable::end(
    |   self : Writable,
    |   chunk? : Js,
    |   encoding? : String,
    |   callback? : Js,
    | ) -> Writable {
188 |   self.call("end", [chunk, encoding, callback]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Writable::cork(self : Writable) -> Unit {
193 |   ignore(self.call("cork", []))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Writable::uncork(self : Writable) -> Unit {
198 |   ignore(self.call("uncork", []))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Writable::destroy(self : Writable, error? : Js) -> Writable {
203 |   self.call("destroy", [error]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Writable::setDefaultEncoding(
    |   self : Writable,
    |   encoding : String,
    | ) -> Writable {
211 |   self.call("setDefaultEncoding", [encoding]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Writable::writable(self : Writable) -> Bool {
217 |   self.get("writable") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Writable::writableEnded(self : Writable) -> Bool {
222 |   self.get("writableEnded") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Writable::writableFinished(self : Writable) -> Bool {
227 |   self.get("writableFinished") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Writable::writableHighWaterMark(self : Writable) -> Int {
232 |   self.get("writableHighWaterMark") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Writable::writableLength(self : Writable) -> Int {
237 |   self.get("writableLength") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Writable::writableObjectMode(self : Writable) -> Bool {
242 |   self.get("writableObjectMode") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Writable::writableCorked(self : Writable) -> Int {
247 |   self.get("writableCorked") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Writable::closed(self : Writable) -> Bool {
252 |   self.get("closed") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Writable::errored(self : Writable) -> Js {
257 |   self.get("errored")
    |   ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Writable::toWeb(self : Self) -> @web.WritableStream {
263 |   stream_module().get("Writable").call("toWeb", [self]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Writable::fromWeb(s : @web.WritableStream) -> Writable {
268 |   stream_module().get("Writable").call("fromWeb", [s]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Duplex::allowHalfOpen(self : Duplex) -> Bool {
287 |   self.get("allowHalfOpen") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Duplex::toWeb(self : Duplex) -> Js {
293 |   stream_module().get("Duplex").call("toWeb", [self])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Duplex::fromWeb(pair : Js) -> Duplex {
298 |   stream_module().get("Duplex").call("fromWeb", [pair]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Duplex::from(src : Js) -> Duplex {
303 |   stream_module().get("Duplex").call("from", [src]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn pipeline(streams : Array[Js], callback? : Js) -> Js {
347 |   ffi_pipeline(unsafe_cast(streams), callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn finished(stream : Js, callback? : Js) -> Js {
364 |   ffi_finished(stream, callback)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn compose(streams : Array[Js]) -> Js {
376 |   ffi_compose(unsafe_cast(streams))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn addAbortSignal(signal : Js, stream : Js) -> Js {
381 |   stream_module().call("addAbortSignal", [signal, stream])
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn isErrored(stream : Js) -> Bool {
386 |   stream_module().call("isErrored", [stream]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn isReadable(stream : Js) -> Bool {
391 |   stream_module().call("isReadable", [stream]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn isWritable(stream : Js) -> Bool {
396 |   stream_module().call("isWritable", [stream]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn getDefaultHighWaterMark(objectMode : Bool) -> Int {
401 |   stream_module().call("getDefaultHighWaterMark", [objectMode]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn setDefaultHighWaterMark(objectMode : Bool, value : Int) -> Unit {
406 |   ignore(stream_module().call("setDefaultHighWaterMark", [objectMode, value]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

11 uncovered line(s) in src/node/test/mock.mbt:

    | pub fn MockTracker::fn_(
    |   self : MockTracker,
    |   original? : Js,
    |   implementation? : Js,
    | ) -> Js {
    |   match (original, implementation) {
 36 |     (Some(orig), Some(imp)) => self.call("fn", [orig, imp])
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(orig), None) => self.call("fn", [orig])
    |     (None, Some(imp)) => self.call("fn", [imp])
    |     (None, None) => self.call("fn", [])
    |   }
    | }
    …

    | pub fn MockTracker::method_(
    |   self : MockTracker,
    |   object : Js,
    |   methodName : String,
    |   implementation? : Js,
    | ) -> Js {
    |   match implementation {
    |     Some(imp) => self.call("method", [object, methodName, imp])
 54 |     None => self.call("method", [object, methodName])
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub fn MockTracker::getter_(
    |   self : MockTracker,
    |   object : Js,
    |   methodName : String,
    |   implementation? : Js,
    | ) -> Js {
 67 |   match implementation {
    |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(imp) => self.call("getter", [object, methodName, imp])
    |     None => self.call("getter", [object, methodName])
    |   }
    | }
    …

    | pub fn MockTracker::setter_(
    |   self : MockTracker,
    |   object : Js,
    |   methodName : String,
    |   implementation? : Js,
    | ) -> Js {
 82 |   match implementation {
    |   ^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(imp) => self.call("setter", [object, methodName, imp])
    |     None => self.call("setter", [object, methodName])
    |   }
    | }
    …

    | pub fn MockTracker::reset(self : MockTracker) -> Unit {
 91 |   self.call("reset", []) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MockFunctionContext::calls(self : MockFunctionContext) -> Array[Js] {
106 |   self.get("calls") |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MockFunctionContext::mockImplementation(
    |   self : MockFunctionContext,
    |   implementation : Js,
    | ) -> Unit {
121 |   self.call("mockImplementation", [implementation]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MockFunctionContext::mockImplementationOnce(
    |   self : MockFunctionContext,
    |   implementation : Js,
    |   onCall? : Int,
    | ) -> Unit {
131 |   match onCall {
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(call) =>
133 |       self.call("mockImplementationOnce", [implementation, call]) |> ignore
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => self.call("mockImplementationOnce", [implementation]) |> ignore
    |   }
    | }
    …

    | pub fn MockFunctionContext::resetCalls(self : MockFunctionContext) -> Unit {
141 |   self.call("resetCalls", []) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MockFunctionContext::restore(self : MockFunctionContext) -> Unit {
147 |   self.call("restore", []) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

6 uncovered line(s) in src/node/test/nodetest.mbt:

   | pub fn TestContext::todo(self : Self, description : String) -> Unit {
15 |   self.call("todo", [@js.js(description)]) |> ignore
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn it(
   |   name : String,
   |   skip? : String,
   |   f : async (TestContext) -> Unit,
   | ) -> Unit {
   |   let args : Array[&JsImpl] = if skip is Some(skip) {
25 |     let arg : Json = { "skip": skip }
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     [name, arg, promisify1(f) |> @js.from_fn1]
   |   } else {
   |     [name, promisify1(f) |> @js.from_fn1]
   |   }
   |   nodetest().call("it", args) |> ignore
   | }
   …

   | #alias(before_all)
   | pub fn beforeAll(f : async () -> Unit) -> Unit {
36 |   nodetest().call("beforeEach", [f |> promisify0 |> @js.from_fn0]) |> ignore
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | #alias(after_all)
   | pub fn afterAll(f : async () -> Unit) -> Unit {
42 |   nodetest().call("beforeEach", [f |> promisify0 |> @js.from_fn0]) |> ignore
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | #alias(before_each)
   | pub fn beforeEach(f : async () -> Unit) -> Unit {
48 |   nodetest().call("beforeEach", [f |> promisify0 |> @js.from_fn0]) |> ignore
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | #alias(after_each)
   | pub fn afterEach(f : async () -> Unit) -> Unit {
54 |   nodetest().call("afterEach", [f |> promisify0 |> @js.from_fn0]) |> ignore
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

20 uncovered line(s) in src/node/test/run.mbt:

   | pub fn run(
   |   files? : Array[String],
   |   cwd? : String,
   |   forceExit? : Bool,
   |   inspectPort? : Int,
   |   only? : Bool,
   |   concurrency? : Int,
   |   globPatterns? : Array[String],
   |   isolation? : Bool,
   |   execArgv? : Array[String],
   |   argv? : Array[String],
   |   watch? : Bool,
   |   shard? : TestShard,
   |   signal? : @js.AbortSignal,
   |   testNamePatterns? : Array[String],
   |   testSkipPatterns? : Array[String],
   |   timeout? : Int,
   |   rerunFailuresFilePath? : String,
   |   setup? : () -> Unit,
   | 
   |   // coverage
   |   coverage? : Bool,
   |   lineCoverage? : Bool,
   |   functionCoverage? : Bool,
   |   branchCoverage? : Bool,
   |   coverageIncludeGlobs? : Array[String],
   |   coverageExcludeGlobs? : Array[String],
   | ) -> @stream.Stream {
41 |   let obj = @js.Object::new()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   if files is Some(files) {
43 |     obj.set("files", @js.from_array(files))
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
   |   if cwd is Some(cwd) {
46 |     obj.set("cwd", @js.js(cwd))
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
   |   if forceExit is Some(forceExit) {
49 |     obj.set("forceExit", @js.js(forceExit))
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
   |   if only is Some(only) {
52 |     obj.set("only", @js.js(only))
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
   |   if inspectPort is Some(inspectPort) {
55 |     obj.set("inspectPort", @js.js(inspectPort))
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
   |   if concurrency is Some(concurrency) {
58 |     obj.set("concurrency", @js.js(concurrency))
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
   |   if globPatterns is Some(globPatterns) {
61 |     obj.set("globPatterns", @js.from_array(globPatterns))
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
   |   if isolation is Some(isolation) {
64 |     obj.set("isolation", @js.js(isolation))
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
   |   if execArgv is Some(execArgv) {
67 |     obj.set("execArgv", @js.from_array(execArgv))
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
   |   if coverage is Some(coverage) {
70 |     obj.set("coverage", @js.js(coverage))
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
   |   if watch is Some(watch) {
73 |     obj.set("watch", @js.js(watch))
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
   |   if signal is Some(signal) {
76 |     obj.set("signal", @js.js(signal))
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
   |   if testNamePatterns is Some(testNamePatterns) {
79 |     obj.set("testNamePatterns", @js.from_array(testNamePatterns))
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
   |   if testSkipPatterns is Some(testSkipPatterns) {
82 |     obj.set("testSkipPatterns", @js.from_array(testSkipPatterns))
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
   |   if timeout is Some(timeout) {
85 |     obj.set("timeout", @js.js(timeout))
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
   |   if shard is Some(shard) {
88 |     obj.set("shard", @js.js(shard))
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
   |   if rerunFailuresFilePath is Some(rerunFailuresFilePath) {
91 |     obj.set("rerunFailuresFilePath", @js.js(rerunFailuresFilePath))
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
   |   if setup is Some(setup) {
94 |     obj.set("setup", @js.from_fn0(setup))
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
96 |   nodetest().call("run", [obj]) |> unsafe_cast
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

4 uncovered line(s) in src/node/url/url.mbt:

   | #alias(file_url_to_path)
   | pub fn fileURLToPath(url : String, windows? : Bool) -> String {
   |   let url_module = @node.require("node:url")
   |   match windows {
 7 |     Some(w) => {
   |     ^^^^^^^^^^^^ 	<-- UNCOVERED
   |       let options = @js.Object::new()
   |       options.set("windows", w)
   |       unsafe_cast(url_module.call("fileURLToPath", [url, options]))
   |     }
   |     None => unsafe_cast(url_module.call("fileURLToPath", [url]))
   |   }
   | }
   …

   | #alias(file_url_to_path_from_url)
   | pub fn fileURLToPathFromURL(url : URL, windows? : Bool) -> String {
   |   let url_module = @node.require("node:url")
   |   match windows {
22 |     Some(w) => {
   |     ^^^^^^^^^^^^ 	<-- UNCOVERED
   |       let options = @js.Object::new()
   |       options.set("windows", w)
   |       unsafe_cast(url_module.call("fileURLToPath", [url, options]))
   |     }
   |     None => unsafe_cast(url_module.call("fileURLToPath", [url]))
   |   }
   | }
   …

   | #alias(path_to_file_url)
   | pub fn pathToFileURL(path : String, windows? : Bool) -> URL {
   |   let url_module = @node.require("node:url")
   |   match windows {
37 |     Some(w) => {
   |     ^^^^^^^^^^^^ 	<-- UNCOVERED
   |       let options = @js.Object::new()
   |       options.set("windows", w)
   |       unsafe_cast(url_module.call("pathToFileURL", [path, options]))
   |     }
   |     None => unsafe_cast(url_module.call("pathToFileURL", [path]))
   |   }
   | }
   …

   | pub fn format(url : URL) -> String {
57 |   let url_module = @node.require("node:url")
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   unsafe_cast(url_module.call("format", [url]))
   | }
   …

1 uncovered line(s) in src/node/wasi/wasi.mbt:

    | pub fn WASI::initialize(self : WASI, instance : WebAssemblyInstance) -> Unit {
136 |   self.call("initialize", [instance.to_js()]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

8 uncovered line(s) in src/npm/ai/ai.mbt:

   | pub impl JsImpl for MessageContent with to_js(self) {
13 |   match self {
   |   ^^^^^^^^^^^^ 	<-- UNCOVERED
   |     Message(m) => m |> js
   |   }
   | }
   …

   | pub impl JsImpl for ModelMessage with to_js(self) {
27 |   match self {
   |   ^^^^^^^^^^^^ 	<-- UNCOVERED
   |     AssitantMessage(content~) =>
29 |       @js.from_map({
   |       ^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |         "type": "assitant" |> js,
   |         "content": JsImpl::to_js(content),
   |       })
   |     UserMessage(content~) =>
34 |       @js.from_map({ "role": "user" |> js, "content": JsImpl::to_js(content) })
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     SystemMessage(content~) =>
36 |       @js.from_map({ "role": "system" |> js, "content": JsImpl::to_js(content) })
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
   | }
   …

   | pub fn Ai::require() -> Self {
54 |   @node.require("ai") |> unsafe_cast
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Ai::generate_text(
   |   self : Self,
   |   model~ : Model,
   |   messages~ : Array[ModelMessage],
   |   // prompt?: String
   | ) -> @promise.Promise[Js] {
64 |   unsafe_cast(
   |   ^^^^^^^^^^^^ 	<-- UNCOVERED
   |     self
66 |     .to_js()
   |     ^^^^^^^^ 	<-- UNCOVERED
   |     .get("generateText")
   |     .call_self([
   |       @js.from_map({
   |         "model": model |> unsafe_cast,
   |         "messages": messages.map(_.to_js()) |> @js.from_array,
   |       }),
   |     ]),
   |   )
   | }
   …

1 uncovered line(s) in src/npm/react/component.mbt:

   | pub fn strict_mode(children : Array[&JsImpl]) -> Element {
33 |   let tag = unsafe_cast(get_strict_mode())
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   let children = @js.from_array(children)
   |   ffi_create_element(tag, @js.undefined(), children) |> unsafe_cast
   | }
   …

21 uncovered line(s) in src/npm/react/element/element_bench.mbt:

    | fn init_minimal_react_api() -> Unit {
 18 |   @react.init_react_api(ffi_create_minimal_react_api())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | fn create_complex_component() -> @react.Element {
 24 |   div(id="app", [
    |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     // Header section
 26 |     header([
    |     ^^^^^^^^ 	<-- UNCOVERED
    |       nav([
    |         ul([
    |           li([a(href="/", ["Home"])]),
    |           li([a(href="/about", ["About"])]),
    |           li([a(href="/products", ["Products"])]),
    |           li([a(href="/contact", ["Contact"])]),
    |         ]),
    |       ]),
 35 |       h1(["Welcome to Our Store"]),
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     ]),
    |     // Main content section
 38 |     main_([
    |     ^^^^^^^ 	<-- UNCOVERED
    |       article([
    |         h2(["Featured Products"]),
    |         div(class="product-grid", [
    |           // Product cards
 43 |           div(class="product-card", [
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             img(src="/product1.jpg", alt="Product 1", []),
    |             h3(["Product 1"]),
    |             p(["Description of product 1 with some details."]),
    |             button(type_="button", ["Add to Cart"]),
    |           ]),
 49 |           div(class="product-card", [
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             img(src="/product2.jpg", alt="Product 2", []),
    |             h3(["Product 2"]),
    |             p(["Description of product 2 with some details."]),
    |             button(type_="button", ["Add to Cart"]),
    |           ]),
 55 |           div(class="product-card", [
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |             img(src="/product3.jpg", alt="Product 3", []),
    |             h3(["Product 3"]),
    |             p(["Description of product 3 with some details."]),
    |             button(type_="button", ["Add to Cart"]),
    |           ]),
    |         ]),
    |       ]),
 63 |       aside([
    |       ^^^^^^^ 	<-- UNCOVERED
    |         h3(["Categories"]),
    |         ul([
    |           li([a(href="/category/electronics", ["Electronics"])]),
    |           li([a(href="/category/clothing", ["Clothing"])]),
    |           li([a(href="/category/books", ["Books"])]),
    |           li([a(href="/category/home", ["Home & Garden"])]),
    |         ]),
    |       ]),
    |     ]),
    |     // Footer section
 74 |     footer([
    |     ^^^^^^^^ 	<-- UNCOVERED
    |       div([
    |         section([h4(["About Us"]), p(["We are a leading online retailer."])]),
    |         section([
    |           h4(["Contact"]),
    |           p(["Email: info@example.com"]),
    |           p(["Phone: 123-456-7890"]),
    |         ]),
 82 |         section([
    |         ^^^^^^^^^ 	<-- UNCOVERED
    |           h4(["Follow Us"]),
    |           ul([
    |             li([a(href="https://facebook.com", ["Facebook"])]),
    |             li([a(href="https://twitter.com", ["Twitter"])]),
    |             li([a(href="https://instagram.com", ["Instagram"])]),
    |           ]),
    |         ]),
    |       ]),
    |     ]),
    |   ])
    | }
    …

    | fn create_form_component() -> @react.Element {
105 |   form([
    |   ^^^^^^ 	<-- UNCOVERED
    |     div([
    |       label(["First Name:"], "firstName"),
    |       input(
    |         type_="text",
    |         id="firstName",
    |         name="firstName",
    |         placeholder="Enter first name",
    |       ),
    |     ]),
115 |     div([
    |     ^^^^^ 	<-- UNCOVERED
    |       label(["Last Name:"], "lastName"),
    |       input(
    |         type_="text",
    |         id="lastName",
    |         name="lastName",
    |         placeholder="Enter last name",
    |       ),
    |     ]),
124 |     div([
    |     ^^^^^ 	<-- UNCOVERED
    |       label(["Email:"], "email"),
    |       input(type_="email", id="email", name="email", placeholder="Enter email"),
    |     ]),
128 |     div([
    |     ^^^^^ 	<-- UNCOVERED
    |       label(["Message:"], "message"),
    |       textarea(id="message", placeholder="Enter your message", []),
    |     ]),
132 |     div([
    |     ^^^^^ 	<-- UNCOVERED
    |       label(["Country:"], "country"),
    |       select(id="country", name="country", [
    |         option(value="us", ["USA"]),
    |         option(value="ca", ["Canada"]),
    |         option(value="uk", ["UK"]),
    |         option(value="jp", ["Japan"]),
    |       ]),
    |     ]),
141 |     button(type_="submit", ["Submit"]),
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   ])
    | }
    …

    | fn create_svg_chart() -> @react.Element {
158 |   svg(width=400, height=300, [
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     // Background
160 |     rect(x=0, y=0, width=400, height=300, fill="white", stroke="black"),
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     // Data bars
162 |     rect(x=50, y=250, width=40, height=50, fill="blue"),
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     rect(x=100, y=200, width=40, height=100, fill="blue"),
    |     rect(x=150, y=150, width=40, height=150, fill="blue"),
    |     rect(x=200, y=180, width=40, height=120, fill="blue"),
    |     rect(x=250, y=220, width=40, height=80, fill="blue"),
    |     // Labels
168 |     text(x=200, y=30, ["Chart Title"]),
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     text(x=70, y=280, ["2020"]),
    |     text(x=120, y=280, ["2021"]),
    |     text(x=170, y=280, ["2022"]),
    |     text(x=220, y=280, ["2023"]),
    |     text(x=270, y=280, ["2024"]),
    |   ])
    | }
    …

61 uncovered line(s) in src/npm/react/element/html.mbt:

     | fn[T] common_node(
     |   tag_name : String,
     |   props : @js.Object,
     |   children~ : Array[&ReactNode],
     |   id~ : String?,
     |   class~ : String?,
     |   style~ : Map[String, String]?,
     |   tab_index~ : Int?,
     |   ref_~ : ReactRef[T]?,
     |   key~ : String?,
     |   on_click~ : MouseEventHandler[T]?,
     |   on_change~ : ChangeEventHandler[T]?,
     |   on_keydown~ : KeyboardEventHandler[T]?,
     |   on_keyup~ : KeyboardEventHandler[T]?,
     |   on_focus~ : FocusEventHandler[T]?,
     |   on_blur~ : FocusEventHandler[T]?,
     |   on_drag~ : DragEventHandler[T]?,
     |   on_dragstart~ : DragEventHandler[T]?,
     |   on_dragend~ : DragEventHandler[T]?,
     |   on_dragleave~ : DragEventHandler[T]?,
     |   on_dragenter~ : DragEventHandler[T]?,
     |   on_dragover~ : DragEventHandler[T]?,
     |   on_drop~ : DragEventHandler[T]?,
     | ) -> @react.Element {
     |   if id is Some(id) {
     |     props.set("id", id)
     |   }
     |   if class is Some(class) {
     |     props.set("className", class)
     |   }
     |   if tab_index is Some(tab_index) {
     |     props.set("tabIndex", tab_index)
     |   }
     |   if style is Some(style) {
     |     let style_obj = @js.Object::new()
     |     for k, v in style {
     |       style_obj.set(k, v)
     |     }
     |     props.set("style", style_obj.to_js())
     |   }
     |   if ref_ is Some(ref_) {
     |     props.set("ref", ref_ |> js)
     |   }
     |   if key is Some(key) {
     |     props.set("key", key)
     |   }
     |   if on_click is Some(f) {
     |     props.set("onClick", f |> @js.from_fn1)
     |   }
     |   if on_change is Some(f) {
     |     props.set("onChange", f |> @js.from_fn1)
     |   }
     |   if on_keydown is Some(f) {
     |     props.set("onKeyDown", f |> @js.from_fn1)
     |   }
     |   if on_keyup is Some(f) {
     |     props.set("onKeyUp", f |> @js.from_fn1)
     |   }
     |   if on_focus is Some(f) {
  61 |     props.set("onFocus", f |> @js.from_fn1)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if on_blur is Some(f) {
  64 |     props.set("onBlur", f |> @js.from_fn1)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   // Optimize: avoid array allocation, handle drag handlers directly
     |   if on_drag is Some(f) {
     |     props.set("onDrag", f |> @js.from_fn1)
     |   }
     |   if on_dragstart is Some(f) {
     |     props.set("onDragStart", f |> @js.from_fn1)
     |   }
     |   if on_dragend is Some(f) {
     |     props.set("onDragEnd", f |> @js.from_fn1)
     |   }
     |   if on_dragleave is Some(f) {
  77 |     props.set("onDragLeave", f |> @js.from_fn1)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if on_dragenter is Some(f) {
  80 |     props.set("onDragEnter", f |> @js.from_fn1)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if on_dragover is Some(f) {
  83 |     props.set("onDragOver", f |> @js.from_fn1)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if on_drop is Some(f) {
     |     props.set("onDrop", f |> @js.from_fn1)
     |   }
     |   let children_js = children.map(_.to_react_node()) |> @js.from_array
     |   @react.createElementDirect(tag_name, props.to_js(), children_js)
     | }
     …

     | pub fn pre(
     |   // common props
     |   children : Array[&ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     |   // react
     |   ref_? : ReactRef[@dom.Element],
     |   key? : String,
     |   // event handlers
     |   on_click? : MouseEventHandler[@dom.Element],
     |   on_change? : ChangeEventHandler[@dom.Element],
     |   on_keydown? : KeyboardEventHandler[@dom.Element],
     |   on_keyup? : KeyboardEventHandler[@dom.Element],
     |   on_focus? : FocusEventHandler[@dom.Element],
     |   on_blur? : FocusEventHandler[@dom.Element],
     |   on_drag? : DragEventHandler[@dom.Element],
     |   on_dragstart? : DragEventHandler[@dom.Element],
     |   on_dragend? : DragEventHandler[@dom.Element],
     |   on_dragleave? : DragEventHandler[@dom.Element],
     |   on_dragenter? : DragEventHandler[@dom.Element],
     |   on_dragover? : DragEventHandler[@dom.Element],
     |   on_drop? : DragEventHandler[@dom.Element],
     | ) -> @react.Element {
     |   common_node(
     |     "pre",
     |     match props {
 180 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     tab_index~,
     |     class~,
     |     style~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn blockquote(
     |   // common props
     |   children : Array[&ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     |   // react
     |   ref_? : ReactRef[@dom.Element],
     |   key? : String,
     |   // event handlers
     |   on_click? : MouseEventHandler[@dom.Element],
     |   on_change? : ChangeEventHandler[@dom.Element],
     |   on_keydown? : KeyboardEventHandler[@dom.Element],
     |   on_keyup? : KeyboardEventHandler[@dom.Element],
     |   on_focus? : FocusEventHandler[@dom.Element],
     |   on_blur? : FocusEventHandler[@dom.Element],
     |   on_drag? : DragEventHandler[@dom.Element],
     |   on_dragstart? : DragEventHandler[@dom.Element],
     |   on_dragend? : DragEventHandler[@dom.Element],
     |   on_dragleave? : DragEventHandler[@dom.Element],
     |   on_dragenter? : DragEventHandler[@dom.Element],
     |   on_dragover? : DragEventHandler[@dom.Element],
     |   on_drop? : DragEventHandler[@dom.Element],
     | ) -> @react.Element {
     |   common_node(
     |     "blockquote",
     |     match props {
 237 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn span(
     |   children : Array[&ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     |   // react
     |   ref_? : ReactRef[HTMLSpanElement],
     |   key? : String,
     |   // event handlers
     |   on_click? : MouseEventHandler[HTMLSpanElement],
     |   on_change? : ChangeEventHandler[HTMLSpanElement],
     |   on_keydown? : KeyboardEventHandler[HTMLSpanElement],
     |   on_keyup? : KeyboardEventHandler[HTMLSpanElement],
     |   on_focus? : FocusEventHandler[HTMLSpanElement],
     |   on_blur? : FocusEventHandler[HTMLSpanElement],
     |   on_drag? : DragEventHandler[HTMLSpanElement],
     |   on_dragstart? : DragEventHandler[HTMLSpanElement],
     |   on_dragend? : DragEventHandler[HTMLSpanElement],
     |   on_dragleave? : DragEventHandler[HTMLSpanElement],
     |   on_dragenter? : DragEventHandler[HTMLSpanElement],
     |   on_dragover? : DragEventHandler[HTMLSpanElement],
     |   on_drop? : DragEventHandler[HTMLSpanElement],
     | ) -> @react.Element {
     |   common_node(
     |     "span",
     |     match props {
 293 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     ref_~,
     |     tab_index~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn nav(
     |   children : Array[&ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     |   // react
     |   ref_? : ReactRef[@dom.Element],
     |   key? : String,
     |   // event handlers
     |   on_click? : MouseEventHandler[@dom.Element],
     |   on_change? : ChangeEventHandler[@dom.Element],
     |   on_keydown? : KeyboardEventHandler[@dom.Element],
     |   on_keyup? : KeyboardEventHandler[@dom.Element],
     |   on_focus? : FocusEventHandler[@dom.Element],
     |   on_blur? : FocusEventHandler[@dom.Element],
     |   on_drag? : DragEventHandler[@dom.Element],
     |   on_dragstart? : DragEventHandler[@dom.Element],
     |   on_dragend? : DragEventHandler[@dom.Element],
     |   on_dragleave? : DragEventHandler[@dom.Element],
     |   on_dragenter? : DragEventHandler[@dom.Element],
     |   on_dragover? : DragEventHandler[@dom.Element],
     |   on_drop? : DragEventHandler[@dom.Element],
     | ) -> @react.Element {
     |   common_node(
     |     "nav",
     |     match props {
 349 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     ref_~,
     |     tab_index~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn textarea(
     |   children : Array[&ReactNode],
     |   rows? : Int,
     |   columns? : Int,
     |   spellcheck? : Bool,
     |   value? : String,
     |   default_value? : String,
     |   placeholder? : String,
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     |   // react
     |   ref_? : ReactRef[HTMLTextAreaElement],
     |   key? : String,
     |   // event handlers
     |   on_click? : MouseEventHandler[HTMLTextAreaElement],
     |   on_change? : ChangeEventHandler[HTMLTextAreaElement],
     |   on_keydown? : KeyboardEventHandler[HTMLTextAreaElement],
     |   on_keyup? : KeyboardEventHandler[HTMLTextAreaElement],
     |   on_focus? : FocusEventHandler[HTMLTextAreaElement],
     |   on_blur? : FocusEventHandler[HTMLTextAreaElement],
     |   on_drag? : DragEventHandler[HTMLTextAreaElement],
     |   on_dragstart? : DragEventHandler[HTMLTextAreaElement],
     |   on_dragend? : DragEventHandler[HTMLTextAreaElement],
     |   on_dragleave? : DragEventHandler[HTMLTextAreaElement],
     |   on_dragenter? : DragEventHandler[HTMLTextAreaElement],
     |   on_dragover? : DragEventHandler[HTMLTextAreaElement],
     |   on_drop? : DragEventHandler[HTMLTextAreaElement],
     | ) -> @react.Element {
     |   let custom_props : @js.Object = match props {
     |     Some(p) => @js.Object::assign(@js.Object::new(), p) |> unsafe_cast
     |     None => @js.Object::new()
     |   }
     |   if rows is Some(r) {
     |     custom_props.set("rows", r)
     |   }
     |   if columns is Some(c) {
     |     custom_props.set("cols", c)
     |   }
     |   if spellcheck is Some(s) {
     |     custom_props.set("spellCheck", s)
     |   }
     |   if value is Some(v) {
 478 |     custom_props.set("value", v)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if default_value is Some(dv) {
     |     custom_props.set("defaultValue", dv)
     |   }
     |   if placeholder is Some(ph) {
     |     custom_props.set("placeholder", ph)
     |   }
     |   common_node(
     |     "textarea",
     |     custom_props,
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn input(
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   name? : String,
     |   type_? : String,
     |   value? : String,
     |   default_value? : String,
     |   placeholder? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     |   // react
     |   ref_? : ReactRef[HTMLInputElement],
     |   key? : String,
     |   // event handlers
     |   on_click? : MouseEventHandler[HTMLInputElement],
     |   on_change? : ChangeEventHandler[HTMLInputElement],
     |   on_keydown? : KeyboardEventHandler[HTMLInputElement],
     |   on_keyup? : KeyboardEventHandler[HTMLInputElement],
     |   on_focus? : FocusEventHandler[HTMLInputElement],
     |   on_blur? : FocusEventHandler[HTMLInputElement],
     |   on_drag? : DragEventHandler[HTMLInputElement],
     |   on_dragstart? : DragEventHandler[HTMLInputElement],
     |   on_dragend? : DragEventHandler[HTMLInputElement],
     |   on_dragleave? : DragEventHandler[HTMLInputElement],
     |   on_dragenter? : DragEventHandler[HTMLInputElement],
     |   on_dragover? : DragEventHandler[HTMLInputElement],
     |   on_drop? : DragEventHandler[HTMLInputElement],
     | ) -> @react.Element {
     |   let custom_props : @js.Object = match props {
     |     Some(p) => @js.Object::assign(@js.Object::new(), p) |> unsafe_cast
     |     None => @js.Object::new()
     |   }
     |   if name is Some(n) {
     |     custom_props.set("name", n)
     |   }
     |   if value is Some(v) {
 551 |     custom_props.set("value", v)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if default_value is Some(dv) {
     |     custom_props.set("defaultValue", dv)
     |   }
     |   if type_ is Some(t) {
     |     custom_props.set("type", t)
     |   }
     |   if placeholder is Some(ph) {
     |     custom_props.set("placeholder", ph)
     |   }
     |   common_node(
     |     "input",
     |     custom_props,
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children=[],
     |   )
     | }
     …

     | pub fn main_(
     |   children : Array[&ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     |   // react
     |   ref_? : ReactRef[@dom.Element],
     |   key? : String,
     |   // event handlers
     |   on_click? : MouseEventHandler[@dom.Element],
     |   on_change? : ChangeEventHandler[@dom.Element],
     |   on_keydown? : KeyboardEventHandler[@dom.Element],
     |   on_keyup? : KeyboardEventHandler[@dom.Element],
     |   on_focus? : FocusEventHandler[@dom.Element],
     |   on_blur? : FocusEventHandler[@dom.Element],
     |   on_drag? : DragEventHandler[@dom.Element],
     |   on_dragstart? : DragEventHandler[@dom.Element],
     |   on_dragend? : DragEventHandler[@dom.Element],
     |   on_dragleave? : DragEventHandler[@dom.Element],
     |   on_dragenter? : DragEventHandler[@dom.Element],
     |   on_dragover? : DragEventHandler[@dom.Element],
     |   on_drop? : DragEventHandler[@dom.Element],
     | ) -> @react.Element {
     |   common_node(
     |     "main",
     |     match props {
 618 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn header(
     |   children : Array[&ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : ReactRef[@dom.Element],
     |   key? : String,
     |   // event handlers
     |   on_click? : MouseEventHandler[@dom.Element],
     |   on_change? : ChangeEventHandler[@dom.Element],
     |   on_keydown? : KeyboardEventHandler[@dom.Element],
     |   on_keyup? : KeyboardEventHandler[@dom.Element],
     |   on_focus? : FocusEventHandler[@dom.Element],
     |   on_blur? : FocusEventHandler[@dom.Element],
     |   on_drag? : DragEventHandler[@dom.Element],
     |   on_dragstart? : DragEventHandler[@dom.Element],
     |   on_dragend? : DragEventHandler[@dom.Element],
     |   on_dragleave? : DragEventHandler[@dom.Element],
     |   on_dragenter? : DragEventHandler[@dom.Element],
     |   on_dragover? : DragEventHandler[@dom.Element],
     |   on_drop? : DragEventHandler[@dom.Element],
     | ) -> @react.Element {
     |   common_node(
     |     "header",
     |     match props {
 675 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn footer(
     |   children : Array[&ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : ReactRef[@dom.Element],
     |   key? : String,
     |   // event handlers
     |   on_click? : MouseEventHandler[@dom.Element],
     |   on_change? : ChangeEventHandler[@dom.Element],
     |   on_keydown? : KeyboardEventHandler[@dom.Element],
     |   on_keyup? : KeyboardEventHandler[@dom.Element],
     |   on_focus? : FocusEventHandler[@dom.Element],
     |   on_blur? : FocusEventHandler[@dom.Element],
     |   on_drag? : DragEventHandler[@dom.Element],
     |   on_dragstart? : DragEventHandler[@dom.Element],
     |   on_dragend? : DragEventHandler[@dom.Element],
     |   on_dragleave? : DragEventHandler[@dom.Element],
     |   on_dragenter? : DragEventHandler[@dom.Element],
     |   on_dragover? : DragEventHandler[@dom.Element],
     |   on_drop? : DragEventHandler[@dom.Element],
     | ) -> @react.Element {
     |   common_node(
     |     "footer",
     |     match props {
 732 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn ol(
     |   children : Array[&ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : ReactRef[HTMLOListElement],
     |   key? : String,
     |   // event handlers
     |   on_click? : MouseEventHandler[HTMLOListElement],
     |   on_change? : ChangeEventHandler[HTMLOListElement],
     |   on_keydown? : KeyboardEventHandler[HTMLOListElement],
     |   on_keyup? : KeyboardEventHandler[HTMLOListElement],
     |   on_focus? : FocusEventHandler[HTMLOListElement],
     |   on_blur? : FocusEventHandler[HTMLOListElement],
     |   on_drag? : DragEventHandler[HTMLOListElement],
     |   on_dragstart? : DragEventHandler[HTMLOListElement],
     |   on_dragend? : DragEventHandler[HTMLOListElement],
     |   on_dragleave? : DragEventHandler[HTMLOListElement],
     |   on_dragenter? : DragEventHandler[HTMLOListElement],
     |   on_dragover? : DragEventHandler[HTMLOListElement],
     |   on_drop? : DragEventHandler[HTMLOListElement],
     | ) -> @react.Element {
     |   common_node(
     |     "ol",
     |     match props {
 846 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn article(
     |   children : Array[&ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     |   // react
     |   ref_? : ReactRef[@dom.Element],
     |   key? : String,
     |   // event handlers
     |   on_click? : MouseEventHandler[@dom.Element],
     |   on_change? : ChangeEventHandler[@dom.Element],
     |   on_keydown? : KeyboardEventHandler[@dom.Element],
     |   on_keyup? : KeyboardEventHandler[@dom.Element],
     |   on_focus? : FocusEventHandler[@dom.Element],
     |   on_blur? : FocusEventHandler[@dom.Element],
     |   on_drag? : DragEventHandler[@dom.Element],
     |   on_dragstart? : DragEventHandler[@dom.Element],
     |   on_dragend? : DragEventHandler[@dom.Element],
     |   on_dragleave? : DragEventHandler[@dom.Element],
     |   on_dragenter? : DragEventHandler[@dom.Element],
     |   on_dragover? : DragEventHandler[@dom.Element],
     |   on_drop? : DragEventHandler[@dom.Element],
     | ) -> @react.Element {
     |   common_node(
     |     "article",
     |     match props {
 902 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn aside(
     |   children : Array[&ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     |   // react
     |   ref_? : ReactRef[@dom.Element],
     |   key? : String,
     |   // event handlers
     |   on_click? : MouseEventHandler[@dom.Element],
     |   on_change? : ChangeEventHandler[@dom.Element],
     |   on_keydown? : KeyboardEventHandler[@dom.Element],
     |   on_keyup? : KeyboardEventHandler[@dom.Element],
     |   on_focus? : FocusEventHandler[@dom.Element],
     |   on_blur? : FocusEventHandler[@dom.Element],
     |   on_drag? : DragEventHandler[@dom.Element],
     |   on_dragstart? : DragEventHandler[@dom.Element],
     |   on_dragend? : DragEventHandler[@dom.Element],
     |   on_dragleave? : DragEventHandler[@dom.Element],
     |   on_dragenter? : DragEventHandler[@dom.Element],
     |   on_dragover? : DragEventHandler[@dom.Element],
     |   on_drop? : DragEventHandler[@dom.Element],
     | ) -> @react.Element {
     |   common_node(
     |     "aside",
     |     match props {
 958 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn section(
     |   children : Array[&ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     |   // react
     |   ref_? : ReactRef[@dom.Element],
     |   key? : String,
     |   // event handlers
     |   on_click? : MouseEventHandler[@dom.Element],
     |   on_change? : ChangeEventHandler[@dom.Element],
     |   on_keydown? : KeyboardEventHandler[@dom.Element],
     |   on_keyup? : KeyboardEventHandler[@dom.Element],
     |   on_focus? : FocusEventHandler[@dom.Element],
     |   on_blur? : FocusEventHandler[@dom.Element],
     |   on_drag? : DragEventHandler[@dom.Element],
     |   on_dragstart? : DragEventHandler[@dom.Element],
     |   on_dragend? : DragEventHandler[@dom.Element],
     |   on_dragleave? : DragEventHandler[@dom.Element],
     |   on_dragenter? : DragEventHandler[@dom.Element],
     |   on_dragover? : DragEventHandler[@dom.Element],
     |   on_drop? : DragEventHandler[@dom.Element],
     | ) -> @react.Element {
     |   common_node(
     |     "section",
     |     match props {
1014 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn form(
     |   children : Array[&ReactNode],
     | 
     |   // xxx
     |   method_? : String,
     |   disabled? : Bool,
     |   name? : String,
     |   enc_type? : String,
     |   action? : (FormData) -> Unit,
     |   on_submit? : (@dom.FormEvent) -> Unit,
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : ReactRef[HTMLFormElement],
     |   key? : String,
     |   // event handlers
     |   on_click? : MouseEventHandler[HTMLFormElement],
     |   on_change? : ChangeEventHandler[HTMLFormElement],
     |   on_keydown? : KeyboardEventHandler[HTMLFormElement],
     |   on_keyup? : KeyboardEventHandler[HTMLFormElement],
     |   on_focus? : FocusEventHandler[HTMLFormElement],
     |   on_blur? : FocusEventHandler[HTMLFormElement],
     |   on_drag? : DragEventHandler[HTMLFormElement],
     |   on_dragstart? : DragEventHandler[HTMLFormElement],
     |   on_dragend? : DragEventHandler[HTMLFormElement],
     |   on_dragleave? : DragEventHandler[HTMLFormElement],
     |   on_dragenter? : DragEventHandler[HTMLFormElement],
     |   on_dragover? : DragEventHandler[HTMLFormElement],
     |   on_drop? : DragEventHandler[HTMLFormElement],
     | ) -> @react.Element {
     |   let custom_props : @js.Object = match props {
1085 |     Some(p) => @js.Object::assign(@js.Object::new(), p) |> unsafe_cast
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => @js.Object::new()
     |   }
     |   if disabled is Some(d) {
1089 |     custom_props.set("disabled", d)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if name is Some(n) {
1092 |     custom_props.set("name", n)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if method_ is Some(m) {
     |     custom_props.set("method", m)
     |   }
     |   if on_submit is Some(f) {
1098 |     let fn_value : Js = f |> @js.from_fn1
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     custom_props.set("onSubmit", fn_value)
     |   }
     |   if action is Some(f) {
1102 |     let fn_value : Js = f |> @js.from_fn1
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     custom_props.set("action", fn_value)
     |   }
     |   if enc_type is Some(e) {
1106 |     custom_props.set("encType", e)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   common_node(
     |     "form",
     |     custom_props,
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn select(
     |   children : Array[&ReactNode],
     |   // xxx
     |   multiple? : Bool,
     |   disabled? : Bool,
     |   name? : String,
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     |   // react
     |   ref_? : ReactRef[HTMLSelectElement],
     |   key? : String,
     |   // event handlers
     |   on_click? : MouseEventHandler[HTMLSelectElement],
     |   on_change? : ChangeEventHandler[HTMLSelectElement],
     |   on_keydown? : KeyboardEventHandler[HTMLSelectElement],
     |   on_keyup? : KeyboardEventHandler[HTMLSelectElement],
     |   on_focus? : FocusEventHandler[HTMLSelectElement],
     |   on_blur? : FocusEventHandler[HTMLSelectElement],
     |   on_drag? : DragEventHandler[HTMLSelectElement],
     |   on_dragstart? : DragEventHandler[HTMLSelectElement],
     |   on_dragend? : DragEventHandler[HTMLSelectElement],
     |   on_dragleave? : DragEventHandler[HTMLSelectElement],
     |   on_dragenter? : DragEventHandler[HTMLSelectElement],
     |   on_dragover? : DragEventHandler[HTMLSelectElement],
     |   on_drop? : DragEventHandler[HTMLSelectElement],
     | ) -> @react.Element {
     |   let custom_props : @js.Object = match props {
1166 |     Some(p) => @js.Object::assign(@js.Object::new(), p) |> unsafe_cast
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => @js.Object::new()
     |   }
     |   if multiple is Some(m) {
1170 |     custom_props.set("multiple", m)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if disabled is Some(d) {
1173 |     custom_props.set("disabled", d)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if name is Some(n) {
1176 |     custom_props.set("name", n)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   common_node(
     |     "select",
     |     custom_props,
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn option(
     |   children : Array[&ReactNode],
     |   value~ : String,
     |   selected? : Bool,
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : ReactRef[HTMLOptionElement],
     |   key? : String,
     |   // event handlers
     |   on_click? : MouseEventHandler[HTMLOptionElement],
     |   on_change? : ChangeEventHandler[HTMLOptionElement],
     |   on_keydown? : KeyboardEventHandler[HTMLOptionElement],
     |   on_keyup? : KeyboardEventHandler[HTMLOptionElement],
     |   on_focus? : FocusEventHandler[HTMLOptionElement],
     |   on_blur? : FocusEventHandler[HTMLOptionElement],
     |   on_drag? : DragEventHandler[HTMLOptionElement],
     |   on_dragstart? : DragEventHandler[HTMLOptionElement],
     |   on_dragend? : DragEventHandler[HTMLOptionElement],
     |   on_dragleave? : DragEventHandler[HTMLOptionElement],
     |   on_dragenter? : DragEventHandler[HTMLOptionElement],
     |   on_dragover? : DragEventHandler[HTMLOptionElement],
     |   on_drop? : DragEventHandler[HTMLOptionElement],
     | ) -> @react.Element {
     |   let custom_props : @js.Object = match props {
1235 |     Some(p) => @js.Object::assign(@js.Object::new(), p) |> unsafe_cast
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => @js.Object::new()
     |   }
     |   custom_props.set("value", value)
     |   if selected is Some(s) {
1240 |     custom_props.set("selected", s)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   common_node(
     |     "option",
     |     custom_props,
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn label(
     |   children : Array[&ReactNode],
     |   htmlFor : String,
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : ReactRef[HTMLLabelElement],
     |   key? : String,
     |   // event handlers
     |   on_click? : MouseEventHandler[HTMLLabelElement],
     |   on_change? : ChangeEventHandler[HTMLLabelElement],
     |   on_keydown? : KeyboardEventHandler[HTMLLabelElement],
     |   on_keyup? : KeyboardEventHandler[HTMLLabelElement],
     |   on_focus? : FocusEventHandler[HTMLLabelElement],
     |   on_blur? : FocusEventHandler[HTMLLabelElement],
     |   on_drag? : DragEventHandler[HTMLLabelElement],
     |   on_dragstart? : DragEventHandler[HTMLLabelElement],
     |   on_dragend? : DragEventHandler[HTMLLabelElement],
     |   on_dragleave? : DragEventHandler[HTMLLabelElement],
     |   on_dragenter? : DragEventHandler[HTMLLabelElement],
     |   on_dragover? : DragEventHandler[HTMLLabelElement],
     |   on_drop? : DragEventHandler[HTMLLabelElement],
     | ) -> @react.Element {
     |   let custom_props : @js.Object = match props {
1298 |     Some(p) => @js.Object::assign(@js.Object::new(), p) |> unsafe_cast
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => @js.Object::new()
     |   }
     |   custom_props.set("htmlFor", htmlFor)
     |   common_node(
     |     "label",
     |     custom_props,
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn li(
     |   children : Array[&ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : ReactRef[HTMLLIElement],
     |   key? : String,
     |   // event handlers
     |   on_click? : MouseEventHandler[HTMLLIElement],
     |   on_change? : ChangeEventHandler[HTMLLIElement],
     |   on_keydown? : KeyboardEventHandler[HTMLLIElement],
     |   on_keyup? : KeyboardEventHandler[HTMLLIElement],
     |   on_focus? : FocusEventHandler[HTMLLIElement],
     |   on_blur? : FocusEventHandler[HTMLLIElement],
     |   on_drag? : DragEventHandler[HTMLLIElement],
     |   on_dragstart? : DragEventHandler[HTMLLIElement],
     |   on_dragend? : DragEventHandler[HTMLLIElement],
     |   on_dragleave? : DragEventHandler[HTMLLIElement],
     |   on_dragenter? : DragEventHandler[HTMLLIElement],
     |   on_dragover? : DragEventHandler[HTMLLIElement],
     |   on_drop? : DragEventHandler[HTMLLIElement],
     | ) -> @react.Element {
     |   common_node(
     |     "li",
     |     match props {
1359 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn code(
     |   children : Array[&ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : ReactRef[@dom.Element],
     |   key? : String,
     |   // event handlers
     |   on_click? : MouseEventHandler[@dom.Element],
     |   on_change? : ChangeEventHandler[@dom.Element],
     |   on_keydown? : KeyboardEventHandler[@dom.Element],
     |   on_keyup? : KeyboardEventHandler[@dom.Element],
     |   on_focus? : FocusEventHandler[@dom.Element],
     |   on_blur? : FocusEventHandler[@dom.Element],
     |   on_drag? : DragEventHandler[@dom.Element],
     |   on_dragstart? : DragEventHandler[@dom.Element],
     |   on_dragend? : DragEventHandler[@dom.Element],
     |   on_dragleave? : DragEventHandler[@dom.Element],
     |   on_dragenter? : DragEventHandler[@dom.Element],
     |   on_dragover? : DragEventHandler[@dom.Element],
     |   on_drop? : DragEventHandler[@dom.Element],
     | ) -> @react.Element {
     |   common_node(
     |     "code",
     |     match props {
1416 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn details(
     |   children : Array[&ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : ReactRef[@dom.Element],
     |   key? : String,
     |   // event handlers
     |   on_click? : MouseEventHandler[@dom.Element],
     |   on_change? : ChangeEventHandler[@dom.Element],
     |   on_keydown? : KeyboardEventHandler[@dom.Element],
     |   on_keyup? : KeyboardEventHandler[@dom.Element],
     |   on_focus? : FocusEventHandler[@dom.Element],
     |   on_blur? : FocusEventHandler[@dom.Element],
     |   on_drag? : DragEventHandler[@dom.Element],
     |   on_dragstart? : DragEventHandler[@dom.Element],
     |   on_dragend? : DragEventHandler[@dom.Element],
     |   on_dragleave? : DragEventHandler[@dom.Element],
     |   on_dragenter? : DragEventHandler[@dom.Element],
     |   on_dragover? : DragEventHandler[@dom.Element],
     |   on_drop? : DragEventHandler[@dom.Element],
     | ) -> @react.Element {
     |   common_node(
     |     "details",
     |     match props {
1473 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn summary(
     |   children : Array[&ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : ReactRef[@dom.Element],
     |   key? : String,
     |   // event handlers
     |   on_click? : MouseEventHandler[@dom.Element],
     |   on_change? : ChangeEventHandler[@dom.Element],
     |   on_keydown? : KeyboardEventHandler[@dom.Element],
     |   on_keyup? : KeyboardEventHandler[@dom.Element],
     |   on_focus? : FocusEventHandler[@dom.Element],
     |   on_blur? : FocusEventHandler[@dom.Element],
     |   on_drag? : DragEventHandler[@dom.Element],
     |   on_dragstart? : DragEventHandler[@dom.Element],
     |   on_dragend? : DragEventHandler[@dom.Element],
     |   on_dragleave? : DragEventHandler[@dom.Element],
     |   on_dragenter? : DragEventHandler[@dom.Element],
     |   on_dragover? : DragEventHandler[@dom.Element],
     |   on_drop? : DragEventHandler[@dom.Element],
     | ) -> @react.Element {
     |   common_node(
     |     "summary",
     |     match props {
1530 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn a(
     |   children : Array[&ReactNode],
     | 
     |   // a specific
     |   href~ : String,
     |   download? : String,
     |   target? : String,
     | 
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : ReactRef[HTMLAnchorElement],
     |   key? : String,
     |   // event handlers
     |   on_click? : MouseEventHandler[HTMLAnchorElement],
     |   on_change? : ChangeEventHandler[HTMLAnchorElement],
     |   on_keydown? : KeyboardEventHandler[HTMLAnchorElement],
     |   on_keyup? : KeyboardEventHandler[HTMLAnchorElement],
     |   on_focus? : FocusEventHandler[HTMLAnchorElement],
     |   on_blur? : FocusEventHandler[HTMLAnchorElement],
     |   on_drag? : DragEventHandler[HTMLAnchorElement],
     |   on_dragstart? : DragEventHandler[HTMLAnchorElement],
     |   on_dragend? : DragEventHandler[HTMLAnchorElement],
     |   on_dragleave? : DragEventHandler[HTMLAnchorElement],
     |   on_dragenter? : DragEventHandler[HTMLAnchorElement],
     |   on_dragover? : DragEventHandler[HTMLAnchorElement],
     |   on_drop? : DragEventHandler[HTMLAnchorElement],
     | ) -> @react.Element {
     |   let custom_props : @js.Object = match props {
1591 |     Some(p) => @js.Object::assign(@js.Object::new(), p) |> unsafe_cast
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => @js.Object::new()
     |   }
     |   custom_props.set("href", href)
     |   if download is Some(d) {
1596 |     custom_props.set("download", d)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if target is Some(t) {
     |     custom_props.set("target", t)
     |   }
     |   common_node(
     |     "a",
     |     custom_props,
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn iframe(
     |   children : Array[&ReactNode],
     | 
     |   // a specific
     |   src~ : String,
     |   width? : Int,
     |   height? : Int,
     |   frameborder? : String,
     |   sandbox? : String,
     |   tab_index? : Int,
     |   allowfullscreen? : Bool,
     |   loading? : String,
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   // react
     |   ref_? : ReactRef[@dom.Element],
     |   key? : String,
     |   // event handlers
     |   on_click? : MouseEventHandler[@dom.Element],
     |   on_change? : ChangeEventHandler[@dom.Element],
     |   on_keydown? : KeyboardEventHandler[@dom.Element],
     |   on_keyup? : KeyboardEventHandler[@dom.Element],
     |   on_focus? : FocusEventHandler[@dom.Element],
     |   on_blur? : FocusEventHandler[@dom.Element],
     |   on_drag? : DragEventHandler[@dom.Element],
     |   on_dragstart? : DragEventHandler[@dom.Element],
     |   on_dragend? : DragEventHandler[@dom.Element],
     |   on_dragleave? : DragEventHandler[@dom.Element],
     |   on_dragenter? : DragEventHandler[@dom.Element],
     |   on_dragover? : DragEventHandler[@dom.Element],
     |   on_drop? : DragEventHandler[@dom.Element],
     | ) -> @react.Element {
     |   let custom_props : @js.Object = match props {
1664 |     Some(p) => @js.Object::assign(@js.Object::new(), p) |> unsafe_cast
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => @js.Object::new()
     |   }
     |   custom_props.set("src", src)
     |   if width is Some(d) {
     |     custom_props.set("width", d)
     |   }
     |   if height is Some(d) {
     |     custom_props.set("height", d)
     |   }
     |   if frameborder is Some(d) {
1675 |     custom_props.set("frameborder", d)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if sandbox is Some(d) {
1678 |     custom_props.set("sandbox", d)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if allowfullscreen is Some(d) {
1681 |     custom_props.set("allowfullscreen", d)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if loading is Some(d) {
1684 |     custom_props.set("loading", d)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   common_node(
     |     "iframe",
     |     custom_props,
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn img(
     |   children : Array[&ReactNode],
     | 
     |   // a specific
     |   src~ : String,
     |   srcset? : String,
     |   alt? : String,
     |   crossorigin? : String,
     |   decoding? : String,
     |   width? : Int,
     |   height? : Int,
     |   fetchpriority? : String,
     |   loading? : String,
     |   sizes? : String,
     | 
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : ReactRef[HTMLImageElement],
     |   key? : String,
     |   // event handlers
     |   on_click? : MouseEventHandler[HTMLImageElement],
     |   on_change? : ChangeEventHandler[HTMLImageElement],
     |   on_keydown? : KeyboardEventHandler[HTMLImageElement],
     |   on_keyup? : KeyboardEventHandler[HTMLImageElement],
     |   on_focus? : FocusEventHandler[HTMLImageElement],
     |   on_blur? : FocusEventHandler[HTMLImageElement],
     |   on_drag? : DragEventHandler[HTMLImageElement],
     |   on_dragstart? : DragEventHandler[HTMLImageElement],
     |   on_dragend? : DragEventHandler[HTMLImageElement],
     |   on_dragleave? : DragEventHandler[HTMLImageElement],
     |   on_dragenter? : DragEventHandler[HTMLImageElement],
     |   on_dragover? : DragEventHandler[HTMLImageElement],
     |   on_drop? : DragEventHandler[HTMLImageElement],
     | ) -> @react.Element {
     |   let custom_props : @js.Object = match props {
1754 |     Some(p) => @js.Object::assign(@js.Object::new(), p) |> unsafe_cast
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => @js.Object::new()
     |   }
     |   custom_props.set("src", src)
     |   if alt is Some(d) {
     |     custom_props.set("alt", d)
     |   }
     |   if crossorigin is Some(d) {
1762 |     custom_props.set("crossorigin", d)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if decoding is Some(d) {
1765 |     custom_props.set("decoding", d)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if width is Some(d) {
     |     custom_props.set("width", d)
     |   }
     |   if height is Some(d) {
     |     custom_props.set("height", d)
     |   }
     |   if fetchpriority is Some(d) {
1774 |     custom_props.set("fetchpriority", d)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if loading is Some(d) {
1777 |     custom_props.set("loading", d)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if sizes is Some(d) {
1780 |     custom_props.set("sizes", d)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   if srcset is Some(d) {
1783 |     custom_props.set("srcset", d)
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |   }
     |   common_node(
     |     "img",
     |     custom_props,
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn video(
     |   children : Array[&ReactNode],
     | 
     |   // a specific
     |   controls? : Bool,
     | 
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : ReactRef[@dom.Element],
     |   key? : String,
     |   // event handlers
     |   on_click? : MouseEventHandler[@dom.Element],
     |   on_change? : ChangeEventHandler[@dom.Element],
     |   on_keydown? : KeyboardEventHandler[@dom.Element],
     |   on_keyup? : KeyboardEventHandler[@dom.Element],
     |   on_focus? : FocusEventHandler[@dom.Element],
     |   on_blur? : FocusEventHandler[@dom.Element],
     |   on_drag? : DragEventHandler[@dom.Element],
     |   on_dragstart? : DragEventHandler[@dom.Element],
     |   on_dragend? : DragEventHandler[@dom.Element],
     |   on_dragleave? : DragEventHandler[@dom.Element],
     |   on_dragenter? : DragEventHandler[@dom.Element],
     |   on_dragover? : DragEventHandler[@dom.Element],
     |   on_drop? : DragEventHandler[@dom.Element],
     | ) -> @react.Element {
     |   let custom_props : @js.Object = match props {
1844 |     Some(p) => @js.Object::assign(@js.Object::new(), p) |> unsafe_cast
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => @js.Object::new()
     |   }
     |   if controls is Some(c) {
     |     custom_props.set("controls", c |> @js.unsafe_js)
     |   }
     |   common_node(
     |     "video",
     |     custom_props,
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn source(
     |   // a specific
     |   src~ : String,
     |   type_? : String,
     | 
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : ReactRef[@dom.Element],
     |   key? : String,
     |   // event handlers
     |   on_click? : MouseEventHandler[@dom.Element],
     |   on_change? : ChangeEventHandler[@dom.Element],
     |   on_keydown? : KeyboardEventHandler[@dom.Element],
     |   on_keyup? : KeyboardEventHandler[@dom.Element],
     |   on_focus? : FocusEventHandler[@dom.Element],
     |   on_blur? : FocusEventHandler[@dom.Element],
     |   on_drag? : DragEventHandler[@dom.Element],
     |   on_dragstart? : DragEventHandler[@dom.Element],
     |   on_dragend? : DragEventHandler[@dom.Element],
     |   on_dragleave? : DragEventHandler[@dom.Element],
     |   on_dragenter? : DragEventHandler[@dom.Element],
     |   on_dragover? : DragEventHandler[@dom.Element],
     |   on_drop? : DragEventHandler[@dom.Element],
     | ) -> @react.Element {
     |   let custom_props : @js.Object = match props {
1908 |     Some(p) => @js.Object::assign(@js.Object::new(), p) |> unsafe_cast
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => @js.Object::new()
     |   }
     |   custom_props.set("src", src |> @js.unsafe_js)
     |   if type_ is Some(t) {
     |     custom_props.set("type", t |> @js.unsafe_js)
     |   }
     |   common_node(
     |     "video",
     |     custom_props,
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children=[],
     |   )
     | }
     …

     | pub fn hr(
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : ReactRef[@dom.Element],
     |   key? : String,
     |   // event handlers
     |   on_click? : MouseEventHandler[@dom.Element],
     |   on_change? : ChangeEventHandler[@dom.Element],
     |   on_keydown? : KeyboardEventHandler[@dom.Element],
     |   on_keyup? : KeyboardEventHandler[@dom.Element],
     |   on_focus? : FocusEventHandler[@dom.Element],
     |   on_blur? : FocusEventHandler[@dom.Element],
     |   on_drag? : DragEventHandler[@dom.Element],
     |   on_dragstart? : DragEventHandler[@dom.Element],
     |   on_dragend? : DragEventHandler[@dom.Element],
     |   on_dragleave? : DragEventHandler[@dom.Element],
     |   on_dragenter? : DragEventHandler[@dom.Element],
     |   on_dragover? : DragEventHandler[@dom.Element],
     |   on_drop? : DragEventHandler[@dom.Element],
     | ) -> @react.Element {
1968 |   common_node(
     |   ^^^^^^^^^^^^ 	<-- UNCOVERED
     |     "hr",
1970 |     match props {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Some(p) => p
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children=[],
     |   )
     | }
     …

     | pub fn h1(
     |   children : Array[&ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : ReactRef[HTMLHeadingElement],
     |   key? : String,
     |   // event handlers
     |   on_click? : MouseEventHandler[HTMLHeadingElement],
     |   on_change? : ChangeEventHandler[HTMLHeadingElement],
     |   on_keydown? : KeyboardEventHandler[HTMLHeadingElement],
     |   on_keyup? : KeyboardEventHandler[HTMLHeadingElement],
     |   on_focus? : FocusEventHandler[HTMLHeadingElement],
     |   on_blur? : FocusEventHandler[HTMLHeadingElement],
     |   on_drag? : DragEventHandler[HTMLHeadingElement],
     |   on_dragstart? : DragEventHandler[HTMLHeadingElement],
     |   on_dragend? : DragEventHandler[HTMLHeadingElement],
     |   on_dragleave? : DragEventHandler[HTMLHeadingElement],
     |   on_dragenter? : DragEventHandler[HTMLHeadingElement],
     |   on_dragover? : DragEventHandler[HTMLHeadingElement],
     |   on_drop? : DragEventHandler[HTMLHeadingElement],
     | ) -> @react.Element {
     |   common_node(
     |     "h1",
     |     match props {
2028 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn h2(
     |   children : Array[&ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : ReactRef[HTMLHeadingElement],
     |   key? : String,
     |   // event handlers
     |   on_click? : MouseEventHandler[HTMLHeadingElement],
     |   on_change? : ChangeEventHandler[HTMLHeadingElement],
     |   on_keydown? : KeyboardEventHandler[HTMLHeadingElement],
     |   on_keyup? : KeyboardEventHandler[HTMLHeadingElement],
     |   on_focus? : FocusEventHandler[HTMLHeadingElement],
     |   on_blur? : FocusEventHandler[HTMLHeadingElement],
     |   on_drag? : DragEventHandler[HTMLHeadingElement],
     |   on_dragstart? : DragEventHandler[HTMLHeadingElement],
     |   on_dragend? : DragEventHandler[HTMLHeadingElement],
     |   on_dragleave? : DragEventHandler[HTMLHeadingElement],
     |   on_dragenter? : DragEventHandler[HTMLHeadingElement],
     |   on_dragover? : DragEventHandler[HTMLHeadingElement],
     |   on_drop? : DragEventHandler[HTMLHeadingElement],
     | ) -> @react.Element {
2082 |   common_node(
     |   ^^^^^^^^^^^^ 	<-- UNCOVERED
     |     "h2",
2084 |     match props {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Some(p) => p
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn h3(
     |   children : Array[&ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : ReactRef[HTMLHeadingElement],
     |   key? : String,
     |   // event handlers
     |   on_click? : MouseEventHandler[HTMLHeadingElement],
     |   on_change? : ChangeEventHandler[HTMLHeadingElement],
     |   on_keydown? : KeyboardEventHandler[HTMLHeadingElement],
     |   on_keyup? : KeyboardEventHandler[HTMLHeadingElement],
     |   on_focus? : FocusEventHandler[HTMLHeadingElement],
     |   on_blur? : FocusEventHandler[HTMLHeadingElement],
     |   on_drag? : DragEventHandler[HTMLHeadingElement],
     |   on_dragstart? : DragEventHandler[HTMLHeadingElement],
     |   on_dragend? : DragEventHandler[HTMLHeadingElement],
     |   on_dragleave? : DragEventHandler[HTMLHeadingElement],
     |   on_dragenter? : DragEventHandler[HTMLHeadingElement],
     |   on_dragover? : DragEventHandler[HTMLHeadingElement],
     |   on_drop? : DragEventHandler[HTMLHeadingElement],
     | ) -> @react.Element {
2139 |   common_node(
     |   ^^^^^^^^^^^^ 	<-- UNCOVERED
     |     "h3",
2141 |     match props {
     |     ^^^^^^^^^^^^^ 	<-- UNCOVERED
     |       Some(p) => p
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn h4(
     |   children : Array[&ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : ReactRef[HTMLHeadingElement],
     |   key? : String,
     |   // event handlers
     |   on_click? : MouseEventHandler[HTMLHeadingElement],
     |   on_change? : ChangeEventHandler[HTMLHeadingElement],
     |   on_keydown? : KeyboardEventHandler[HTMLHeadingElement],
     |   on_keyup? : KeyboardEventHandler[HTMLHeadingElement],
     |   on_focus? : FocusEventHandler[HTMLHeadingElement],
     |   on_blur? : FocusEventHandler[HTMLHeadingElement],
     |   on_drag? : DragEventHandler[HTMLHeadingElement],
     |   on_dragstart? : DragEventHandler[HTMLHeadingElement],
     |   on_dragend? : DragEventHandler[HTMLHeadingElement],
     |   on_dragleave? : DragEventHandler[HTMLHeadingElement],
     |   on_dragenter? : DragEventHandler[HTMLHeadingElement],
     |   on_dragover? : DragEventHandler[HTMLHeadingElement],
     |   on_drop? : DragEventHandler[HTMLHeadingElement],
     | ) -> @react.Element {
     |   common_node(
     |     "h4",
     |     match props {
2199 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn h5(
     |   children : Array[&ReactNode],
     |   // shared
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     | 
     |   // react
     |   ref_? : ReactRef[HTMLHeadingElement],
     |   key? : String,
     |   // event handlers
     |   on_click? : MouseEventHandler[HTMLHeadingElement],
     |   on_change? : ChangeEventHandler[HTMLHeadingElement],
     |   on_keydown? : KeyboardEventHandler[HTMLHeadingElement],
     |   on_keyup? : KeyboardEventHandler[HTMLHeadingElement],
     |   on_focus? : FocusEventHandler[HTMLHeadingElement],
     |   on_blur? : FocusEventHandler[HTMLHeadingElement],
     |   on_drag? : DragEventHandler[HTMLHeadingElement],
     |   on_dragstart? : DragEventHandler[HTMLHeadingElement],
     |   on_dragend? : DragEventHandler[HTMLHeadingElement],
     |   on_dragleave? : DragEventHandler[HTMLHeadingElement],
     |   on_dragenter? : DragEventHandler[HTMLHeadingElement],
     |   on_dragover? : DragEventHandler[HTMLHeadingElement],
     |   on_drop? : DragEventHandler[HTMLHeadingElement],
     | ) -> @react.Element {
     |   common_node(
     |     "h5",
     |     match props {
2256 |       Some(p) => p
     |       ^^^^^^^^^^^^ 	<-- UNCOVERED
     |       None => @js.Object::new()
     |     },
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

     | pub fn button(
     |   children : Array[&ReactNode],
     |   type_? : String,
     |   disabled? : Bool,
     |   props? : @js.Object,
     |   id? : String,
     |   class? : String,
     |   style? : Map[String, String],
     |   tab_index? : Int,
     |   ref_? : ReactRef[HTMLButtonElement],
     |   key? : String,
     |   on_click? : MouseEventHandler[HTMLButtonElement],
     |   on_change? : ChangeEventHandler[HTMLButtonElement],
     |   on_keydown? : KeyboardEventHandler[HTMLButtonElement],
     |   on_keyup? : KeyboardEventHandler[HTMLButtonElement],
     |   on_focus? : FocusEventHandler[HTMLButtonElement],
     |   on_blur? : FocusEventHandler[HTMLButtonElement],
     |   on_drag? : DragEventHandler[HTMLButtonElement],
     |   on_dragstart? : DragEventHandler[HTMLButtonElement],
     |   on_dragend? : DragEventHandler[HTMLButtonElement],
     |   on_dragleave? : DragEventHandler[HTMLButtonElement],
     |   on_dragenter? : DragEventHandler[HTMLButtonElement],
     |   on_dragover? : DragEventHandler[HTMLButtonElement],
     |   on_drop? : DragEventHandler[HTMLButtonElement],
     | ) -> @react.Element {
     |   let custom_props : @js.Object = match props {
2309 |     Some(p) => @js.Object::assign(@js.Object::new(), p) |> unsafe_cast
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
     |     None => @js.Object::new()
     |   }
     |   if type_ is Some(t) {
     |     custom_props.set("type", t)
     |   }
     |   if disabled is Some(d) {
     |     custom_props.set("disabled", d)
     |   }
     |   common_node(
     |     "button",
     |     custom_props,
     |     id~,
     |     class~,
     |     style~,
     |     tab_index~,
     |     ref_~,
     |     key~,
     |     on_click~,
     |     on_change~,
     |     on_keydown~,
     |     on_keyup~,
     |     on_focus~,
     |     on_blur~,
     |     on_drag~,
     |     on_dragend~,
     |     on_dragenter~,
     |     on_dragleave~,
     |     on_dragover~,
     |     on_dragstart~,
     |     on_drop~,
     |     children~,
     |   )
     | }
     …

61 uncovered line(s) in src/npm/react/element/svg.mbt:

    | pub fn svg(
    |   // common props
    |   children : Array[&ReactNode],
    |   width~ : Int,
    |   height~ : Int,
    |   view_box? : String,
    |   // shared
    |   props? : @js.Object,
    |   id? : String,
    |   class? : String,
    |   style? : Map[String, String],
    |   tab_index? : Int,
    |   // react
    |   ref_? : ReactRef[@dom.Element],
    |   key? : String,
    |   // event handlers
    |   on_click? : MouseEventHandler[@dom.Element],
    |   on_change? : ChangeEventHandler[@dom.Element],
    |   on_keydown? : KeyboardEventHandler[@dom.Element],
    |   on_keyup? : KeyboardEventHandler[@dom.Element],
    |   on_focus? : FocusEventHandler[@dom.Element],
    |   on_blur? : FocusEventHandler[@dom.Element],
    |   on_drag? : DragEventHandler[@dom.Element],
    |   on_dragstart? : DragEventHandler[@dom.Element],
    |   on_dragend? : DragEventHandler[@dom.Element],
    |   on_dragleave? : DragEventHandler[@dom.Element],
    |   on_dragenter? : DragEventHandler[@dom.Element],
    |   on_dragover? : DragEventHandler[@dom.Element],
    |   on_drop? : DragEventHandler[@dom.Element],
    | ) -> @react.Element {
    |   // Optimize: avoid Object.assign when props is provided but reuse if empty
    |   let attrs : @js.Object = match props {
    |     Some(p) =>
 35 |       if @js.Object::keys(p).length() > 0 {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         @js.Object::assign(@js.Object::new(), p) |> unsafe_cast
    |       } else {
 38 |         p
    |         ^ 	<-- UNCOVERED
    |       }
    |     None => @js.Object::new()
    |   }
    |   attrs.set("width", width)
    |   attrs.set("height", height)
    |   if view_box is Some(view_box) {
 45 |     attrs.set("viewBox", view_box)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   common_node(
    |     "svg",
    |     attrs,
    |     id~,
    |     class~,
    |     style~,
    |     tab_index~,
    |     ref_~,
    |     key~,
    |     on_click~,
    |     on_change~,
    |     on_keydown~,
    |     on_keyup~,
    |     on_focus~,
    |     on_blur~,
    |     on_drag~,
    |     on_dragend~,
    |     on_dragenter~,
    |     on_dragleave~,
    |     on_dragover~,
    |     on_dragstart~,
    |     on_drop~,
    |     children~,
    |   )
    | }
    …

    | pub fn circle(
    |   // common props
    |   cx~ : Int,
    |   cy~ : Int,
    |   r~ : Int,
    |   stroke? : String,
    |   stroke_width? : Int,
    |   fill? : String,
    | 
    |   // shared
    |   props? : @js.Object,
    |   id? : String,
    |   class? : String,
    |   style? : Map[String, String],
    |   tab_index? : Int,
    |   // react
    |   ref_? : ReactRef[@dom.Element],
    |   key? : String,
    |   // event handlers
    |   on_click? : MouseEventHandler[@dom.Element],
    |   on_drag? : DragEventHandler[@dom.Element],
    |   on_dragstart? : DragEventHandler[@dom.Element],
    |   on_dragend? : DragEventHandler[@dom.Element],
    |   on_dragleave? : DragEventHandler[@dom.Element],
    |   on_dragenter? : DragEventHandler[@dom.Element],
    |   on_dragover? : DragEventHandler[@dom.Element],
    |   on_drop? : DragEventHandler[@dom.Element],
    | ) -> @react.Element {
    |   let attrs : @js.Object = match props {
    |     Some(p) =>
104 |       if @js.Object::keys(p).length() > 0 {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         @js.Object::assign(@js.Object::new(), p) |> unsafe_cast
    |       } else {
107 |         p
    |         ^ 	<-- UNCOVERED
    |       }
    |     None => @js.Object::new()
    |   }
    |   attrs.set("cx", cx)
    |   attrs.set("cy", cy)
    |   attrs.set("r", r)
    |   if stroke is Some(stroke) {
115 |     attrs.set("stroke", stroke)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if stroke_width is Some(stroke_width) {
118 |     attrs.set("strokeWidth", stroke_width)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if fill is Some(fill) {
    |     attrs.set("fill", fill)
    |   }
    |   common_node(
    |     "circle",
    |     attrs,
    |     id~,
    |     class~,
    |     style~,
    |     tab_index~,
    |     ref_~,
    |     key~,
    |     on_click~,
    |     on_change=None,
    |     on_keydown=None,
    |     on_keyup=None,
    |     on_focus=None,
    |     on_blur=None,
    |     on_drag~,
    |     on_dragend~,
    |     on_dragenter~,
    |     on_dragleave~,
    |     on_dragover~,
    |     on_dragstart~,
    |     on_drop~,
    |     children=[],
    |   )
    | }
    …

    | pub fn ellipse(
    |   // common props
    |   cx~ : Int,
    |   cy~ : Int,
    |   rx~ : Int,
    |   ry~ : Int,
    |   stroke? : String,
    |   stroke_width? : Int,
    |   fill? : String,
    | 
    |   // shared
    |   props? : @js.Object,
    |   id? : String,
    |   class? : String,
    |   style? : Map[String, String],
    |   tab_index? : Int,
    |   // react
    |   ref_? : ReactRef[@dom.Element],
    |   key? : String,
    |   // event handlers
    |   on_click? : MouseEventHandler[@dom.Element],
    |   on_change? : ChangeEventHandler[@dom.Element],
    |   on_keydown? : KeyboardEventHandler[@dom.Element],
    |   on_keyup? : KeyboardEventHandler[@dom.Element],
    |   on_focus? : FocusEventHandler[@dom.Element],
    |   on_blur? : FocusEventHandler[@dom.Element],
    |   on_drag? : DragEventHandler[@dom.Element],
    |   on_dragstart? : DragEventHandler[@dom.Element],
    |   on_dragend? : DragEventHandler[@dom.Element],
    |   on_dragleave? : DragEventHandler[@dom.Element],
    |   on_dragenter? : DragEventHandler[@dom.Element],
    |   on_dragover? : DragEventHandler[@dom.Element],
    |   on_drop? : DragEventHandler[@dom.Element],
    | ) -> @react.Element {
    |   let attrs : @js.Object = match props {
    |     Some(p) =>
186 |       if @js.Object::keys(p).length() > 0 {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         @js.Object::assign(@js.Object::new(), p) |> unsafe_cast
    |       } else {
189 |         p
    |         ^ 	<-- UNCOVERED
    |       }
    |     None => @js.Object::new()
    |   }
    |   attrs.set("cx", cx)
    |   attrs.set("cy", cy)
    |   attrs.set("rx", rx)
    |   attrs.set("ry", ry)
    |   if stroke is Some(stroke) {
198 |     attrs.set("stroke", stroke)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if stroke_width is Some(stroke_width) {
201 |     attrs.set("strokeWidth", stroke_width)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if fill is Some(fill) {
    |     attrs.set("fill", fill)
    |   }
    |   common_node(
    |     "circle",
    |     attrs,
    |     id~,
    |     class~,
    |     style~,
    |     tab_index~,
    |     ref_~,
    |     key~,
    |     on_click~,
    |     on_change~,
    |     on_keydown~,
    |     on_keyup~,
    |     on_focus~,
    |     on_blur~,
    |     on_drag~,
    |     on_dragend~,
    |     on_dragenter~,
    |     on_dragleave~,
    |     on_dragover~,
    |     on_dragstart~,
    |     on_drop~,
    |     children=[],
    |   )
    | }
    …

    | pub fn rect(
    |   // common props
    |   x~ : Int,
    |   y~ : Int,
    |   width~ : Int,
    |   height~ : Int,
    |   stroke? : String,
    |   stroke_width? : Int,
    |   fill? : String,
    | 
    |   // shared
    |   props? : @js.Object,
    |   id? : String,
    |   class? : String,
    |   style? : Map[String, String],
    |   tab_index? : Int,
    |   // react
    |   ref_? : ReactRef[@dom.Element],
    |   key? : String,
    |   // event handlers
    |   on_click? : MouseEventHandler[@dom.Element],
    |   on_change? : ChangeEventHandler[@dom.Element],
    |   on_keydown? : KeyboardEventHandler[@dom.Element],
    |   on_keyup? : KeyboardEventHandler[@dom.Element],
    |   on_focus? : FocusEventHandler[@dom.Element],
    |   on_blur? : FocusEventHandler[@dom.Element],
    |   on_drag? : DragEventHandler[@dom.Element],
    |   on_dragstart? : DragEventHandler[@dom.Element],
    |   on_dragend? : DragEventHandler[@dom.Element],
    |   on_dragleave? : DragEventHandler[@dom.Element],
    |   on_dragenter? : DragEventHandler[@dom.Element],
    |   on_dragover? : DragEventHandler[@dom.Element],
    |   on_drop? : DragEventHandler[@dom.Element],
    | ) -> @react.Element {
    |   let attrs : @js.Object = match props {
    |     Some(p) =>
269 |       if @js.Object::keys(p).length() > 0 {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         @js.Object::assign(@js.Object::new(), p) |> unsafe_cast
    |       } else {
272 |         p
    |         ^ 	<-- UNCOVERED
    |       }
    |     None => @js.Object::new()
    |   }
    |   attrs.set("x", x)
    |   attrs.set("y", y)
    |   attrs.set("width", width)
    |   attrs.set("height", height)
    |   if stroke is Some(stroke) {
281 |     attrs.set("stroke", stroke)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if stroke_width is Some(stroke_width) {
284 |     attrs.set("strokeWidth", stroke_width)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if fill is Some(fill) {
    |     attrs.set("fill", fill)
    |   }
    |   common_node(
    |     "rect",
    |     attrs,
    |     id~,
    |     class~,
    |     style~,
    |     tab_index~,
    |     ref_~,
    |     key~,
    |     on_click~,
    |     on_change~,
    |     on_keydown~,
    |     on_keyup~,
    |     on_focus~,
    |     on_blur~,
    |     on_drag~,
    |     on_dragend~,
    |     on_dragenter~,
    |     on_dragleave~,
    |     on_dragover~,
    |     on_dragstart~,
    |     on_drop~,
    |     children=[],
    |   )
    | }
    …

    | pub fn line(
    |   // common props
    |   x1~ : Int,
    |   y1~ : Int,
    |   x2~ : Int,
    |   y2~ : Int,
    |   stroke? : String,
    |   stroke_width? : Int,
    |   fill? : String,
    | 
    |   // shared
    |   props? : @js.Object,
    |   id? : String,
    |   class? : String,
    |   style? : Map[String, String],
    |   tab_index? : Int,
    |   // react
    |   ref_? : ReactRef[@dom.Element],
    |   key? : String,
    |   // event handlers
    |   on_click? : MouseEventHandler[@dom.Element],
    |   on_change? : ChangeEventHandler[@dom.Element],
    |   on_keydown? : KeyboardEventHandler[@dom.Element],
    |   on_keyup? : KeyboardEventHandler[@dom.Element],
    |   on_focus? : FocusEventHandler[@dom.Element],
    |   on_blur? : FocusEventHandler[@dom.Element],
    |   on_drag? : DragEventHandler[@dom.Element],
    |   on_dragstart? : DragEventHandler[@dom.Element],
    |   on_dragend? : DragEventHandler[@dom.Element],
    |   on_dragleave? : DragEventHandler[@dom.Element],
    |   on_dragenter? : DragEventHandler[@dom.Element],
    |   on_dragover? : DragEventHandler[@dom.Element],
    |   on_drop? : DragEventHandler[@dom.Element],
    | ) -> @react.Element {
    |   let attrs : @js.Object = match props {
    |     Some(p) =>
352 |       if @js.Object::keys(p).length() > 0 {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         @js.Object::assign(@js.Object::new(), p) |> unsafe_cast
    |       } else {
355 |         p
    |         ^ 	<-- UNCOVERED
    |       }
    |     None => @js.Object::new()
    |   }
    |   attrs.set("x1", x1)
    |   attrs.set("y1", y1)
    |   attrs.set("x2", x2)
    |   attrs.set("y2", y2)
    |   if stroke is Some(stroke) {
    |     attrs.set("stroke", stroke)
    |   }
    |   if stroke_width is Some(stroke_width) {
    |     attrs.set("strokeWidth", stroke_width)
    |   }
    |   if fill is Some(fill) {
370 |     attrs.set("fill", fill)
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   common_node(
    |     "line",
    |     attrs,
    |     id~,
    |     class~,
    |     style~,
    |     tab_index~,
    |     ref_~,
    |     key~,
    |     on_click~,
    |     on_change~,
    |     on_keydown~,
    |     on_keyup~,
    |     on_focus~,
    |     on_blur~,
    |     on_drag~,
    |     on_dragend~,
    |     on_dragenter~,
    |     on_dragleave~,
    |     on_dragover~,
    |     on_dragstart~,
    |     on_drop~,
    |     children=[],
    |   )
    | }
    …

    | pub fn path(
    |   // common props
    |   d~ : String,
    |   stroke? : String,
    |   stroke_width? : Int,
    |   fill? : String,
    | 
    |   // shared
    |   props? : @js.Object,
    |   id? : String,
    |   class? : String,
    |   style? : Map[String, String],
    |   tab_index? : Int,
    |   // react
    |   ref_? : ReactRef[@dom.Element],
    |   key? : String,
    |   // event handlers
    |   on_click? : MouseEventHandler[@dom.Element],
    |   on_change? : ChangeEventHandler[@dom.Element],
    |   on_keydown? : KeyboardEventHandler[@dom.Element],
    |   on_keyup? : KeyboardEventHandler[@dom.Element],
    |   on_focus? : FocusEventHandler[@dom.Element],
    |   on_blur? : FocusEventHandler[@dom.Element],
    |   on_drag? : DragEventHandler[@dom.Element],
    |   on_dragstart? : DragEventHandler[@dom.Element],
    |   on_dragend? : DragEventHandler[@dom.Element],
    |   on_dragleave? : DragEventHandler[@dom.Element],
    |   on_dragenter? : DragEventHandler[@dom.Element],
    |   on_dragover? : DragEventHandler[@dom.Element],
    |   on_drop? : DragEventHandler[@dom.Element],
    | ) -> @react.Element {
    |   let attrs : @js.Object = match props {
    |     Some(p) =>
432 |       if @js.Object::keys(p).length() > 0 {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         @js.Object::assign(@js.Object::new(), p) |> unsafe_cast
    |       } else {
435 |         p
    |         ^ 	<-- UNCOVERED
    |       }
    |     None => @js.Object::new()
    |   }
    |   attrs.set("d", d)
    |   if stroke is Some(stroke) {
    |     attrs.set("stroke", stroke)
    |   }
    |   if stroke_width is Some(stroke_width) {
    |     attrs.set("strokeWidth", stroke_width)
    |   }
    |   if fill is Some(fill) {
447 |     attrs.set("fill", fill)
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   common_node(
    |     "path",
    |     attrs,
    |     id~,
    |     class~,
    |     style~,
    |     tab_index~,
    |     ref_~,
    |     key~,
    |     on_click~,
    |     on_change~,
    |     on_keydown~,
    |     on_keyup~,
    |     on_focus~,
    |     on_blur~,
    |     on_drag~,
    |     on_dragend~,
    |     on_dragenter~,
    |     on_dragleave~,
    |     on_dragover~,
    |     on_dragstart~,
    |     on_drop~,
    |     children=[],
    |   )
    | }
    …

    | pub fn use_(
    |   // common props
    |   href~ : String,
    | 
    |   // shared
    |   props? : @js.Object,
    |   id? : String,
    |   class? : String,
    |   style? : Map[String, String],
    |   tab_index? : Int,
    |   // react
    |   ref_? : ReactRef[@dom.Element],
    |   key? : String,
    |   // event handlers
    |   on_click? : MouseEventHandler[@dom.Element],
    |   on_change? : ChangeEventHandler[@dom.Element],
    |   on_keydown? : KeyboardEventHandler[@dom.Element],
    |   on_keyup? : KeyboardEventHandler[@dom.Element],
    |   on_focus? : FocusEventHandler[@dom.Element],
    |   on_blur? : FocusEventHandler[@dom.Element],
    |   on_drag? : DragEventHandler[@dom.Element],
    |   on_dragstart? : DragEventHandler[@dom.Element],
    |   on_dragend? : DragEventHandler[@dom.Element],
    |   on_dragleave? : DragEventHandler[@dom.Element],
    |   on_dragenter? : DragEventHandler[@dom.Element],
    |   on_dragover? : DragEventHandler[@dom.Element],
    |   on_drop? : DragEventHandler[@dom.Element],
    | ) -> @react.Element {
504 |   let attrs : @js.Object = match props {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(p) =>
506 |       if @js.Object::keys(p).length() > 0 {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         @js.Object::assign(@js.Object::new(), p) |> unsafe_cast
    |       } else {
509 |         p
    |         ^ 	<-- UNCOVERED
    |       }
511 |     None => @js.Object::new()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
513 |   attrs.set("href", href)
    |   ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   common_node(
    |     "use",
    |     attrs,
    |     id~,
    |     class~,
    |     style~,
    |     tab_index~,
    |     ref_~,
    |     key~,
    |     on_click~,
    |     on_change~,
    |     on_keydown~,
    |     on_keyup~,
    |     on_focus~,
    |     on_blur~,
    |     on_drag~,
    |     on_dragend~,
    |     on_dragenter~,
    |     on_dragleave~,
    |     on_dragover~,
    |     on_dragstart~,
    |     on_drop~,
    |     children=[],
    |   )
    | }
    …

    | pub fn polygon(
    |   // common props
    |   points~ : Array[(Int, Int)],
    |   stroke? : String,
    |   stroke_width? : Int,
    |   fill? : String,
    | 
    |   // shared
    |   props? : @js.Object,
    |   id? : String,
    |   class? : String,
    |   style? : Map[String, String],
    |   tab_index? : Int,
    |   // react
    |   ref_? : ReactRef[@dom.Element],
    |   key? : String,
    |   // event handlers
    |   on_click? : MouseEventHandler[@dom.Element],
    |   on_change? : ChangeEventHandler[@dom.Element],
    |   on_keydown? : KeyboardEventHandler[@dom.Element],
    |   on_keyup? : KeyboardEventHandler[@dom.Element],
    |   on_focus? : FocusEventHandler[@dom.Element],
    |   on_blur? : FocusEventHandler[@dom.Element],
    |   on_drag? : DragEventHandler[@dom.Element],
    |   on_dragstart? : DragEventHandler[@dom.Element],
    |   on_dragend? : DragEventHandler[@dom.Element],
    |   on_dragleave? : DragEventHandler[@dom.Element],
    |   on_dragenter? : DragEventHandler[@dom.Element],
    |   on_dragover? : DragEventHandler[@dom.Element],
    |   on_drop? : DragEventHandler[@dom.Element],
    | ) -> @react.Element {
572 |   let attrs : @js.Object = match props {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(p) =>
574 |       if @js.Object::keys(p).length() > 0 {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         @js.Object::assign(@js.Object::new(), p) |> unsafe_cast
    |       } else {
577 |         p
    |         ^ 	<-- UNCOVERED
    |       }
579 |     None => @js.Object::new()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
581 |   attrs.set("points", points |> unsafe_cast)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   if stroke is Some(stroke) {
583 |     attrs.set("stroke", stroke)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if stroke_width is Some(stroke_width) {
586 |     attrs.set("strokeWidth", stroke_width)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if fill is Some(fill) {
589 |     attrs.set("fill", fill)
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
591 |   common_node(
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     "points",
    |     attrs,
    |     id~,
    |     class~,
    |     style~,
    |     tab_index~,
    |     ref_~,
    |     key~,
    |     on_click~,
    |     on_change~,
    |     on_keydown~,
    |     on_keyup~,
    |     on_focus~,
    |     on_blur~,
    |     on_drag~,
    |     on_dragend~,
    |     on_dragenter~,
    |     on_dragleave~,
    |     on_dragover~,
    |     on_dragstart~,
    |     on_drop~,
    |     children=[],
    |   )
    | }
    …

    | pub fn polyline(
    |   // common props
    |   points~ : Array[(Int, Int)],
    |   stroke? : String,
    |   stroke_width? : Int,
    |   fill? : String,
    | 
    |   // shared
    |   props? : @js.Object,
    |   id? : String,
    |   class? : String,
    |   style? : Map[String, String],
    |   tab_index? : Int,
    |   // react
    |   ref_? : ReactRef[@dom.Element],
    |   key? : String,
    |   // event handlers
    |   on_click? : MouseEventHandler[@dom.Element],
    |   on_change? : ChangeEventHandler[@dom.Element],
    |   on_keydown? : KeyboardEventHandler[@dom.Element],
    |   on_keyup? : KeyboardEventHandler[@dom.Element],
    |   on_focus? : FocusEventHandler[@dom.Element],
    |   on_blur? : FocusEventHandler[@dom.Element],
    |   on_drag? : DragEventHandler[@dom.Element],
    |   on_dragstart? : DragEventHandler[@dom.Element],
    |   on_dragend? : DragEventHandler[@dom.Element],
    |   on_dragleave? : DragEventHandler[@dom.Element],
    |   on_dragenter? : DragEventHandler[@dom.Element],
    |   on_dragover? : DragEventHandler[@dom.Element],
    |   on_drop? : DragEventHandler[@dom.Element],
    | ) -> @react.Element {
649 |   let attrs : @js.Object = match props {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(p) =>
651 |       if @js.Object::keys(p).length() > 0 {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         @js.Object::assign(@js.Object::new(), p) |> unsafe_cast
    |       } else {
654 |         p
    |         ^ 	<-- UNCOVERED
    |       }
656 |     None => @js.Object::new()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
658 |   attrs.set("points", points |> unsafe_cast)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   if stroke is Some(stroke) {
660 |     attrs.set("stroke", stroke)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if stroke_width is Some(stroke_width) {
663 |     attrs.set("strokeWidth", stroke_width)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if fill is Some(fill) {
666 |     attrs.set("fill", fill)
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
668 |   common_node(
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     "polyline",
    |     attrs,
    |     id~,
    |     class~,
    |     style~,
    |     tab_index~,
    |     ref_~,
    |     key~,
    |     on_click~,
    |     on_change~,
    |     on_keydown~,
    |     on_keyup~,
    |     on_focus~,
    |     on_blur~,
    |     on_drag~,
    |     on_dragend~,
    |     on_dragenter~,
    |     on_dragleave~,
    |     on_dragover~,
    |     on_dragstart~,
    |     on_drop~,
    |     children=[],
    |   )
    | }
    …

    | pub fn g(
    |   children : Array[&ReactNode],
    |   // common props
    |   stroke? : String,
    |   stroke_width? : Int,
    |   fill? : String,
    | 
    |   // shared
    |   props? : @js.Object,
    |   id? : String,
    |   class? : String,
    |   style? : Map[String, String],
    |   tab_index? : Int,
    |   // react
    |   ref_? : ReactRef[@dom.Element],
    |   key? : String,
    |   // event handlers
    |   on_click? : MouseEventHandler[@dom.Element],
    |   on_change? : ChangeEventHandler[@dom.Element],
    |   on_keydown? : KeyboardEventHandler[@dom.Element],
    |   on_keyup? : KeyboardEventHandler[@dom.Element],
    |   on_focus? : FocusEventHandler[@dom.Element],
    |   on_blur? : FocusEventHandler[@dom.Element],
    |   on_drag? : DragEventHandler[@dom.Element],
    |   on_dragstart? : DragEventHandler[@dom.Element],
    |   on_dragend? : DragEventHandler[@dom.Element],
    |   on_dragleave? : DragEventHandler[@dom.Element],
    |   on_dragenter? : DragEventHandler[@dom.Element],
    |   on_dragover? : DragEventHandler[@dom.Element],
    |   on_drop? : DragEventHandler[@dom.Element],
    | ) -> @react.Element {
    |   let attrs : @js.Object = match props {
    |     Some(p) =>
728 |       if @js.Object::keys(p).length() > 0 {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         @js.Object::assign(@js.Object::new(), p) |> unsafe_cast
    |       } else {
731 |         p
    |         ^ 	<-- UNCOVERED
    |       }
    |     None => @js.Object::new()
    |   }
    |   if stroke is Some(stroke) {
    |     attrs.set("stroke", stroke)
    |   }
    |   if stroke_width is Some(stroke_width) {
739 |     attrs.set("strokeWidth", stroke_width)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if fill is Some(fill) {
742 |     attrs.set("fill", fill)
    |     ^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   common_node(
    |     "g",
    |     attrs,
    |     id~,
    |     class~,
    |     style~,
    |     tab_index~,
    |     ref_~,
    |     key~,
    |     on_click~,
    |     on_change~,
    |     on_keydown~,
    |     on_keyup~,
    |     on_focus~,
    |     on_blur~,
    |     on_drag~,
    |     on_dragend~,
    |     on_dragenter~,
    |     on_dragleave~,
    |     on_dragover~,
    |     on_dragstart~,
    |     on_drop~,
    |     children~,
    |   )
    | }
    …

    | pub fn defs(
    |   children : Array[&ReactNode],
    |   // shared
    |   props? : @js.Object,
    |   id? : String,
    |   class? : String,
    |   style? : Map[String, String],
    |   tab_index? : Int,
    |   // react
    |   ref_? : ReactRef[@dom.Element],
    |   key? : String,
    |   // event handlers
    |   on_click? : MouseEventHandler[@dom.Element],
    |   on_change? : ChangeEventHandler[@dom.Element],
    |   on_keydown? : KeyboardEventHandler[@dom.Element],
    |   on_keyup? : KeyboardEventHandler[@dom.Element],
    |   on_focus? : FocusEventHandler[@dom.Element],
    |   on_blur? : FocusEventHandler[@dom.Element],
    |   on_drag? : DragEventHandler[@dom.Element],
    |   on_dragstart? : DragEventHandler[@dom.Element],
    |   on_dragend? : DragEventHandler[@dom.Element],
    |   on_dragleave? : DragEventHandler[@dom.Element],
    |   on_dragenter? : DragEventHandler[@dom.Element],
    |   on_dragover? : DragEventHandler[@dom.Element],
    |   on_drop? : DragEventHandler[@dom.Element],
    | ) -> @react.Element {
    |   let attrs : @js.Object = match props {
    |     Some(p) =>
799 |       if @js.Object::keys(p).length() > 0 {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         @js.Object::assign(@js.Object::new(), p) |> unsafe_cast
    |       } else {
802 |         p
    |         ^ 	<-- UNCOVERED
    |       }
    |     None => @js.Object::new()
    |   }
    |   common_node(
    |     "defs",
    |     attrs,
    |     id~,
    |     class~,
    |     style~,
    |     tab_index~,
    |     ref_~,
    |     key~,
    |     on_click~,
    |     on_change~,
    |     on_keydown~,
    |     on_keyup~,
    |     on_focus~,
    |     on_blur~,
    |     on_drag~,
    |     on_dragend~,
    |     on_dragenter~,
    |     on_dragleave~,
    |     on_dragover~,
    |     on_dragstart~,
    |     on_drop~,
    |     children~,
    |   )
    | }
    …

    | pub fn text(
    |   children : Array[&ReactNode],
    |   // common props
    |   x~ : Int,
    |   y~ : Int,
    |   dx? : String,
    |   dy? : String,
    |   length_adjust? : String,
    |   text_length? : String,
    |   rotate? : String,
    |   stroke? : String,
    |   stroke_width? : Int,
    |   fill? : String,
    | 
    |   // shared
    |   props? : @js.Object,
    |   id? : String,
    |   class? : String,
    |   style? : Map[String, String],
    |   tab_index? : Int,
    |   // react
    |   ref_? : ReactRef[@dom.Element],
    |   key? : String,
    |   // event handlers
    |   on_click? : MouseEventHandler[@dom.Element],
    |   on_change? : ChangeEventHandler[@dom.Element],
    |   on_keydown? : KeyboardEventHandler[@dom.Element],
    |   on_keyup? : KeyboardEventHandler[@dom.Element],
    |   on_focus? : FocusEventHandler[@dom.Element],
    |   on_blur? : FocusEventHandler[@dom.Element],
    |   on_drag? : DragEventHandler[@dom.Element],
    |   on_dragstart? : DragEventHandler[@dom.Element],
    |   on_dragend? : DragEventHandler[@dom.Element],
    |   on_dragleave? : DragEventHandler[@dom.Element],
    |   on_dragenter? : DragEventHandler[@dom.Element],
    |   on_dragover? : DragEventHandler[@dom.Element],
    |   on_drop? : DragEventHandler[@dom.Element],
    | ) -> @react.Element {
    |   let attrs : @js.Object = match props {
    |     Some(p) =>
873 |       if @js.Object::keys(p).length() > 0 {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         @js.Object::assign(@js.Object::new(), p) |> unsafe_cast
    |       } else {
876 |         p
    |         ^ 	<-- UNCOVERED
    |       }
    |     None => @js.Object::new()
    |   }
    |   attrs.set("x", x)
    |   attrs.set("y", y)
    |   if dx is Some(dx) {
883 |     attrs.set("dx", dx)
    |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if dy is Some(dy) {
886 |     attrs.set("dy", dy)
    |     ^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if length_adjust is Some(length_adjust) {
889 |     attrs.set("lengthAdjust", length_adjust)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if text_length is Some(text_length) {
892 |     attrs.set("textLength", text_length)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if stroke is Some(stroke) {
895 |     attrs.set("stroke", stroke)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if stroke_width is Some(stroke_width) {
898 |     attrs.set("strokeWidth", stroke_width)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   if fill is Some(fill) {
    |     attrs.set("fill", fill)
    |   }
    |   if rotate is Some(rotate) {
904 |     attrs.set("rotate", rotate)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   common_node(
    |     "text",
    |     attrs,
    |     id~,
    |     class~,
    |     style~,
    |     tab_index~,
    |     ref_~,
    |     key~,
    |     on_click~,
    |     on_change~,
    |     on_keydown~,
    |     on_keyup~,
    |     on_focus~,
    |     on_blur~,
    |     on_drag~,
    |     on_dragend~,
    |     on_dragenter~,
    |     on_dragleave~,
    |     on_dragover~,
    |     on_dragstart~,
    |     on_drop~,
    |     children~,
    |   )
    | }
    …

    | pub fn image(
    |   x~ : Int,
    |   y~ : Int,
    |   href~ : String,
    |   // shared
    |   props? : @js.Object,
    |   id? : String,
    |   class? : String,
    |   style? : Map[String, String],
    |   tab_index? : Int,
    |   // react
    |   ref_? : ReactRef[@dom.Element],
    |   key? : String,
    |   // event handlers
    |   on_click? : MouseEventHandler[@dom.Element],
    |   on_change? : ChangeEventHandler[@dom.Element],
    |   on_keydown? : KeyboardEventHandler[@dom.Element],
    |   on_keyup? : KeyboardEventHandler[@dom.Element],
    |   on_focus? : FocusEventHandler[@dom.Element],
    |   on_blur? : FocusEventHandler[@dom.Element],
    |   on_drag? : DragEventHandler[@dom.Element],
    |   on_dragstart? : DragEventHandler[@dom.Element],
    |   on_dragend? : DragEventHandler[@dom.Element],
    |   on_dragleave? : DragEventHandler[@dom.Element],
    |   on_dragenter? : DragEventHandler[@dom.Element],
    |   on_dragover? : DragEventHandler[@dom.Element],
    |   on_drop? : DragEventHandler[@dom.Element],
    | ) -> @react.Element {
    |   let attrs : @js.Object = match props {
    |     Some(p) =>
963 |       if @js.Object::keys(p).length() > 0 {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         @js.Object::assign(@js.Object::new(), p) |> unsafe_cast
    |       } else {
966 |         p
    |         ^ 	<-- UNCOVERED
    |       }
    |     None => @js.Object::new()
    |   }
    |   attrs.set("x", x)
    |   attrs.set("y", y)
    |   attrs.set("href", href)
    |   common_node(
    |     "image",
    |     attrs,
    |     id~,
    |     class~,
    |     style~,
    |     tab_index~,
    |     ref_~,
    |     key~,
    |     on_click~,
    |     on_change~,
    |     on_keydown~,
    |     on_keyup~,
    |     on_focus~,
    |     on_blur~,
    |     on_drag~,
    |     on_dragend~,
    |     on_dragenter~,
    |     on_dragleave~,
    |     on_dragover~,
    |     on_dragstart~,
    |     on_drop~,
    |     children=[],
    |   )
    | }
    …

2 uncovered line(s) in src/npm/react/hooks.mbt:

    | pub fn[T] use_(promise : Promise[T]) -> T {
160 |   unsafe_cast(ffi_react_use(promise |> unsafe_cast))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[T] lazy_(f : async () -> (T) -> Element) -> (EmptyProps) -> Promise[Js] {
230 |   f |> @promise.promisify0 |> @js.unsafe_js |> ffi_react_lazy() |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

1 uncovered line(s) in src/npm/react/init.mbt:

   | pub async fn init_react_async() -> Unit {
18 |   if @js.is_nullish(global_this().get("__ReactApi")) {
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     let react : Js = import_react().unwrap()
   |     global_this().set("__ReactApi", react)
   |   }
   | }
   …

2 uncovered line(s) in src/npm/react_dom/client.mbt:

   | #alias(create_root)
   | pub fn ReactDOMClient::createRoot(
   |   self : Self,
   |   container : &@dom.ElementImpl,
   | ) -> ReactDOMRoot {
21 |   self.call("createRoot", [container.to_js()]) |> unsafe_cast
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn ReactDOMRoot::render(self : ReactDOMRoot, vdom : @react.Element) -> Unit {
26 |   self.call("render", [vdom]) |> ignore
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

2 uncovered line(s) in src/npm/react_dom/server.mbt:

   | #alias(render_to_string)
   | pub fn renderToString(element : @react.Element) -> String {
 4 |   let react_dom_server : Js = @node.require("react-dom/server")
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   unsafe_cast(react_dom_server.get("renderToString").call_self([element]))
   | }
   …

   | #alias(render_to_readable_stream)
   | pub fn renderToReadableStream(
   |   element : @react.Element,
   | ) -> Promise[ReadableStream] {
13 |   let react_dom_server : Js = @node.require("react-dom/server")
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   unsafe_cast(
   |     react_dom_server.get("renderToReadableStream").call_self([element]),
   |   )
   | }
   …

7 uncovered line(s) in src/npm/react_router/lib.mbt:

   | pub async fn init_react_router_async() -> Unit {
13 |   if @js.is_undefined(@js.globalThis().get("__ReactRouterApi")) {
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     let v = import_react_router().unwrap()
   |     @js.globalThis().set("__ReactRouterApi", v)
   |   }
   | }
   …

   | #alias(router_provider)
   | pub fn routerProvider(router : Router) -> @react.Element {
35 |   let p = get_router_provider()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   @react.c(p, RouterProviderProps::{ router, })
   | }
   …

   | impl JsImpl for Route with to_js(self : Route) {
55 |   match self {
   |   ^^^^^^^^^^^^ 	<-- UNCOVERED
   |     Route::Component(path~, component~) => {
   |       let obj = @js.Object::new()
   |       obj.set("path", path)
   |       obj.set("Component", component |> @js.unsafe_js)
   |       obj.to_js()
   |     }
62 |     Route::Element(path~, element~) => {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |       let obj = @js.Object::new()
   |       obj.set("path", path)
   |       obj.set("element", element |> @js.unsafe_js)
   |       obj.to_js()
   |     }
   |   }
   | }
   …

   | #alias(create_browser_router)
   | pub fn createBrowserRouter(routes : Array[Route]) -> Router {
74 |   let create_browser_router : (Array[Js]) -> Router = unsafe_cast(
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     @js.global_this().get("__ReactRouterApi").get("createBrowserRouter"),
   |   )
77 |   create_browser_router(routes.map(_.to_js()))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn link(to~ : String, children : Array[&JsImpl]) -> @react.Element {
91 |   let p = get_link()
   |   ^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   @react.c(p, LinkProps::{ to, }, children~)
   | }
   …

2 uncovered line(s) in src/npm/react_testing_library/rtl.mbt:

   | pub fn Screen::debug(self : Self) -> Unit {
73 |   self.call("debug", []) |> ignore
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Screen::getByRole(self : Screen, role : String) -> Js {
85 |   self.call("getByRole", [role]) |> unsafe_cast
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

7 uncovered line(s) in src/performance/observer.mbt:

   | pub fn PerformanceObserver::new(
   |   callback : (PerformanceObserverEntryList, PerformanceObserver) -> Unit,
   | ) -> PerformanceObserver {
30 |   ffi_new_performance_observer(fn(list, observer) {
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     callback(@js.unsafe_cast(list), @js.unsafe_cast(observer))
   |   })
   | }
   …

   | pub fn PerformanceObserver::observe(
   |   self : PerformanceObserver,
   |   options : @js.Object,
   | ) -> Unit {
43 |   self.call("observe", [options]) |> ignore
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn PerformanceObserver::disconnect(self : PerformanceObserver) -> Unit {
50 |   self.call("disconnect", []) |> ignore
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn PerformanceObserver::takeRecords(
   |   self : PerformanceObserver,
   | ) -> Array[PerformanceEntry] {
59 |   self.call("takeRecords", []) |> @js.unsafe_cast
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn PerformanceObserverEntryList::getEntries(
   |   self : PerformanceObserverEntryList,
   | ) -> Array[PerformanceEntry] {
68 |   self.call("getEntries", []) |> @js.unsafe_cast
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn PerformanceObserverEntryList::getEntriesByType(
   |   self : PerformanceObserverEntryList,
   |   entryType : String,
   | ) -> Array[PerformanceEntry] {
78 |   self.call("getEntriesByType", [entryType]) |> @js.unsafe_cast
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn PerformanceObserverEntryList::getEntriesByName(
   |   self : PerformanceObserverEntryList,
   |   name : String,
   | ) -> Array[PerformanceEntry] {
88 |   self.call("getEntriesByName", [name]) |> @js.unsafe_cast
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

14 uncovered line(s) in src/performance/performance.mbt:

    | pub fn performance() -> Performance {
 24 |   @js.global_this().get("performance") |> @js.unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Performance::now(self : Performance) -> Double {
 31 |   self.call("now", []) |> @js.unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Performance::timeOrigin(self : Performance) -> Double {
 38 |   self.get("timeOrigin") |> @js.unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Performance::mark(self : Performance, name : String) -> PerformanceEntry {
 45 |   self.call("mark", [name]) |> @js.unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Performance::measure(
    |   self : Performance,
    |   name : String,
    |   startMark? : String,
    |   endMark? : String,
    | ) -> PerformanceEntry {
 57 |   match (startMark, endMark) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     (Some(s), Some(e)) => self.call("measure", [name, s, e]) |> @js.unsafe_cast
    |     (Some(s), None) => self.call("measure", [name, s]) |> @js.unsafe_cast
    |     (None, _) => self.call("measure", [name]) |> @js.unsafe_cast
    |   }
    | }
    …

    | pub fn Performance::getEntries(self : Performance) -> Array[PerformanceEntry] {
 68 |   self.call("getEntries", []) |> @js.unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Performance::getEntriesByType(
    |   self : Performance,
    |   entryType : String,
    | ) -> Array[PerformanceEntry] {
 78 |   self.call("getEntriesByType", [entryType]) |> @js.unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Performance::getEntriesByName(
    |   self : Performance,
    |   name : String,
    | ) -> Array[PerformanceEntry] {
 88 |   self.call("getEntriesByName", [name]) |> @js.unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Performance::clearMarks(self : Performance, name? : String) -> Unit {
 95 |   match name {
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(n) => self.call("clearMarks", [n]) |> ignore
    |     None => self.call("clearMarks", []) |> ignore
    |   }
    | }
    …

    | pub fn Performance::clearMeasures(self : Performance, name? : String) -> Unit {
105 |   match name {
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(n) => self.call("clearMeasures", [n]) |> ignore
    |     None => self.call("clearMeasures", []) |> ignore
    |   }
    | }
    …

    | pub fn PerformanceEntry::name(self : PerformanceEntry) -> String {
114 |   self.get("name") |> @js.unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn PerformanceEntry::entryType(self : PerformanceEntry) -> String {
120 |   self.get("entryType") |> @js.unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn PerformanceEntry::startTime(self : PerformanceEntry) -> Double {
126 |   self.get("startTime") |> @js.unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn PerformanceEntry::duration(self : PerformanceEntry) -> Double {
132 |   self.get("duration") |> @js.unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

5 uncovered line(s) in src/promise/async_utils.mbt:

   | pub fn[R] promisify0(f : async () -> R) -> () -> Promise[R] noraise {
14 |   () => {
   |   ^^^^^^^ 	<-- UNCOVERED
   |     let { promise, resolve, reject } = Promise::withResolvers()
   |     run_async(() => try f() |> resolve catch {
   |       e => reject(e)
   |     })
   |     promise
   |   }
   | }
   …

   | pub fn[A, R] promisify1(f : async (A) -> R) -> (A) -> Promise[R] noraise {
   |   a => {
27 |     let { promise, resolve, reject } = Promise::withResolvers()
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     run_async(() => try f(a) |> resolve catch {
   |       e => reject(e)
   |     })
   |     promise
   |   }
   | }
   …

   | pub fn[A, B, R] promisify2(
   |   f : async (A, B) -> R,
   | ) -> (A, B) -> Promise[R] noraise {
   |   (a, b) => {
41 |     let { promise, resolve, reject } = Promise::withResolvers()
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     run_async(() => try f(a, b) |> resolve catch {
   |       e => reject(e)
   |     })
   |     promise
   |   }
   | }
   …

   | pub fn[A, B, C, R] promisify3(
   |   f : async (A, B, C) -> R,
   | ) -> (A, B, C) -> Promise[R] noraise {
54 |   (a, b, c) => {
   |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     let { promise, resolve, reject } = Promise::withResolvers()
   |     run_async(() => try f(a, b, c) |> resolve catch {
   |       e => reject(e)
   |     })
   |     promise
   |   }
   | }
   …

   | pub async fn sleep(ms : Int) -> Unit noraise {
70 |   ffi_sleep(ms).unwrap() catch {
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     _ => panic()
   |   }
   | }
   …

15 uncovered line(s) in src/promise/promise.mbt:

    | pub fn[A] Promise::new(
    |   f : ((A) -> Unit, (Error) -> Unit) -> Unit,
    | ) -> Promise[A] {
    |   ffi_new_promise(fn(resolve, reject) {
 20 |     f(a => a |> unsafe_cast |> resolve, e => e |> unsafe_cast |> reject)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   })
    |   |> unsafe_cast
    | }
    …

    | pub fn[A] Promise::resolve(x : A) -> Self[A] {
 28 |   ffi_promise_resolve(unsafe_cast(x)) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn Promise::reject(x : Js) -> Self[Js] {
 34 |   ffi_promise_reject(unsafe_cast(x)) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[A, B] Promise::then(
    |   self : Self[A],
    |   resolve : (A) -> Self[B] raise,
    | ) -> Promise[B] {
 42 |   ffi_promise_then(self.to_js(), a => (a
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   |> unsafe_cast
    |   |> resolve
    |   |> unsafe_cast) catch {
    |     e => e |> ffi_promise_reject |> unsafe_cast
    |   })
 48 |   |> unsafe_cast
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[A, B] Promise::catch_(
    |   self : Self[A],
    |   f : (Error) -> Promise[B],
    | ) -> Promise[B] {
 56 |   self.call("catch", [@js.from_fn1(f)]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[A] Promise::finally_(self : Self[A], f : () -> Unit) -> Self[A] {
 62 |   self.call("finally", [@js.from_fn0(f)]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[A] Promise::all(promises : Array[Promise[A]]) -> Promise[Array[A]] {
 78 |   ffi_promise_all(promises |> unsafe_cast) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[T] Promise::race(promises : Array[Promise[T]]) -> Promise[T] {
 84 |   ffi_promise_race(promises |> unsafe_cast) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[T] Promise::any(promises : Array[Promise[T]]) -> Promise[T] {
 90 |   ffi_promise_any(promises |> unsafe_cast) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[A] Promise::allSettled(
    |   promises : Array[Promise[A]],
    | ) -> Promise[Array[SettledResult[A]]] {
106 |   ffi_promise_all(promises |> unsafe_cast) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[R] Promise::try_(f : async () -> R) -> Promise[R] noraise {
119 |   let { promise, resolve, reject } = Promise::withResolvers()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   run_async(() => try f() |> resolve catch {
    |     e => reject(e)
    |   })
    |   promise
    | }
    …

    | pub fn[T] Promise::withResolvers() -> Resolvers[T] {
137 |   ffi_promise_with_resolvers() |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[T] Resolvers::resolve(self : Self[T], value : T) -> Unit {
143 |   (self.resolve)(value)
    |   ^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[T] Resolvers::reject(self : Self[T], error : Error) -> Unit {
149 |   (self.reject)(error)
    |   ^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

23 uncovered line(s) in src/proxy/proxy.mbt:

    | pub fn Proxy::new(
    |   target : &@js.JsImpl,
    |   get? : (@js.Js, @js.Js, @js.Js) -> @js.Js,
    |   set? : (@js.Js, @js.Js, @js.Js, @js.Js) -> Bool,
    |   has? : (@js.Js, @js.Js) -> Bool,
    |   deleteProperty? : (@js.Js, @js.Js) -> Bool,
    |   apply? : (@js.Js, @js.Js, @js.Js) -> @js.Js,
    |   construct? : (@js.Js, @js.Js, @js.Js) -> @js.Js,
    |   ownKeys? : (@js.Js) -> @js.Js,
    |   getPrototypeOf? : (@js.Js) -> @js.Js,
    |   setPrototypeOf? : (@js.Js, @js.Js) -> Bool,
    |   isExtensible? : (@js.Js) -> Bool,
    |   preventExtensions? : (@js.Js) -> Bool,
    |   getOwnPropertyDescriptor? : (@js.Js, @js.Js) -> @js.Js,
    |   defineProperty? : (@js.Js, @js.Js, @js.Js) -> Bool,
    | ) -> Proxy {
    |   let handler = @js.Object::new()
    |   if get is Some(trap) {
    |     let js_fn : @js.Js = @js.unsafe_cast(trap)
    |     handler.set("get", js_fn)
    |   }
    |   if set is Some(trap) {
    |     let js_fn : @js.Js = @js.unsafe_cast(trap)
    |     handler.set("set", js_fn)
    |   }
    |   if has is Some(trap) {
    |     let js_fn : @js.Js = @js.unsafe_cast(trap)
    |     handler.set("has", js_fn)
    |   }
    |   if deleteProperty is Some(trap) {
 61 |     let js_fn : @js.Js = @js.unsafe_cast(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("deleteProperty", js_fn)
    |   }
    |   if apply is Some(trap) {
 65 |     let js_fn : @js.Js = @js.unsafe_cast(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("apply", js_fn)
    |   }
    |   if construct is Some(trap) {
 69 |     let js_fn : @js.Js = @js.unsafe_cast(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("construct", js_fn)
    |   }
    |   if ownKeys is Some(trap) {
 73 |     let js_fn : @js.Js = @js.unsafe_cast(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("ownKeys", js_fn)
    |   }
    |   if getPrototypeOf is Some(trap) {
 77 |     let js_fn : @js.Js = @js.unsafe_cast(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("getPrototypeOf", js_fn)
    |   }
    |   if setPrototypeOf is Some(trap) {
 81 |     let js_fn : @js.Js = @js.unsafe_cast(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("setPrototypeOf", js_fn)
    |   }
    |   if isExtensible is Some(trap) {
 85 |     let js_fn : @js.Js = @js.unsafe_cast(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("isExtensible", js_fn)
    |   }
    |   if preventExtensions is Some(trap) {
 89 |     let js_fn : @js.Js = @js.unsafe_cast(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("preventExtensions", js_fn)
    |   }
    |   if getOwnPropertyDescriptor is Some(trap) {
 93 |     let js_fn : @js.Js = @js.unsafe_cast(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("getOwnPropertyDescriptor", js_fn)
    |   }
    |   if defineProperty is Some(trap) {
 97 |     let js_fn : @js.Js = @js.unsafe_cast(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("defineProperty", js_fn)
    |   }
    |   @js.new_(proxy_class(), [target.to_js(), handler.to_js()]) |> @js.unsafe_cast
    | }
    …

    | pub fn Proxy::revocable(
    |   target : &@js.JsImpl,
    |   get? : (@js.Js, @js.Js, @js.Js) -> @js.Js,
    |   set? : (@js.Js, @js.Js, @js.Js, @js.Js) -> Bool,
    |   has? : (@js.Js, @js.Js) -> Bool,
    |   deleteProperty? : (@js.Js, @js.Js) -> Bool,
    |   apply? : (@js.Js, @js.Js, @js.Js) -> @js.Js,
    |   construct? : (@js.Js, @js.Js, @js.Js) -> @js.Js,
    |   ownKeys? : (@js.Js) -> @js.Js,
    |   getPrototypeOf? : (@js.Js) -> @js.Js,
    |   setPrototypeOf? : (@js.Js, @js.Js) -> Bool,
    |   isExtensible? : (@js.Js) -> Bool,
    |   preventExtensions? : (@js.Js) -> Bool,
    |   getOwnPropertyDescriptor? : (@js.Js, @js.Js) -> @js.Js,
    |   defineProperty? : (@js.Js, @js.Js, @js.Js) -> Bool,
    | ) -> @js.Js {
    |   let handler = @js.Object::new()
    |   if get is Some(trap) {
125 |     let js_fn : @js.Js = @js.unsafe_cast(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("get", js_fn)
    |   }
    |   if set is Some(trap) {
129 |     let js_fn : @js.Js = @js.unsafe_cast(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("set", js_fn)
    |   }
    |   if has is Some(trap) {
133 |     let js_fn : @js.Js = @js.unsafe_cast(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("has", js_fn)
    |   }
    |   if deleteProperty is Some(trap) {
137 |     let js_fn : @js.Js = @js.unsafe_cast(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("deleteProperty", js_fn)
    |   }
    |   if apply is Some(trap) {
141 |     let js_fn : @js.Js = @js.unsafe_cast(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("apply", js_fn)
    |   }
    |   if construct is Some(trap) {
145 |     let js_fn : @js.Js = @js.unsafe_cast(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("construct", js_fn)
    |   }
    |   if ownKeys is Some(trap) {
149 |     let js_fn : @js.Js = @js.unsafe_cast(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("ownKeys", js_fn)
    |   }
    |   if getPrototypeOf is Some(trap) {
153 |     let js_fn : @js.Js = @js.unsafe_cast(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("getPrototypeOf", js_fn)
    |   }
    |   if setPrototypeOf is Some(trap) {
157 |     let js_fn : @js.Js = @js.unsafe_cast(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("setPrototypeOf", js_fn)
    |   }
    |   if isExtensible is Some(trap) {
161 |     let js_fn : @js.Js = @js.unsafe_cast(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("isExtensible", js_fn)
    |   }
    |   if preventExtensions is Some(trap) {
165 |     let js_fn : @js.Js = @js.unsafe_cast(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("preventExtensions", js_fn)
    |   }
    |   if getOwnPropertyDescriptor is Some(trap) {
169 |     let js_fn : @js.Js = @js.unsafe_cast(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("getOwnPropertyDescriptor", js_fn)
    |   }
    |   if defineProperty is Some(trap) {
173 |     let js_fn : @js.Js = @js.unsafe_cast(trap)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     handler.set("defineProperty", js_fn)
    |   }
    |   proxy_class().call("revocable", [target.to_js(), handler.to_js()])
    | }
    …

1 uncovered line(s) in src/reflect/reflect.mbt:

    | pub fn construct(
    |   target : &@js.JsImpl,
    |   arguments_list : Array[@js.Js],
    |   new_target : @js.Js?,
    | ) -> @js.Js {
    |   match new_target {
    |     Some(nt) =>
 32 |       reflect_class().call("construct", [
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |         target.to_js(),
    |         @js.from_array(arguments_list),
    |         nt,
    |       ])
    |     None =>
    |       reflect_class().call("construct", [
    |         target.to_js(),
    |         @js.from_array(arguments_list),
    |       ])
    |   }
    | }
    …

14 uncovered line(s) in src/regexp/regexp.mbt:

    | pub fn RegExp::dotAll(self : RegExp) -> Bool {
248 |   RegExp::ffi_regexp_dot_all(self)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn RegExp::hasIndices(self : RegExp) -> Bool {
257 |   RegExp::ffi_regexp_has_indices(self)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn RegExp::exec(self : RegExp, s : String) -> RegExpResult? {
    |   let v = RegExp::ffi_regexp_exec(self, s)
    |   if is_null(v) {
304 |     return None
    |     ^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let full : String = unsafe_cast(v.get(0))
    |   let index : Int = unsafe_cast(v.get("index"))
    |   let last_index : Int = unsafe_cast(v.get("lastIndex"))
    |   let input : String = unsafe_cast(v.get("input"))
    |   let groups : Map[String, String]? = if is_undefined(v.get("groups")) {
    |     None
    |   } else {
    |     let g : Map[String, String] = {}
    |     let keys = @js.Object::keys(v.get("groups"))
    |     for k in keys {
    |       g[k] = unsafe_cast(v.get("groups").get(k))
    |     }
    |     Some(g)
    |   }
    |   { full, input, index, lastIndex: last_index, groups } |> Some
    | }
    …

    | pub fn RegExp::match_(self : RegExp, string : String) -> RegExpMatchArray? {
    |   let v = ffi_string_match(string, self)
    |   if is_null(v) {
344 |     return None
    |     ^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   let len : Int = unsafe_cast(v.get("length"))
    |   let matches : Array[String] = Array::new(capacity=len)
    |   for i = 0; i < len; i = i + 1 {
    |     matches.push(unsafe_cast(v.get(i)))
    |   }
    |   let index : Int? = if is_undefined(v.get("index")) {
352 |     None
    |     ^^^^ 	<-- UNCOVERED
    |   } else {
    |     Some(unsafe_cast(v.get("index")))
    |   }
    |   let input : String? = if is_undefined(v.get("input")) {
357 |     None
    |     ^^^^ 	<-- UNCOVERED
    |   } else {
    |     Some(unsafe_cast(v.get("input")))
    |   }
    |   let groups : Map[String, String]? = if is_undefined(v.get("groups")) {
    |     None
    |   } else {
364 |     let g : Map[String, String] = {}
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     let keys = @js.Object::keys(v.get("groups"))
    |     for k in keys {
367 |       g[k] = unsafe_cast(v.get("groups").get(k))
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |     Some(g)
    |   }
    |   Some({ matches, index, input, groups })
    | }
    …

    | pub fn RegExp::matchAll(
    |   self : RegExp,
    |   string : String,
    | ) -> Array[RegExpMatchArray] {
    |   let v = ffi_string_match_all(string, self)
    |   let len : Int = unsafe_cast(v.get("length"))
    |   let results : Array[RegExpMatchArray] = []
    |   for i = 0; i < len; i = i + 1 {
    |     let item = v.get(i)
    |     let match_len : Int = unsafe_cast(item.get("length"))
    |     let matches : Array[String] = Array::new(capacity=match_len)
    |     for j = 0; j < match_len; j = j + 1 {
    |       matches.push(unsafe_cast(item.get(j)))
    |     }
    |     let index : Int? = if is_undefined(item.get("index")) {
394 |       None
    |       ^^^^ 	<-- UNCOVERED
    |     } else {
    |       Some(unsafe_cast(item.get("index")))
    |     }
    |     let input : String? = if is_undefined(item.get("input")) {
399 |       None
    |       ^^^^ 	<-- UNCOVERED
    |     } else {
    |       Some(unsafe_cast(item.get("input")))
    |     }
    |     let groups : Map[String, String]? = if is_undefined(item.get("groups")) {
    |       None
    |     } else {
406 |       let g : Map[String, String] = {}
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       let keys = @js.Object::keys(item.get("groups"))
    |       for k in keys {
409 |         g[k] = unsafe_cast(item.get("groups").get(k))
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       }
    |       Some(g)
    |     }
    |     results.push({ matches, index, input, groups })
    |   }
    |   results
    | }
    …

    | pub fn RegExp::replace_fn(
    |   self : RegExp,
    |   string : String,
    |   replacer : (String, Array[String], Int, String) -> String,
    | ) -> String {
    |   let wrapper = fn(
    |     matched : String,
    |     groups_val : Js,
    |     offset : Int,
    |     input : String,
    |   ) -> String {
    |     let groups_len : Int = unsafe_cast(groups_val.get("length"))
    |     let groups : Array[String] = Array::new(capacity=groups_len)
    |     for i = 0; i < groups_len; i = i + 1 {
    |       let item = groups_val.get(i)
    |       if is_undefined(item) {
465 |         groups.push("")
    |         ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       } else {
    |         groups.push(unsafe_cast(item))
    |       }
    |     }
    |     replacer(matched, groups, offset, input)
    |   }
    |   ffi_string_replace_fn(string, self, @js.unsafe_js(wrapper))
    | }
    …

    | pub fn RegExp::replace_all_fn(
    |   self : RegExp,
    |   string : String,
    |   replacer : (String, Array[String], Int, String) -> String,
    | ) -> String {
    |   let wrapper = fn(
    |     matched : String,
    |     groups_val : Js,
    |     offset : Int,
    |     input : String,
    |   ) -> String {
    |     let groups_len : Int = unsafe_cast(groups_val.get("length"))
    |     let groups : Array[String] = Array::new(capacity=groups_len)
    |     for i = 0; i < groups_len; i = i + 1 {
    |       let item = groups_val.get(i)
    |       if is_undefined(item) {
496 |         groups.push("")
    |         ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |       } else {
    |         groups.push(unsafe_cast(item))
    |       }
    |     }
    |     replacer(matched, groups, offset, input)
    |   }
    |   ffi_string_replace_all_fn(string, self, @js.unsafe_js(wrapper))
    | }
    …

14 uncovered line(s) in src/stream/stream.mbt:

    | pub fn ReadableStream::cancel(self : Self, reason? : Js) -> Promise[Unit] {
 29 |   match reason {
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(r) => self.call("cancel", [r]) |> unsafe_cast
    |     None => self.call("cancel", []) |> unsafe_cast
    |   }
    | }
    …

    | #alias(pipe_to)
    | pub fn ReadableStream::pipeTo(
    |   self : Self,
    |   destination : WritableStream,
    |   options? : Js,
    | ) -> Promise[Unit] {
 50 |   match options {
    |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(opts) => self.call("pipeTo", [destination, opts]) |> unsafe_cast
    |     None => self.call("pipeTo", [destination]) |> unsafe_cast
    |   }
    | }
    …

    | #alias(pipe_through)
    | pub fn ReadableStream::pipeThrough(
    |   self : Self,
    |   transform : Js,
    |   options? : Js,
    | ) -> ReadableStream {
 64 |   match options {
    |   ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(opts) => self.call("pipeThrough", [transform, opts]) |> unsafe_cast
    |     None => self.call("pipeThrough", [transform]) |> unsafe_cast
    |   }
    | }
    …

    | pub fn ReadableStreamDefaultReader::read(self : Self) -> Promise[Js] {
 94 |   self.call("read", []) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn ReadableStreamDefaultReader::cancel(
    |   self : Self,
    |   reason? : Js,
    | ) -> Promise[Unit] {
110 |   match reason {
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(r) => self.call("cancel", [r]) |> unsafe_cast
    |     None => self.call("cancel", []) |> unsafe_cast
    |   }
    | }
    …

    | pub fn ReadableStreamDefaultReader::closed(self : Self) -> Promise[Unit] {
119 |   unsafe_cast(self.get("closed"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn WritableStream::abort(self : Self, reason? : Js) -> Promise[Unit] {
150 |   match reason {
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(r) => self.call("abort", [r]) |> unsafe_cast
    |     None => self.call("abort", []) |> unsafe_cast
    |   }
    | }
    …

    | pub fn WritableStream::close(self : Self) -> Promise[Unit] {
159 |   self.call("close", []) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn WritableStreamDefaultWriter::write(
    |   self : Self,
    |   chunk : Js,
    | ) -> Promise[Unit] {
183 |   self.call("write", [chunk]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn WritableStreamDefaultWriter::close(self : Self) -> Promise[Unit] {
189 |   self.call("close", []) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn WritableStreamDefaultWriter::abort(
    |   self : Self,
    |   reason? : Js,
    | ) -> Promise[Unit] {
198 |   match reason {
    |   ^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(r) => self.call("abort", [r]) |> unsafe_cast
    |     None => self.call("abort", []) |> unsafe_cast
    |   }
    | }
    …

    | pub fn WritableStreamDefaultWriter::closed(self : Self) -> Promise[Unit] {
214 |   unsafe_cast(self.get("closed"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn WritableStreamDefaultWriter::ready(self : Self) -> Promise[Unit] {
220 |   unsafe_cast(self.get("ready"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(desiredSize)
    | pub fn WritableStreamDefaultWriter::desired_size(self : Self) -> Int? {
227 |   self.get("desiredSize") |> @js.unsafe_cast_option
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

2 uncovered line(s) in src/url/search_params.mbt:

   | impl Eq for URLSearchParams with op_equal(self, other) {
10 |   self.to_js() == other.to_js()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | impl Show for URLSearchParams with output(self, logger) {
15 |   logger.write_string(self.to_string())
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

2 uncovered line(s) in src/url/url.mbt:

   | #alias(createObjectURL)
   | pub fn URL::create_object_url(obj : Js) -> String {
66 |   unsafe_cast(ffi_create_object_url(obj))
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | #alias(revokeObjectURL)
   | pub fn URL::revoke_object_url(url : String) -> Unit {
76 |   ffi_revoke_object_url(url) |> ignore
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

17 uncovered line(s) in src/url/url_pattern.mbt:

    | pub fn URLPattern::new(pattern : String, base? : String) -> URLPattern {
    |   let pattern_val = @js.unsafe_js(pattern)
    |   match base {
 35 |     Some(b) => unsafe_cast(ffi_new_url_pattern_with_base(pattern_val, b))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     None => unsafe_cast(ffi_new_url_pattern(pattern_val))
    |   }
    | }
    …

    | #alias(new_from_object)
    | pub fn URLPattern::newFromObject(
    |   pattern : @js.Js,
    |   base? : String,
    | ) -> URLPattern {
 47 |   match base {
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(b) => unsafe_cast(ffi_new_url_pattern_with_base(pattern, b))
    |     None => unsafe_cast(ffi_new_url_pattern(pattern))
    |   }
    | }
    …

    | pub fn URLPattern::username(self : Self) -> String {
 62 |   unsafe_cast(self.get("username"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn URLPattern::password(self : Self) -> String {
 68 |   unsafe_cast(self.get("password"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn URLPattern::search(self : Self) -> String {
 92 |   unsafe_cast(self.to_js().get("search"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn URLPattern::hash(self : Self) -> String {
 98 |   unsafe_cast(self.to_js().get("hash"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | #alias(has_regexp_groups)
    | pub fn URLPattern::hasRegExpGroups(self : Self) -> Bool {
105 |   unsafe_cast(self.to_js().get("hasRegExpGroups"))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn URLPattern::test_url_with_base(
    |   self : Self,
    |   input : String,
    |   base? : String,
    | ) -> Bool {
121 |   match base {
    |   ^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(b) => self.call("test", [input, b]) |> unsafe_cast
    |     None => self.call("test", [input]) |> unsafe_cast
    |   }
    | }
    …

    | #alias(exec_with_base)
    | pub fn URLPattern::execWithBase(
    |   self : Self,
    |   input : String,
    |   base? : String,
    | ) -> URLPatternResult? {
150 |   let result = match base {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(b) => self.call("exec", [input, b])
    |     None => self.call("exec", [input])
    |   }
    |   if ffi_is_null(result) {
155 |     None
    |     ^^^^ 	<-- UNCOVERED
    |   } else {
157 |     Some(unsafe_cast(result))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    | }
    …

    | pub fn URLPatternResult::inputs(self : Self) -> @js.Js {
164 |   self.to_js().get("inputs")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn URLPatternResult::protocol(self : Self) -> @js.Js {
179 |   get_component_result(self, "protocol")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn URLPatternResult::username(self : Self) -> @js.Js {
185 |   get_component_result(self, "username")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn URLPatternResult::password(self : Self) -> @js.Js {
191 |   get_component_result(self, "password")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn URLPatternResult::hostname(self : Self) -> @js.Js {
197 |   get_component_result(self, "hostname")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn URLPatternResult::port(self : Self) -> @js.Js {
203 |   get_component_result(self, "port")
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

4 uncovered line(s) in src/utils.mbt:

    | pub fn[T] throwable(f : () -> T raise?) -> T raise JsThrowError {
    |   match throwable_result(f |> unsafe_cast) {
113 |     Ok(result) => result |> unsafe_cast
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Err(e) => {
    |       if ffi_is_error(e) {
    |         raise JsThrowError::Error(unsafe_cast(e))
    |       }
118 |       raise JsThrowError::Value(e |> unsafe_cast)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     }
    |   }
    | }
    …

    | pub fn[T] log(v : T) -> Unit {
132 |   ffi_console_log([v |> unsafe_cast]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn[T, U] log2(a : T, b : U) -> Unit {
138 |   ffi_console_log([a |> unsafe_cast, b |> unsafe_cast]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

1 uncovered line(s) in src/weak.mbt:

    | pub fn[T : JsImpl] FinalizationRegistry::new(
    |   cleanup_callback : (T) -> Unit,
    | ) -> FinalizationRegistry[T] {
    |   unsafe_cast(
131 |     ffi_new_finalization_registry(fn(val) { cleanup_callback(unsafe_cast(val)) }),
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   )
    | }
    …

9 uncovered line(s) in src/webassembly/webassembly.mbt:

    | pub fn WebAssemblyMemory::new(
    |   descriptor : MemoryDescriptor,
    | ) -> WebAssemblyMemory {
    |   let obj = @js.Object::new()
    |   obj.set("initial", descriptor.initial)
    |   match descriptor.maximum {
    |     Some(max) => obj.set("maximum", max)
 68 |     None => ()
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   obj.set("shared", descriptor.shared)
    |   ffi_new_memory(obj.to_js())
    | }
    …

    | pub fn WebAssemblyTable::set(self : Self, index : Int, value : Js) -> Unit {
 91 |   ignore(self.call("set", [index, value]))
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn WebAssemblyTable::grow(self : Self, delta : Int, value : Js) -> Int {
 97 |   self.call("grow", [delta, value]) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn WebAssemblyTable::new(descriptor : TableDescriptor) -> WebAssemblyTable {
    |   let obj = @js.Object::new()
    |   obj.set("element", descriptor.element)
    |   obj.set("initial", descriptor.initial)
    |   match descriptor.maximum {
    |     Some(max) => obj.set("maximum", max)
120 |     None => ()
    |     ^^^^^^^^^^ 	<-- UNCOVERED
    |   }
    |   ffi_new_table(obj.to_js())
    | }
    …

    | pub fn instantiate_bytes(
    |   bytes : Uint8Array,
    |   import_object : Js?,
    | ) -> (WebAssemblyModule, WebAssemblyInstance) {
217 |   let imports = match import_object {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(obj) => obj
    |     None => @js.undefined()
    |   }
221 |   let result = ffi_instantiate(bytes.to_js(), imports)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let wasm_module : WebAssemblyModule = result.get("module") |> unsafe_cast
    |   let instance : WebAssemblyInstance = result.get("instance") |> unsafe_cast
    |   (wasm_module, instance)
    | }
    …

    | pub fn instantiate_module(
    |   wasm_module : WebAssemblyModule,
    |   import_object : Js?,
    | ) -> WebAssemblyInstance {
233 |   let imports = match import_object {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     Some(obj) => obj
    |     None => @js.undefined()
    |   }
237 |   ffi_instantiate(wasm_module.to_js(), imports) |> unsafe_cast
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn compile(bytes : Uint8Array) -> Js {
257 |   ffi_compile(bytes.to_js())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

5 uncovered line(s) in src/worker/message_port.mbt:

    | pub impl Show for MessagePort with output(self, logger) {
 17 |   logger.write_string(self.to_string())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub fn MessagePort::post_message_with_transfer(
    |   port : MessagePort,
    |   message : &JsImpl,
    |   transfer : Array[Js],
    | ) -> Unit {
 40 |   let arr = @js.JsArray::new()
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |   let mut i = 0
    |   while i < transfer.length() {
 43 |     arr.call("push", [transfer[i]]) |> ignore
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    |     i = i + 1
    |   }
 46 |   port.call("postMessage", [message.to_js(), arr.to_js()]) |> ignore
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

    | pub impl Show for MessageChannel with output(self, logger) {
 74 |   logger.write_string(self.to_string())
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
    | }
    …

8 uncovered line(s) in src/worker/worker.mbt:

   | pub fn Worker::new(script_url : String, type_? : String) -> Worker {
41 |   let option = if type_ is Some(v) {
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     @js.from_map({ "type": js(v) })
   |   } else {
44 |     @js.undefined()
   |     ^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   }
46 |   ffi_new_worker(script_url, option)
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Worker::terminate(worker : Worker) -> Unit {
51 |   worker.call("terminate", []) |> ignore
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | #alias(post_message)
   | pub fn Worker::postMessage(worker : Worker, message : &JsImpl) -> Unit {
65 |   ffi_worker_post_message(worker, message.to_js(), @js.undefined())
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

   | pub fn Worker::post_message_with_transfer(
   |   worker : Worker,
   |   message : &JsImpl,
   |   transfer : Array[Js],
   | ) -> Unit {
74 |   let arr = @js.JsArray::new()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |   let mut i = 0
   |   while i < transfer.length() {
77 |     arr.call("push", [transfer[i]]) |> ignore
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   |     i = i + 1
   |   }
80 |   ffi_worker_post_message(worker, message.to_js(), arr.to_js())
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	<-- UNCOVERED
   | }
   …

Total: 1485 uncovered line(s) in 89 file(s)
