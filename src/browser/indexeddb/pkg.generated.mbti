// Generated using `moon info`, DON'T EDIT IT
package "mizchi/js/browser/indexeddb"

import(
  "mizchi/js"
  "mizchi/js/web/event"
)

// Values
fn cmp(&@js.JsImpl, &@js.JsImpl) -> Int

fn deleteDatabase(String) -> IDBOpenDBRequest

fn indexedDB() -> @js.Js

fn open(String, version? : Int) -> IDBOpenDBRequest

// Errors

// Types and methods
pub(all) struct IDBCursor[T] {
  key : @js.Js
  primaryKey : @js.Js
  direction : String
  source : @js.Js
}
fn[T] IDBCursor::advance(Self[T], Int) -> Unit
fn[T] IDBCursor::continue_(Self[T], key? : &@js.JsImpl) -> Unit
fn[T] IDBCursor::delete_current(Self[T]) -> IDBRequest[@js.Js]
fn[T] IDBCursor::update(Self[T], T) -> IDBRequest[@js.Js]
impl[T] @js.JsImpl for IDBCursor[T]

pub(all) struct IDBCursorWithValue[T] {
  key : @js.Js
  primaryKey : @js.Js
  direction : String
  source : @js.Js
  value : T
}
fn[T] IDBCursorWithValue::advance(Self[T], Int) -> Unit
fn[T] IDBCursorWithValue::continue_(Self[T], key? : &@js.JsImpl) -> Unit
fn[T] IDBCursorWithValue::delete_current(Self[T]) -> IDBRequest[@js.Js]
fn[T] IDBCursorWithValue::update(Self[T], T) -> IDBRequest[@js.Js]
impl[T] @js.JsImpl for IDBCursorWithValue[T]

pub(all) struct IDBDatabase {
  name : String
  version : Int
  objectStoreNames : @js.Js
}
fn IDBDatabase::close(Self) -> Unit
fn IDBDatabase::createObjectStore(Self, String, keyPath? : String, autoIncrement? : Bool) -> IDBObjectStore[@js.Js]
fn IDBDatabase::deleteObjectStore(Self, String) -> Unit
fn IDBDatabase::transaction(Self, Array[String], mode? : String) -> IDBTransaction[@js.Js]
impl @js.JsImpl for IDBDatabase

pub(all) struct IDBIndex[T] {
  name : String
  objectStore : IDBObjectStore[T]
  keyPath : @js.Js
  multiEntry : Bool
  unique : Bool
}
fn[T] IDBIndex::count(Self[T], query? : &@js.JsImpl) -> IDBRequest[@js.Js]
fn[T] IDBIndex::get(Self[T], &@js.JsImpl) -> IDBRequest[T]
fn[T] IDBIndex::getAll(Self[T], query? : &@js.JsImpl, count? : Int) -> IDBRequest[@js.Js]
fn[T] IDBIndex::getAllKeys(Self[T], query? : &@js.JsImpl, count? : Int) -> IDBRequest[@js.Js]
fn[T] IDBIndex::openCursor(Self[T], query? : &@js.JsImpl, direction? : String) -> IDBRequest[@js.Js]
fn[T] IDBIndex::openKeyCursor(Self[T], query? : &@js.JsImpl, direction? : String) -> IDBRequest[@js.Js]
impl[T] @js.JsImpl for IDBIndex[T]

pub(all) struct IDBKeyRange {
  lower : @js.Js
  upper : @js.Js
  lowerOpen : Bool
  upperOpen : Bool
}
fn IDBKeyRange::bound(&@js.JsImpl, &@js.JsImpl, lowerOpen? : Bool, upperOpen? : Bool) -> Self
fn IDBKeyRange::includes(Self, &@js.JsImpl) -> Bool
fn IDBKeyRange::lowerBound(&@js.JsImpl, open? : Bool) -> Self
fn IDBKeyRange::only(&@js.JsImpl) -> Self
fn IDBKeyRange::upperBound(&@js.JsImpl, open? : Bool) -> Self
impl @js.JsImpl for IDBKeyRange

pub(all) struct IDBObjectStore[T] {
  name : String
  keyPath : @js.Js
  autoIncrement : Bool
  indexNames : @js.Js
  transaction : IDBTransaction[T]
}
fn[T] IDBObjectStore::add(Self[T], T, key? : &@js.JsImpl) -> IDBRequest[@js.Js]
fn[T] IDBObjectStore::clear(Self[T]) -> IDBRequest[@js.Js]
fn[T] IDBObjectStore::count(Self[T], query? : &@js.JsImpl) -> IDBRequest[@js.Js]
fn[T] IDBObjectStore::createIndex(Self[T], String, String, unique? : Bool, multiEntry? : Bool) -> IDBIndex[T]
fn[T] IDBObjectStore::delete(Self[T], &@js.JsImpl) -> IDBRequest[@js.Js]
fn[T] IDBObjectStore::deleteIndex(Self[T], String) -> Unit
fn[T] IDBObjectStore::get(Self[T], &@js.JsImpl) -> IDBRequest[T]
fn[T] IDBObjectStore::getAll(Self[T], query? : &@js.JsImpl, count? : Int) -> IDBRequest[@js.Js]
fn[T] IDBObjectStore::getAllKeys(Self[T], query? : &@js.JsImpl, count? : Int) -> IDBRequest[@js.Js]
fn[T] IDBObjectStore::index(Self[T], String) -> IDBIndex[T]
fn[T] IDBObjectStore::openCursor(Self[T], query? : &@js.JsImpl, direction? : String) -> IDBRequest[@js.Js]
fn[T] IDBObjectStore::openKeyCursor(Self[T], query? : &@js.JsImpl, direction? : String) -> IDBRequest[@js.Js]
fn[T] IDBObjectStore::put(Self[T], T, key? : &@js.JsImpl) -> IDBRequest[@js.Js]
impl[T] @js.JsImpl for IDBObjectStore[T]

pub(all) struct IDBOpenDBRequest {
  result : @js.Js
  error : @js.Nullable[@js.Js]
  source : @js.Js
  readyState : String
}
impl @js.JsImpl for IDBOpenDBRequest
impl @event.EventTargetImpl for IDBOpenDBRequest

pub(all) struct IDBRequest[T] {
  result : T
  error : @js.Nullable[@js.Js]
  source : @js.Js
  readyState : String
}
fn[T] IDBRequest::is_done(Self[T]) -> Bool
fn[T] IDBRequest::is_pending(Self[T]) -> Bool
fn[T, U] IDBRequest::source_as_cursor(Self[T]) -> IDBCursor[U]
fn[T] IDBRequest::source_as_index(Self[T]) -> IDBIndex[@js.Js]
fn[T] IDBRequest::source_as_object_store(Self[T]) -> IDBObjectStore[@js.Js]
impl[T] @js.JsImpl for IDBRequest[T]
impl[T] @event.EventTargetImpl for IDBRequest[T]

pub(all) struct IDBTransaction[T] {
  db : IDBDatabase
  mode : String
  objectStoreNames : @js.Js
}
fn[T] IDBTransaction::abort(Self[T]) -> Unit
fn[T] IDBTransaction::commit(Self[T]) -> Unit
fn[T] IDBTransaction::objectStore(Self[T], String) -> IDBObjectStore[T]
impl[T] @js.JsImpl for IDBTransaction[T]

// Type aliases

// Traits

