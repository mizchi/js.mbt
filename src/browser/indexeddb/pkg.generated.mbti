// Generated using `moon info`, DON'T EDIT IT
package "mizchi/js/browser/indexeddb"

import {
  "mizchi/js/core",
  "mizchi/js/web/event",
}

// Values
pub fn cmp(@core.Any, @core.Any) -> Int

pub fn deleteDatabase(String) -> IDBOpenDBRequest

pub fn indexedDB() -> @core.Any

pub fn open(String, version? : Int) -> IDBOpenDBRequest

// Errors

// Types and methods
pub(all) struct IDBCursor[T] {
  key : @core.Any
  primaryKey : @core.Any
  direction : String
  source : @core.Any
}
pub fn[T] IDBCursor::advance(Self[T], Int) -> Unit
pub fn[T] IDBCursor::as_any(Self[T]) -> @core.Any
pub fn[T] IDBCursor::continue_(Self[T], key? : @core.Any) -> Unit
pub fn[T] IDBCursor::delete_current(Self[T]) -> IDBRequest[@core.Any]
pub fn[T] IDBCursor::update(Self[T], T) -> IDBRequest[@core.Any]

pub(all) struct IDBCursorWithValue[T] {
  key : @core.Any
  primaryKey : @core.Any
  direction : String
  source : @core.Any
  value : T
}
pub fn[T] IDBCursorWithValue::advance(Self[T], Int) -> Unit
pub fn[T] IDBCursorWithValue::as_any(Self[T]) -> @core.Any
pub fn[T] IDBCursorWithValue::continue_(Self[T], key? : @core.Any) -> Unit
pub fn[T] IDBCursorWithValue::delete_current(Self[T]) -> IDBRequest[@core.Any]
pub fn[T] IDBCursorWithValue::update(Self[T], T) -> IDBRequest[@core.Any]

pub(all) struct IDBDatabase {
  name : String
  version : Int
  objectStoreNames : @core.Any
}
pub fn IDBDatabase::as_any(Self) -> @core.Any
pub fn IDBDatabase::close(Self) -> Unit
pub fn IDBDatabase::createObjectStore(Self, String, keyPath? : String, autoIncrement? : Bool) -> IDBObjectStore[@core.Any]
pub fn IDBDatabase::deleteObjectStore(Self, String) -> Unit
pub fn IDBDatabase::transaction(Self, Array[String], mode? : String) -> IDBTransaction[@core.Any]

pub(all) struct IDBIndex[T] {
  name : String
  objectStore : IDBObjectStore[T]
  keyPath : @core.Any
  multiEntry : Bool
  unique : Bool
}
pub fn[T] IDBIndex::as_any(Self[T]) -> @core.Any
pub fn[T] IDBIndex::count(Self[T], query? : @core.Any) -> IDBRequest[@core.Any]
pub fn[T] IDBIndex::get(Self[T], @core.Any) -> IDBRequest[T]
pub fn[T] IDBIndex::getAll(Self[T], query? : @core.Any, count? : Int) -> IDBRequest[@core.Any]
pub fn[T] IDBIndex::getAllKeys(Self[T], query? : @core.Any, count? : Int) -> IDBRequest[@core.Any]
pub fn[T] IDBIndex::openCursor(Self[T], query? : @core.Any, direction? : String) -> IDBRequest[@core.Any]
pub fn[T] IDBIndex::openKeyCursor(Self[T], query? : @core.Any, direction? : String) -> IDBRequest[@core.Any]

pub(all) struct IDBKeyRange {
  lower : @core.Any
  upper : @core.Any
  lowerOpen : Bool
  upperOpen : Bool
}
pub fn IDBKeyRange::as_any(Self) -> @core.Any
pub fn IDBKeyRange::bound(@core.Any, @core.Any, lowerOpen? : Bool, upperOpen? : Bool) -> Self
pub fn IDBKeyRange::includes(Self, @core.Any) -> Bool
pub fn IDBKeyRange::lowerBound(@core.Any, open? : Bool) -> Self
pub fn IDBKeyRange::only(@core.Any) -> Self
pub fn IDBKeyRange::upperBound(@core.Any, open? : Bool) -> Self

pub(all) struct IDBObjectStore[T] {
  name : String
  keyPath : @core.Any
  autoIncrement : Bool
  indexNames : @core.Any
  transaction : IDBTransaction[T]
}
pub fn[T] IDBObjectStore::add(Self[T], T, key? : @core.Any) -> IDBRequest[@core.Any]
pub fn[T] IDBObjectStore::as_any(Self[T]) -> @core.Any
pub fn[T] IDBObjectStore::clear(Self[T]) -> IDBRequest[@core.Any]
pub fn[T] IDBObjectStore::count(Self[T], query? : @core.Any) -> IDBRequest[@core.Any]
pub fn[T] IDBObjectStore::createIndex(Self[T], String, String, unique? : Bool, multiEntry? : Bool) -> IDBIndex[T]
pub fn[T] IDBObjectStore::delete(Self[T], @core.Any) -> IDBRequest[@core.Any]
pub fn[T] IDBObjectStore::deleteIndex(Self[T], String) -> Unit
pub fn[T] IDBObjectStore::get(Self[T], @core.Any) -> IDBRequest[T]
pub fn[T] IDBObjectStore::getAll(Self[T], query? : @core.Any, count? : Int) -> IDBRequest[@core.Any]
pub fn[T] IDBObjectStore::getAllKeys(Self[T], query? : @core.Any, count? : Int) -> IDBRequest[@core.Any]
pub fn[T] IDBObjectStore::index(Self[T], String) -> IDBIndex[T]
pub fn[T] IDBObjectStore::openCursor(Self[T], query? : @core.Any, direction? : String) -> IDBRequest[@core.Any]
pub fn[T] IDBObjectStore::openKeyCursor(Self[T], query? : @core.Any, direction? : String) -> IDBRequest[@core.Any]
pub fn[T] IDBObjectStore::put(Self[T], T, key? : @core.Any) -> IDBRequest[@core.Any]

pub(all) struct IDBOpenDBRequest {
  result : @core.Any
  error : @core.Nullable[@core.Any]
  source : @core.Any
  readyState : String
}
pub fn IDBOpenDBRequest::as_any(Self) -> @core.Any
pub fn IDBOpenDBRequest::as_event_target(Self) -> @event.EventTarget

pub(all) struct IDBRequest[T] {
  result : T
  error : @core.Nullable[@core.Any]
  source : @core.Any
  readyState : String
}
pub fn[T] IDBRequest::as_any(Self[T]) -> @core.Any
pub fn[T] IDBRequest::as_event_target(Self[T]) -> @event.EventTarget
pub fn[T] IDBRequest::is_done(Self[T]) -> Bool
pub fn[T] IDBRequest::is_pending(Self[T]) -> Bool
pub fn[T, U] IDBRequest::source_as_cursor(Self[T]) -> IDBCursor[U]
pub fn[T] IDBRequest::source_as_index(Self[T]) -> IDBIndex[@core.Any]
pub fn[T] IDBRequest::source_as_object_store(Self[T]) -> IDBObjectStore[@core.Any]

pub(all) struct IDBTransaction[T] {
  db : IDBDatabase
  mode : String
  objectStoreNames : @core.Any
}
pub fn[T] IDBTransaction::abort(Self[T]) -> Unit
pub fn[T] IDBTransaction::as_any(Self[T]) -> @core.Any
pub fn[T] IDBTransaction::commit(Self[T]) -> Unit
pub fn[T] IDBTransaction::objectStore(Self[T], String) -> IDBObjectStore[T]

// Type aliases

// Traits

