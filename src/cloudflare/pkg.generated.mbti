// Generated using `moon info`, DON'T EDIT IT
package "mizchi/js/cloudflare"

import(
  "mizchi/js"
  "mizchi/js/builtins/date"
  "mizchi/js/web/blob"
  "mizchi/js/web/http"
  "mizchi/js/web/streams"
)

// Values

// Errors

// Types and methods
#external
pub type CloudflareContext
#alias(passThroughException)
fn CloudflareContext::pass_through_exception(Self) -> Unit
#alias(waitUntil)
fn CloudflareContext::wait_until(Self, @js.Promise[Unit]) -> Unit

#external
pub type CloudflareEnv
impl @js.JsImpl for CloudflareEnv

pub(all) struct CloudflareRequest {
  cf : CloudflareContext
  url : String
}
impl @js.JsImpl for CloudflareRequest

#external
pub type D1Database
fn D1Database::batch(Self, Array[D1PreparedStatement]) -> @js.Promise[Array[D1Result]]
fn D1Database::dump(Self) -> @js.Promise[@js.Any]
fn D1Database::exec(Self, String) -> @js.Promise[D1ExecResult]
fn D1Database::prepare(Self, String) -> D1PreparedStatement
impl @js.JsImpl for D1Database

pub(all) struct D1ExecResult {
  count : Int
  duration : Double
}
impl @js.JsImpl for D1ExecResult

pub(all) struct D1Meta {
  duration : Double?
  rows_read : Int?
  rows_written : Int?
  last_row_id : Int?
  changed_db : Bool?
  changes : Int?
  size_after : Int?
}
impl @js.JsImpl for D1Meta

#external
pub type D1PreparedStatement
fn D1PreparedStatement::all(Self) -> @js.Promise[D1Result]
fn D1PreparedStatement::bind(Self, Array[@js.Any]) -> Self
fn D1PreparedStatement::bind1(Self, @js.Any) -> Self
fn D1PreparedStatement::bind2(Self, @js.Any, @js.Any) -> Self
fn D1PreparedStatement::bind3(Self, @js.Any, @js.Any, @js.Any) -> Self
fn D1PreparedStatement::first(Self) -> @js.Promise[@js.Any?]
fn D1PreparedStatement::first_col(Self, String) -> @js.Promise[@js.Any?]
fn D1PreparedStatement::raw(Self) -> @js.Promise[Array[@js.Any]]
fn D1PreparedStatement::raw_with_options(Self, D1RawOptions) -> @js.Promise[Array[@js.Any]]
fn D1PreparedStatement::run(Self) -> @js.Promise[D1Result]
impl @js.JsImpl for D1PreparedStatement

pub(all) struct D1RawOptions {
  columnNames : Bool?
}
impl @js.JsImpl for D1RawOptions

#alias(D1ResultSet)
pub(all) struct D1Result {
  results : Array[@js.Any]?
  success : Bool
  meta : D1Meta?
  error : String?
}
fn D1Result::get_results(Self) -> Array[@js.Any]
impl @js.JsImpl for D1Result

pub(all) struct DurableObjectGetAlarmOptions {
  allowConcurrency : Bool?
}
impl @js.JsImpl for DurableObjectGetAlarmOptions

pub(all) struct DurableObjectGetOptions {
  allowConcurrency : Bool?
  noCache : Bool?
}
impl @js.JsImpl for DurableObjectGetOptions

pub(all) struct DurableObjectId {
  name : String?
}
fn DurableObjectId::equals(Self, Self) -> Bool
fn DurableObjectId::to_string(Self) -> String
impl @js.JsImpl for DurableObjectId

pub(all) struct DurableObjectIdOptions {
  jurisdiction : String?
}
impl @js.JsImpl for DurableObjectIdOptions

pub(all) struct DurableObjectListOptions {
  start : String?
  startAfter : String?
  end : String?
  prefix : String?
  reverse : Bool?
  limit : Int?
  allowConcurrency : Bool?
  noCache : Bool?
}
impl @js.JsImpl for DurableObjectListOptions

#external
pub type DurableObjectNamespace
fn DurableObjectNamespace::get(Self, DurableObjectId) -> DurableObjectStub
fn DurableObjectNamespace::get_by_id_string(Self, String) -> DurableObjectStub
fn DurableObjectNamespace::get_by_name(Self, String) -> DurableObjectStub
fn DurableObjectNamespace::id_from_name(Self, String) -> DurableObjectId
fn DurableObjectNamespace::id_from_string(Self, String) -> DurableObjectId
fn DurableObjectNamespace::new_unique_id(Self) -> DurableObjectId
fn DurableObjectNamespace::new_unique_id_with_options(Self, DurableObjectIdOptions) -> DurableObjectId
impl @js.JsImpl for DurableObjectNamespace

pub(all) struct DurableObjectPutOptions {
  allowConcurrency : Bool?
  allowUnconfirmed : Bool?
  noCache : Bool?
}
impl @js.JsImpl for DurableObjectPutOptions

pub(all) struct DurableObjectSetAlarmOptions {
  allowConcurrency : Bool?
  allowUnconfirmed : Bool?
}
impl @js.JsImpl for DurableObjectSetAlarmOptions

pub(all) struct DurableObjectState {
  id : DurableObjectId
  storage : DurableObjectStorage
}
fn DurableObjectState::block_concurrency_while(Self, @js.Any) -> @js.Promise[Unit]
fn DurableObjectState::wait_until(Self, @js.Any) -> Unit
impl @js.JsImpl for DurableObjectState

#external
pub type DurableObjectStorage
fn DurableObjectStorage::delete(Self, String) -> @js.Promise[Bool]
fn DurableObjectStorage::delete_alarm(Self) -> @js.Promise[Unit]
fn DurableObjectStorage::delete_alarm_with_options(Self, DurableObjectSetAlarmOptions) -> @js.Promise[Unit]
fn DurableObjectStorage::delete_all(Self) -> @js.Promise[Unit]
fn DurableObjectStorage::delete_all_with_options(Self, DurableObjectPutOptions) -> @js.Promise[Unit]
fn DurableObjectStorage::delete_multiple(Self, Array[String]) -> @js.Promise[Int]
fn DurableObjectStorage::delete_multiple_with_options(Self, Array[String], DurableObjectPutOptions) -> @js.Promise[Int]
fn DurableObjectStorage::delete_with_options(Self, String, DurableObjectPutOptions) -> @js.Promise[Bool]
fn DurableObjectStorage::get(Self, String) -> @js.Promise[@js.Any?]
fn DurableObjectStorage::get_alarm(Self) -> @js.Promise[Int?]
fn DurableObjectStorage::get_alarm_with_options(Self, DurableObjectGetAlarmOptions) -> @js.Promise[Int?]
fn DurableObjectStorage::get_multiple(Self, Array[String]) -> @js.Promise[@js.Any]
fn DurableObjectStorage::get_multiple_with_options(Self, Array[String], DurableObjectGetOptions) -> @js.Promise[@js.Any]
fn DurableObjectStorage::get_with_options(Self, String, DurableObjectGetOptions) -> @js.Promise[@js.Any?]
fn DurableObjectStorage::list(Self) -> @js.Promise[@js.Any]
fn DurableObjectStorage::list_with_options(Self, DurableObjectListOptions) -> @js.Promise[@js.Any]
fn DurableObjectStorage::put(Self, String, @js.Any) -> @js.Promise[Unit]
fn DurableObjectStorage::put_multiple(Self, @js.Any) -> @js.Promise[Unit]
fn DurableObjectStorage::put_multiple_with_options(Self, @js.Any, DurableObjectPutOptions) -> @js.Promise[Unit]
fn DurableObjectStorage::put_with_options(Self, String, @js.Any, DurableObjectPutOptions) -> @js.Promise[Unit]
fn DurableObjectStorage::set_alarm(Self, Int) -> @js.Promise[Unit]
fn DurableObjectStorage::set_alarm_with_options(Self, Int, DurableObjectSetAlarmOptions) -> @js.Promise[Unit]
fn DurableObjectStorage::sync(Self) -> @js.Promise[Unit]
fn DurableObjectStorage::transaction(Self, @js.Any) -> @js.Promise[@js.Any]
impl @js.JsImpl for DurableObjectStorage

pub(all) struct DurableObjectStub {
  id : DurableObjectId
  name : String?
}
fn DurableObjectStub::fetch(Self, @js.Any) -> @js.Promise[@js.Any]
fn DurableObjectStub::fetch_url(Self, String) -> @js.Promise[@js.Any]
fn DurableObjectStub::fetch_url_with_init(Self, String, @js.Any) -> @js.Promise[@js.Any]
fn DurableObjectStub::fetch_with_init(Self, @js.Any, @js.Any) -> @js.Promise[@js.Any]
impl @js.JsImpl for DurableObjectStub

#external
pub type DurableObjectTransaction
fn DurableObjectTransaction::delete(Self, String) -> @js.Promise[Bool]
fn DurableObjectTransaction::delete_alarm(Self) -> @js.Promise[Unit]
fn DurableObjectTransaction::delete_all(Self) -> @js.Promise[Unit]
fn DurableObjectTransaction::delete_multiple(Self, Array[String]) -> @js.Promise[Int]
fn DurableObjectTransaction::get(Self, String) -> @js.Promise[@js.Any?]
fn DurableObjectTransaction::get_alarm(Self) -> @js.Promise[Int?]
fn DurableObjectTransaction::get_multiple(Self, Array[String]) -> @js.Promise[@js.Any]
fn DurableObjectTransaction::list(Self) -> @js.Promise[@js.Any]
fn DurableObjectTransaction::list_with_options(Self, DurableObjectListOptions) -> @js.Promise[@js.Any]
fn DurableObjectTransaction::put(Self, String, @js.Any) -> @js.Promise[Unit]
fn DurableObjectTransaction::put_multiple(Self, @js.Any) -> @js.Promise[Unit]
fn DurableObjectTransaction::rollback(Self) -> Unit
fn DurableObjectTransaction::set_alarm(Self, Int) -> @js.Promise[Unit]
impl @js.JsImpl for DurableObjectTransaction

pub(all) struct KVKey {
  name : String
  expiration : Int?
  metadata : @js.Any?
}
impl @js.JsImpl for KVKey

pub(all) struct KVListResult {
  keys : Array[KVKey]
  list_complete : Bool
  cursor : String?
}
impl @js.JsImpl for KVListResult

#external
pub type KVNamespace
fn KVNamespace::delete(Self, String) -> @js.Promise[Unit]
fn KVNamespace::get(Self, String, type_? : String, cacheTtl? : Int) -> @js.Promise[String?]
fn KVNamespace::get_array_buffer(Self, String) -> @js.Promise[@js.Any?]
fn KVNamespace::get_json(Self, String) -> @js.Promise[@js.Any?]
fn KVNamespace::get_stream(Self, String) -> @js.Promise[@js.Any?]
fn KVNamespace::get_with_metadata(Self, String, type_? : String, cacheTtl? : Int) -> @js.Promise[KVValueWithMetadata]
fn KVNamespace::list(Self, prefix? : String, limit? : Int, cursor? : String) -> @js.Promise[KVListResult]
fn KVNamespace::put(Self, String, String, expiration? : Int, expirationTtl? : Int, metadata? : @js.Any) -> @js.Promise[Unit]
fn KVNamespace::put_with_metadata(Self, String, String, @js.Any) -> @js.Promise[Unit]
impl @js.JsImpl for KVNamespace

pub(all) struct KVValueWithMetadata {
  value : @js.Any?
  metadata : @js.Any?
}
impl @js.JsImpl for KVValueWithMetadata

#external
pub type R2Bucket
fn R2Bucket::create_multipart_upload(Self, String, httpMetadata? : R2HttpMetadata, customMetadata? : @js.Any, md5? : String, sha1? : String, sha256? : String, sha384? : String, sha512? : String) -> @js.Promise[R2MultipartUpload]
fn R2Bucket::delete(Self, String) -> @js.Promise[Unit]
fn R2Bucket::delete_multiple(Self, Array[String]) -> @js.Promise[Unit]
fn R2Bucket::get(Self, String, onlyIf? : R2Conditional, range? : R2Range) -> @js.Promise[R2Object?]
fn R2Bucket::head(Self, String) -> @js.Promise[R2Object?]
fn R2Bucket::list(Self, limit? : Int, prefix? : String, cursor? : String, delimiter? : String, startAfter? : String, include_? : Array[String]) -> @js.Promise[R2Objects]
fn R2Bucket::put(Self, String, @js.Any, httpMetadata? : R2HttpMetadata, customMetadata? : @js.Any, md5? : String, sha1? : String, sha256? : String, sha384? : String, sha512? : String) -> @js.Promise[R2Object]
fn R2Bucket::resume_multipart_upload(Self, String, String) -> R2MultipartUpload
impl @js.JsImpl for R2Bucket

pub(all) struct R2Conditional {
  etagMatches : String?
  etagDoesNotMatch : String?
  uploadedBefore : @date.Date?
  uploadedAfter : @date.Date?
}

pub(all) struct R2HttpMetadata {
  contentType : String?
  contentLanguage : String?
  contentDisposition : String?
  contentEncoding : String?
  cacheControl : String?
  cacheExpiry : @date.Date?
}
impl @js.JsImpl for R2HttpMetadata

#external
pub type R2MultipartUpload
fn R2MultipartUpload::abort(Self) -> @js.Promise[Unit]
fn R2MultipartUpload::complete(Self, Array[R2UploadedPart]) -> @js.Promise[R2Object]
fn R2MultipartUpload::key(Self) -> String
fn R2MultipartUpload::uploadId(Self) -> String
fn R2MultipartUpload::upload_part(Self, Int, @js.Any) -> @js.Promise[R2UploadedPart]
impl @js.JsImpl for R2MultipartUpload

#external
pub type R2Object
fn R2Object::array_buffer(Self) -> @js.Promise[@js.ArrayBuffer]
fn R2Object::blob(Self) -> @js.Promise[@blob.Blob]
fn R2Object::body(Self) -> @streams.ReadableStream
fn R2Object::body_used(Self) -> Bool
fn R2Object::custom_metadata(Self) -> @js.Any
fn R2Object::etag(Self) -> String
fn R2Object::http_metadata(Self) -> @js.Any
fn R2Object::json(Self) -> @js.Promise[@js.Any]
fn R2Object::key(Self) -> String
fn R2Object::size(Self) -> Int
fn R2Object::text(Self) -> @js.Promise[String]
fn R2Object::uploaded(Self) -> @js.Any
fn R2Object::version(Self) -> String
fn R2Object::write_http_metadata(Self, @js.Any) -> Unit
impl @js.JsImpl for R2Object

pub(all) struct R2Objects {
  objects : Array[R2Object]
  truncated : Bool
  cursor : String?
  delimitedPrefixes : Array[String]
}
impl @js.JsImpl for R2Objects

pub(all) struct R2Range {
  offset : Int?
  length : Int?
  suffix : Int?
}

pub(all) struct R2UploadedPart {
  partNumber : Int
  etag : String
}
impl @js.JsImpl for R2UploadedPart

// Type aliases
pub type CloudflareFetchHandler = (CloudflareRequest, CloudflareEnv, CloudflareContext) -> @js.Promise[@http.Response]

// Traits

