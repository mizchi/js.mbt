// Generated using `moon info`, DON'T EDIT IT
package "mizchi/js/cloudflare"

import(
  "mizchi/js"
  "mizchi/js/arraybuffer"
  "mizchi/js/browser/blob"
  "mizchi/js/web/http"
  "mizchi/js/web/stream"
)

// Values

// Errors

// Types and methods
#external
pub type CloudflareContext
#alias(passThroughException)
fn CloudflareContext::pass_through_exception(Self) -> Unit
#alias(waitUntil)
fn CloudflareContext::wait_until(Self, @js.Promise[Unit]) -> Unit

#external
pub type CloudflareEnv

#external
pub type CloudflareRequest
fn CloudflareRequest::cf(Self) -> CloudflareContext
fn CloudflareRequest::url(Self) -> String
impl @js.JsImpl for CloudflareRequest

#external
pub type D1Database
fn D1Database::batch(Self, Array[D1PreparedStatement]) -> @js.Promise[Array[D1Result]]
fn D1Database::dump(Self) -> @js.Promise[@js.Js]
fn D1Database::exec(Self, String) -> @js.Promise[D1ExecResult]
fn D1Database::prepare(Self, String) -> D1PreparedStatement
impl @js.JsImpl for D1Database

pub(all) struct D1ExecResult {
  count : Int
  duration : Double
}
impl @js.JsImpl for D1ExecResult

pub(all) struct D1Meta {
  duration : Double?
  rows_read : Int?
  rows_written : Int?
  last_row_id : Int?
  changed_db : Bool?
  changes : Int?
  size_after : Int?
}
impl @js.JsImpl for D1Meta

#external
pub type D1PreparedStatement
fn D1PreparedStatement::all(Self) -> @js.Promise[D1Result]
fn D1PreparedStatement::bind(Self, Array[@js.Js]) -> Self
fn D1PreparedStatement::bind1(Self, @js.Js) -> Self
fn D1PreparedStatement::bind2(Self, @js.Js, @js.Js) -> Self
fn D1PreparedStatement::bind3(Self, @js.Js, @js.Js, @js.Js) -> Self
fn D1PreparedStatement::first(Self) -> @js.Promise[@js.Js?]
fn D1PreparedStatement::first_col(Self, String) -> @js.Promise[@js.Js?]
fn D1PreparedStatement::raw(Self) -> @js.Promise[Array[@js.Js]]
fn D1PreparedStatement::raw_with_options(Self, D1RawOptions) -> @js.Promise[Array[@js.Js]]
fn D1PreparedStatement::run(Self) -> @js.Promise[D1Result]
impl @js.JsImpl for D1PreparedStatement

pub(all) struct D1RawOptions {
  columnNames : Bool?
}
impl @js.JsImpl for D1RawOptions

#alias(D1ResultSet)
pub(all) struct D1Result {
  results : Array[@js.Js]?
  success : Bool
  meta : D1Meta?
  error : String?
}
fn D1Result::get_results(Self) -> Array[@js.Js]
impl @js.JsImpl for D1Result

pub(all) struct DurableObjectGetAlarmOptions {
  allowConcurrency : Bool?
}
impl @js.JsImpl for DurableObjectGetAlarmOptions

pub(all) struct DurableObjectGetOptions {
  allowConcurrency : Bool?
  noCache : Bool?
}
impl @js.JsImpl for DurableObjectGetOptions

#external
pub type DurableObjectId
fn DurableObjectId::equals(Self, Self) -> Bool
fn DurableObjectId::name(Self) -> String?
fn DurableObjectId::to_string(Self) -> String
impl @js.JsImpl for DurableObjectId

pub(all) struct DurableObjectIdOptions {
  jurisdiction : String?
}
impl @js.JsImpl for DurableObjectIdOptions

pub(all) struct DurableObjectListOptions {
  start : String?
  startAfter : String?
  end : String?
  prefix : String?
  reverse : Bool?
  limit : Int?
  allowConcurrency : Bool?
  noCache : Bool?
}
impl @js.JsImpl for DurableObjectListOptions

#external
pub type DurableObjectNamespace
fn DurableObjectNamespace::get(Self, DurableObjectId) -> DurableObjectStub
fn DurableObjectNamespace::get_by_id_string(Self, String) -> DurableObjectStub
fn DurableObjectNamespace::get_by_name(Self, String) -> DurableObjectStub
fn DurableObjectNamespace::id_from_name(Self, String) -> DurableObjectId
fn DurableObjectNamespace::id_from_string(Self, String) -> DurableObjectId
fn DurableObjectNamespace::new_unique_id(Self) -> DurableObjectId
fn DurableObjectNamespace::new_unique_id_with_options(Self, DurableObjectIdOptions) -> DurableObjectId
impl @js.JsImpl for DurableObjectNamespace

pub(all) struct DurableObjectPutOptions {
  allowConcurrency : Bool?
  allowUnconfirmed : Bool?
  noCache : Bool?
}
impl @js.JsImpl for DurableObjectPutOptions

pub(all) struct DurableObjectSetAlarmOptions {
  allowConcurrency : Bool?
  allowUnconfirmed : Bool?
}
impl @js.JsImpl for DurableObjectSetAlarmOptions

#external
pub type DurableObjectState
fn DurableObjectState::block_concurrency_while(Self, @js.Js) -> @js.Promise[Unit]
fn DurableObjectState::id(Self) -> DurableObjectId
fn DurableObjectState::storage(Self) -> DurableObjectStorage
fn DurableObjectState::wait_until(Self, @js.Js) -> Unit
impl @js.JsImpl for DurableObjectState

#external
pub type DurableObjectStorage
fn DurableObjectStorage::delete(Self, String) -> @js.Promise[Bool]
fn DurableObjectStorage::delete_alarm(Self) -> @js.Promise[Unit]
fn DurableObjectStorage::delete_alarm_with_options(Self, DurableObjectSetAlarmOptions) -> @js.Promise[Unit]
fn DurableObjectStorage::delete_all(Self) -> @js.Promise[Unit]
fn DurableObjectStorage::delete_all_with_options(Self, DurableObjectPutOptions) -> @js.Promise[Unit]
fn DurableObjectStorage::delete_multiple(Self, Array[String]) -> @js.Promise[Int]
fn DurableObjectStorage::delete_multiple_with_options(Self, Array[String], DurableObjectPutOptions) -> @js.Promise[Int]
fn DurableObjectStorage::delete_with_options(Self, String, DurableObjectPutOptions) -> @js.Promise[Bool]
fn DurableObjectStorage::get(Self, String) -> @js.Promise[@js.Js?]
fn DurableObjectStorage::get_alarm(Self) -> @js.Promise[Int?]
fn DurableObjectStorage::get_alarm_with_options(Self, DurableObjectGetAlarmOptions) -> @js.Promise[Int?]
fn DurableObjectStorage::get_multiple(Self, Array[String]) -> @js.Promise[@js.Js]
fn DurableObjectStorage::get_multiple_with_options(Self, Array[String], DurableObjectGetOptions) -> @js.Promise[@js.Js]
fn DurableObjectStorage::get_with_options(Self, String, DurableObjectGetOptions) -> @js.Promise[@js.Js?]
fn DurableObjectStorage::list(Self) -> @js.Promise[@js.Js]
fn DurableObjectStorage::list_with_options(Self, DurableObjectListOptions) -> @js.Promise[@js.Js]
fn DurableObjectStorage::put(Self, String, @js.Js) -> @js.Promise[Unit]
fn DurableObjectStorage::put_multiple(Self, @js.Js) -> @js.Promise[Unit]
fn DurableObjectStorage::put_multiple_with_options(Self, @js.Js, DurableObjectPutOptions) -> @js.Promise[Unit]
fn DurableObjectStorage::put_with_options(Self, String, @js.Js, DurableObjectPutOptions) -> @js.Promise[Unit]
fn DurableObjectStorage::set_alarm(Self, Int) -> @js.Promise[Unit]
fn DurableObjectStorage::set_alarm_with_options(Self, Int, DurableObjectSetAlarmOptions) -> @js.Promise[Unit]
fn DurableObjectStorage::sync(Self) -> @js.Promise[Unit]
fn DurableObjectStorage::transaction(Self, @js.Js) -> @js.Promise[@js.Js]
impl @js.JsImpl for DurableObjectStorage

#external
pub type DurableObjectStub
fn DurableObjectStub::fetch(Self, @js.Js) -> @js.Promise[@js.Js]
fn DurableObjectStub::fetch_url(Self, String) -> @js.Promise[@js.Js]
fn DurableObjectStub::fetch_url_with_init(Self, String, @js.Js) -> @js.Promise[@js.Js]
fn DurableObjectStub::fetch_with_init(Self, @js.Js, @js.Js) -> @js.Promise[@js.Js]
fn DurableObjectStub::id(Self) -> DurableObjectId
fn DurableObjectStub::name(Self) -> String?
impl @js.JsImpl for DurableObjectStub

#external
pub type DurableObjectTransaction
fn DurableObjectTransaction::delete(Self, String) -> @js.Promise[Bool]
fn DurableObjectTransaction::delete_alarm(Self) -> @js.Promise[Unit]
fn DurableObjectTransaction::delete_all(Self) -> @js.Promise[Unit]
fn DurableObjectTransaction::delete_multiple(Self, Array[String]) -> @js.Promise[Int]
fn DurableObjectTransaction::get(Self, String) -> @js.Promise[@js.Js?]
fn DurableObjectTransaction::get_alarm(Self) -> @js.Promise[Int?]
fn DurableObjectTransaction::get_multiple(Self, Array[String]) -> @js.Promise[@js.Js]
fn DurableObjectTransaction::list(Self) -> @js.Promise[@js.Js]
fn DurableObjectTransaction::list_with_options(Self, DurableObjectListOptions) -> @js.Promise[@js.Js]
fn DurableObjectTransaction::put(Self, String, @js.Js) -> @js.Promise[Unit]
fn DurableObjectTransaction::put_multiple(Self, @js.Js) -> @js.Promise[Unit]
fn DurableObjectTransaction::rollback(Self) -> Unit
fn DurableObjectTransaction::set_alarm(Self, Int) -> @js.Promise[Unit]
impl @js.JsImpl for DurableObjectTransaction

pub(all) struct KVGetOptions {
  type_ : String?
  cacheTtl : Int?
}
impl @js.JsImpl for KVGetOptions

pub(all) struct KVKey {
  name : String
  expiration : Int?
  metadata : @js.Js?
}
impl @js.JsImpl for KVKey

pub(all) struct KVListOptions {
  prefix : String?
  limit : Int?
  cursor : String?
}
impl @js.JsImpl for KVListOptions

pub(all) struct KVListResult {
  keys : Array[KVKey]
  list_complete : Bool
  cursor : String?
}
impl @js.JsImpl for KVListResult

#external
pub type KVNamespace
fn KVNamespace::delete(Self, String) -> @js.Promise[Unit]
fn KVNamespace::get(Self, String, KVGetOptions?) -> @js.Promise[String?]
fn KVNamespace::get_array_buffer(Self, String) -> @js.Promise[@js.Js?]
fn KVNamespace::get_json(Self, String) -> @js.Promise[@js.Js?]
fn KVNamespace::get_stream(Self, String) -> @js.Promise[@js.Js?]
fn KVNamespace::get_with_metadata(Self, String, KVGetOptions?) -> @js.Promise[KVValueWithMetadata]
fn KVNamespace::list(Self, KVListOptions?) -> @js.Promise[KVListResult]
fn KVNamespace::put(Self, String, String, KVPutOptions?) -> @js.Promise[Unit]
fn KVNamespace::put_with_metadata(Self, String, String, @js.Js) -> @js.Promise[Unit]
impl @js.JsImpl for KVNamespace

pub(all) struct KVPutOptions {
  expiration : Int?
  expirationTtl : Int?
  metadata : @js.Js?
}
impl @js.JsImpl for KVPutOptions

pub(all) struct KVValueWithMetadata {
  value : @js.Js?
  metadata : @js.Js?
}
impl @js.JsImpl for KVValueWithMetadata

#external
pub type R2Bucket
fn R2Bucket::create_multipart_upload(Self, String) -> @js.Promise[R2MultipartUpload]
fn R2Bucket::create_multipart_upload_with_options(Self, String, R2PutOptions) -> @js.Promise[R2MultipartUpload]
fn R2Bucket::delete(Self, String) -> @js.Promise[Unit]
fn R2Bucket::delete_multiple(Self, Array[String]) -> @js.Promise[Unit]
fn R2Bucket::get(Self, String) -> @js.Promise[R2Object?]
fn R2Bucket::get_with_options(Self, String, R2GetOptions) -> @js.Promise[R2Object?]
fn R2Bucket::head(Self, String) -> @js.Promise[R2Object?]
fn R2Bucket::list(Self) -> @js.Promise[R2Objects]
fn R2Bucket::list_with_options(Self, R2ListOptions) -> @js.Promise[R2Objects]
fn R2Bucket::put(Self, String, @js.Js) -> @js.Promise[R2Object]
fn R2Bucket::put_with_options(Self, String, @js.Js, R2PutOptions) -> @js.Promise[R2Object]
fn R2Bucket::resume_multipart_upload(Self, String, String) -> R2MultipartUpload
impl @js.JsImpl for R2Bucket

pub(all) struct R2Conditional {
  etagMatches : String?
  etagDoesNotMatch : String?
  uploadedBefore : @js.Js?
  uploadedAfter : @js.Js?
}

pub(all) struct R2GetOptions {
  onlyIf : R2Conditional?
  range : R2Range?
}
impl @js.JsImpl for R2GetOptions

pub(all) struct R2HttpMetadata {
  contentType : String?
  contentLanguage : String?
  contentDisposition : String?
  contentEncoding : String?
  cacheControl : String?
  cacheExpiry : @js.Js?
}
impl @js.JsImpl for R2HttpMetadata

pub(all) struct R2ListOptions {
  limit : Int?
  prefix : String?
  cursor : String?
  delimiter : String?
  startAfter : String?
  include_ : Array[String]?
}
impl @js.JsImpl for R2ListOptions

#external
pub type R2MultipartUpload
fn R2MultipartUpload::abort(Self) -> @js.Promise[Unit]
fn R2MultipartUpload::complete(Self, Array[R2UploadedPart]) -> @js.Promise[R2Object]
fn R2MultipartUpload::key(Self) -> String
fn R2MultipartUpload::uploadId(Self) -> String
fn R2MultipartUpload::upload_part(Self, Int, @js.Js) -> @js.Promise[R2UploadedPart]
impl @js.JsImpl for R2MultipartUpload

#external
pub type R2Object
fn R2Object::array_buffer(Self) -> @js.Promise[@arraybuffer.ArrayBuffer]
fn R2Object::blob(Self) -> @js.Promise[@blob.Blob]
fn R2Object::body(Self) -> @stream.ReadableStream
fn R2Object::body_used(Self) -> Bool
fn R2Object::custom_metadata(Self) -> @js.Js
fn R2Object::etag(Self) -> String
fn R2Object::http_metadata(Self) -> @js.Js
fn R2Object::json(Self) -> @js.Promise[@js.Js]
fn R2Object::key(Self) -> String
fn R2Object::size(Self) -> Int
fn R2Object::text(Self) -> @js.Promise[String]
fn R2Object::uploaded(Self) -> @js.Js
fn R2Object::version(Self) -> String
fn R2Object::write_http_metadata(Self, @js.Js) -> Unit
impl @js.JsImpl for R2Object

pub(all) struct R2Objects {
  objects : Array[R2Object]
  truncated : Bool
  cursor : String?
  delimitedPrefixes : Array[String]
}
impl @js.JsImpl for R2Objects

pub(all) struct R2PutOptions {
  httpMetadata : R2HttpMetadata?
  customMetadata : @js.Js?
  md5 : String?
  sha1 : String?
  sha256 : String?
  sha384 : String?
  sha512 : String?
}
impl @js.JsImpl for R2PutOptions

pub(all) struct R2Range {
  offset : Int?
  length : Int?
  suffix : Int?
}

pub(all) struct R2UploadedPart {
  partNumber : Int
  etag : String
}
impl @js.JsImpl for R2UploadedPart

// Type aliases
pub type CloudflareFetchHandler = (CloudflareRequest, CloudflareEnv, CloudflareContext) -> @js.Promise[@http.Response]

// Traits

