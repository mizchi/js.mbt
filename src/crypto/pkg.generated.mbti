// Generated using `moon info`, DON'T EDIT IT
package "mizchi/js/crypto"

import(
  "mizchi/js"
  "mizchi/js/promise"
)

// Values
#alias(get_crypto)
fn getCrypto() -> Crypto

// Errors

// Types and methods
#external
pub type Crypto
fn Crypto::subtle(Self) -> SubtleCrypto
impl @js.Js for Crypto

#external
pub type SubtleCrypto
fn SubtleCrypto::decrypt(Self, &@js.Js, &@js.Js, &@js.Js) -> @promise.Promise[@js.Val]
#alias(derive_bits)
fn SubtleCrypto::deriveBits(Self, &@js.Js, &@js.Js, Int) -> @promise.Promise[@js.Val]
#alias(derive_key)
fn SubtleCrypto::deriveKey(Self, &@js.Js, &@js.Js, &@js.Js, Bool, Array[String]) -> @promise.Promise[@js.Val]
fn SubtleCrypto::digest(Self, String, &@js.Js) -> @promise.Promise[@js.Val]
fn SubtleCrypto::encrypt(Self, &@js.Js, &@js.Js, &@js.Js) -> @promise.Promise[@js.Val]
#alias(export_key)
fn SubtleCrypto::exportKey(Self, String, &@js.Js) -> @promise.Promise[@js.Val]
#alias(generate_key)
fn SubtleCrypto::generateKey(Self, &@js.Js, Bool, Array[String]) -> @promise.Promise[@js.Val]
#alias(import_key)
fn SubtleCrypto::importKey(Self, String, &@js.Js, &@js.Js, Bool, Array[String]) -> @promise.Promise[@js.Val]
fn SubtleCrypto::sign(Self, &@js.Js, &@js.Js, &@js.Js) -> @promise.Promise[@js.Val]
#alias(unwrap_key)
fn SubtleCrypto::unwrapKey(Self, String, &@js.Js, &@js.Js, &@js.Js, &@js.Js, Bool, Array[String]) -> @promise.Promise[@js.Val]
fn SubtleCrypto::verify(Self, &@js.Js, &@js.Js, &@js.Js, &@js.Js) -> @promise.Promise[Bool]
#alias(wrap_key)
fn SubtleCrypto::wrapKey(Self, String, &@js.Js, &@js.Js, &@js.Js) -> @promise.Promise[@js.Val]
impl @js.Js for SubtleCrypto

// Type aliases

// Traits
