// Generated using `moon info`, DON'T EDIT IT
package "mizchi/js/js"

// Values
fn clear_interval(JSTimer) -> Unit

fn clear_timeout(JSTimer) -> Unit

fn[T] console_error(T) -> Unit

fn[T] console_info(T) -> Unit

fn[T] console_warn(T) -> Unit

async fn fetch(String, method_~ : String, headers? : Map[String, String]) -> Promise[Response]

fn global_this() -> Value

fn[A, B] identity(A) -> B

fn import_meta() -> Value

async fn import_module(String) -> Value

fn import_module_promise(String) -> Promise[Value]

fn js_null() -> Value

fn js_undefined() -> Value

fn[T] log(T) -> Unit

fn new_array() -> Value

fn new_object() -> Value

fn[R] return_promise(async () -> R) -> Promise[R]

fn run_async(async () -> Unit noraise) -> Unit

fn set_interval(() -> Unit, Int) -> JSTimer

fn set_timeout(() -> Unit, Int) -> JSTimer

async fn sleep(Int) -> Unit noraise

fn stringify(Value, indent? : Int) -> String

fn structured_clone(Value) -> Value

async fn[T, E : Error] suspend(((T) -> Unit, (E) -> Unit) -> Unit) -> T raise E

fn[T] to_js(T) -> Value

fn[R] to_promise_fn0(async () -> R) -> () -> Promise[R]

fn[A, R] to_promise_fn1(async (A) -> R) -> (A) -> Promise[R]

fn[A, B, R] to_promise_fn2(async (A, B) -> R) -> (A, B) -> Promise[R]

fn[A, B, C, R] to_promise_fn3(async (A, B, C) -> R) -> (A, B, C) -> Promise[R]

fn[T] try_call(() -> T) -> T raise JsError

// Errors
pub suberror JsError Value

// Types and methods
#external
pub type Date
fn Date::new() -> Self
fn Date::now() -> Int

#external
pub type JSON

#external
pub type JSTimer

#external
pub type Math
fn Math::abs(Double) -> Double
fn Math::acos(Double) -> Double
fn Math::asin(Double) -> Double
fn Math::atan(Double) -> Double
fn Math::atan2(Double, Double) -> Double
fn Math::ceil(Double) -> Int
fn Math::cos(Double) -> Double
fn Math::exp(Double) -> Double
fn Math::floor(Double) -> Int
fn Math::log(Double) -> Double
fn Math::max(Double, Double) -> Double
fn Math::min(Double, Double) -> Double
fn Math::pow(Double, Double) -> Double
fn Math::random() -> Double
fn Math::round(Double) -> Int
fn Math::sin(Double) -> Double
fn Math::sqrt(Double) -> Double
fn Math::tan(Double) -> Double
fn Math::tanh(Double) -> Double
fn Math::trunc(Double) -> Double

#external
pub type Object
fn Object::assign(Value, Value) -> Value
fn Object::extend(Value, Value) -> Value
fn Object::freeze(Value) -> Value
fn Object::from(Map[String, &ToJs]) -> Self
#alias("_[_]")
fn Object::get(Self, String) -> Unit
fn Object::has_own_property(Self, String) -> Bool
fn Object::is_(Value, Value) -> Array[Value]
fn Object::keys(Value) -> Array[String]
fn Object::new() -> Self
fn Object::seal(Value) -> Value
#alias("_[_]=_")
fn Object::set(Self, String, Value) -> Unit
fn Object::to_value(Self) -> Value
fn Object::values(Value) -> Array[Value]

#external
pub type Promise[T]
fn[A, B] Promise::bind(Self[A], (A) -> Self[B] raise, reject? : (Error) -> Self[B]) -> Self[B]
fn[A, B] Promise::catch_(Self[A], (Error) -> Self[B]) -> Self[B]
fn[T] Promise::deferred() -> (Self[T], (T) -> Unit, (Error) -> Unit)
fn[A] Promise::finally_(Self[A], () -> Unit) -> Self[A]
fn[A] Promise::new(((A) -> Unit, (Error) -> Unit) -> Unit) -> Self[A]
fn Promise::reject(Value) -> Self[Value]
fn[A] Promise::resolve(A) -> Self[A]
fn[A, B] Promise::then(Self[A], (A) -> Self[B] raise, reject? : (Error) -> Self[B]) -> Self[B]
async fn[A] Promise::wait(Self[A]) -> A

#external
pub type RegExp
fn RegExp::exec(Self, String) -> RegExpResult?
fn RegExp::new(String, flags? : String) -> Self
fn RegExp::test_(Self, String) -> Bool

pub struct RegExpResult {
  full : String
  input : String
  index : Int
  last_index : Int
  groups : Map[String, String]?
}

#external
pub type Request

#external
pub type Response
fn Response::json(Self) -> Promise[Value]
fn Response::text(Self) -> Promise[String]

#external
pub type Value
fn Value::at(Self, Int) -> Self
fn Value::call(Self, Array[Self]) -> Self
fn[T] Value::cast(Self) -> T
fn Value::delete(Self, String) -> Unit
fn Value::from_array(Array[&ToJs]) -> Self
fn Value::from_js_array(Array[Self]) -> Self
#alias("_[_]")
fn Value::get(Self, String) -> Self
fn Value::get_inner(Self, String) -> Self
fn Value::instance_of(Self, Self) -> Bool
fn Value::is_array(Self) -> Bool
fn Value::is_boolean(Self) -> Bool
fn Value::is_equal(Self, Self) -> Bool
fn Value::is_function(Self) -> Bool
fn Value::is_nan(Self) -> Bool
fn Value::is_null(Self) -> Bool
fn Value::is_number(Self) -> Bool
fn Value::is_object(Self) -> Bool
fn Value::is_string(Self) -> Bool
fn Value::is_undefined(Self) -> Bool
fn Value::length(Self) -> Int
fn Value::output(Self, &Logger) -> Unit // from trait `Show`
fn Value::push(Self, &ToJs) -> Unit
#alias("_[_]=_")
fn Value::set(Self, String, &ToJs) -> Unit
fn Value::to_js(Self) -> Self // from trait `ToJs`
fn Value::to_json(Self) -> Json // from trait `ToJson`
fn[T] Value::to_option(Self) -> T?
fn Value::to_string(Self) -> String
fn[T] Value::try_call(Self, Array[Self]) -> T raise JsError
impl ToJs for Value
impl Show for Value
impl ToJson for Value

// Type aliases

// Traits
pub(open) trait ToJs {
  to_js(Self) -> Value
}
impl ToJs for Bool
impl ToJs for Int
impl ToJs for Double
impl ToJs for String
impl ToJs for Array[&ToJs]
impl ToJs for Json
impl ToJs for Map[String, &ToJs]

