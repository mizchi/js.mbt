// Generated using `moon info`, DON'T EDIT IT
package "mizchi/js/npm/ai"

import(
  "mizchi/js"
)

// Values
fn all_of(Array[StopCondition]) -> StopCondition

fn anthropic(String) -> Model

fn anthropic_with_options(String, AnthropicOptions) -> Model

fn any_of(Array[StopCondition]) -> StopCondition

fn convert_array_to_async_iterable(Array[@js.Any]) -> @js.Any

fn convert_array_to_readable_stream(Array[@js.Any]) -> @js.Any

async fn convert_readable_stream_to_array(@js.Any) -> Array[@js.Any]

#alias(cosine_similarity)
fn cosineSimilarity(Array[Double], Array[Double]) -> Double

async fn embed(model~ : EmbeddingModel, value~ : String, max_retries? : Int, abort_signal? : @js.Any, headers? : @js.Any) -> EmbedResult

#alias(embed_many)
async fn embedMany(model~ : EmbeddingModel, values~ : Array[String], max_parallel_calls? : Int, max_retries? : Int, abort_signal? : @js.Any, headers? : @js.Any) -> EmbedManyResult

fn finish_chunk(String, MockUsage) -> @js.Any

#alias(generate_image)
async fn generateImage(model~ : ImageModel, prompt~ : String, n? : Int, size? : String, aspect_ratio? : String, seed? : Int, provider_options? : @js.Any, max_retries? : Int, abort_signal? : @js.Any, headers? : @js.Any) -> GenerateImageResult

#alias(generate_object)
async fn generateObject(model~ : Model, schema~ : @js.Any, schema_name? : String, schema_description? : String, output? : OutputStrategy, enum_values? : Array[String], prompt? : String, system? : String, messages? : Array[ModelMessage], max_tokens? : Int, temperature? : Double, max_retries? : Int, abort_signal? : @js.Any) -> GenerateObjectResult

#alias(generate_object_with_zod)
async fn generateObjectWithZod(model~ : Model, zod_schema~ : @js.Any, schema_name? : String, schema_description? : String, prompt? : String, system? : String, messages? : Array[ModelMessage], max_tokens? : Int, temperature? : Double) -> GenerateObjectResult

#alias(generate_text)
async fn generateText(model~ : Model, messages? : Array[ModelMessage], prompt? : String, system? : String, max_tokens? : Int, temperature? : Double, tools? : Tools, tool_choice? : ToolChoice, max_steps? : Int, stop_when? : StopCondition, prepare_step? : PrepareStep, active_tools? : Array[String]) -> GenerateTextResult

fn google(String) -> Model

fn google_with_options(String, GoogleOptions) -> Model

fn has_any_tool_call(Array[String]) -> StopCondition

fn has_tool_call(String) -> StopCondition

fn mock_id() -> MockId

fn mock_language_model(MockLanguageModelOptions) -> @js.Any

fn mock_model_with_stream(Array[@js.Any]) -> @js.Any

fn mock_model_with_text(String) -> @js.Any

fn mock_values_js(Array[@js.Any]) -> @js.Any

fn model_finished() -> StopCondition

fn openai(String) -> Model

fn openai_with_options(String, OpenAIOptions) -> Model

fn require_test() -> @js.Any

fn simulate_readable_stream(SimulateStreamOptions) -> @js.Any

fn simulate_stream(Array[@js.Any]) -> @js.Any

fn simulate_stream_with_delay(Array[@js.Any], Int) -> @js.Any

fn step_count_is(Int) -> StopCondition

#alias(stream_text)
fn streamText(model~ : Model, messages? : Array[ModelMessage], prompt? : String, system? : String, max_tokens? : Int, temperature? : Double, tools? : Tools, tool_choice? : ToolChoice, max_steps? : Int, stop_when? : StopCondition, prepare_step? : PrepareStep, active_tools? : Array[String]) -> StreamTextResultHandle

fn text_delta_chunk(String) -> @js.Any

fn tool_call_chunk(String, String, @js.Any) -> @js.Any

// Errors
pub suberror PrepareStep async (PrepareStepContext) -> PrepareStepResult
fn PrepareStep::as_any(Self) -> @js.Any

pub suberror StopCondition (StopConditionContext) -> Bool
fn StopCondition::as_any(Self) -> @js.Any

// Types and methods
pub(all) struct AnthropicOptions {
  api_key : String?
  base_url : String?
}
fn AnthropicOptions::as_any(Self) -> @js.Any
fn AnthropicOptions::default() -> Self

#external
pub type AnthropicProvider
fn AnthropicProvider::create(AnthropicOptions) -> Self
fn AnthropicProvider::model(Self, String) -> Model
fn AnthropicProvider::require() -> Self
impl @js.JsImpl for AnthropicProvider

pub(all) struct CallWarning {
  type_ : String
  message : String?
  raw : @js.Any
}
fn CallWarning::from_any(@js.Any) -> Self

pub(all) enum ContentPart {
  TextPart(text~ : String, provider_metadata~ : ProviderMetadata?)
  ReasoningPart(reasoning~ : ReasoningOutput)
  SourceContentPart(source~ : Source)
  FilePart(file~ : GeneratedFile, provider_metadata~ : ProviderMetadata?)
  ToolCallContentPart(tool_call~ : ToolCall, provider_metadata~ : ProviderMetadata?)
  ToolResultContentPart(tool_result~ : ToolResult, provider_metadata~ : ProviderMetadata?)
  ToolErrorContentPart(tool_error~ : ToolError, provider_metadata~ : ProviderMetadata?)
}
fn ContentPart::from_any(@js.Any) -> Self

pub(all) struct EmbedManyResult {
  embeddings : Array[Array[Double]]
  usage : EmbeddingUsage
  raw : @js.Any
}
fn EmbedManyResult::from_any(@js.Any) -> Self

pub(all) struct EmbedResult {
  embedding : Array[Double]
  usage : EmbeddingUsage
  raw : @js.Any
}
fn EmbedResult::from_any(@js.Any) -> Self

#external
pub type EmbeddingModel
impl @js.JsImpl for EmbeddingModel

pub(all) struct EmbeddingUsage {
  tokens : Int
}
fn EmbeddingUsage::from_any(@js.Any) -> Self

pub(all) enum FinishReason {
  Stop
  Length
  ContentFilter
  ToolCalls
  Error
  Other
  Unknown
}
fn FinishReason::from_string(String) -> Self
fn FinishReason::to_string(Self) -> String
impl Eq for FinishReason
impl Show for FinishReason

pub(all) struct GenerateImageResult {
  image : GeneratedImage
  images : Array[GeneratedImage]
  warnings : Array[CallWarning]
  provider_metadata : ProviderMetadata?
  raw : @js.Any
}
fn GenerateImageResult::from_any(@js.Any) -> Self

pub(all) struct GenerateObjectResult {
  object : @js.Any
  finish_reason : FinishReason
  usage : LanguageModelUsage
  warnings : Array[CallWarning]
  response : LanguageModelResponseMetadata
  provider_metadata : ProviderMetadata?
  raw : @js.Any
}
fn GenerateObjectResult::from_any(@js.Any) -> Self
fn[T] GenerateObjectResult::get_object(Self) -> T

pub(all) struct GenerateTextResult {
  content : Array[ContentPart]
  text : String
  reasoning : Array[ReasoningOutput]
  reasoning_text : String?
  files : Array[GeneratedFile]
  sources : Array[Source]
  tool_calls : Array[ToolCall]
  tool_results : Array[ToolResult]
  finish_reason : FinishReason
  usage : LanguageModelUsage
  total_usage : LanguageModelUsage
  warnings : Array[CallWarning]
  request : LanguageModelRequestMetadata
  response : LanguageModelResponseMetadata
  raw : @js.Any
}
fn GenerateTextResult::from_any(@js.Any) -> Self

pub(all) struct GeneratedFile {
  name : String?
  media_type : String?
  data : @js.Any
  raw : @js.Any
}
fn GeneratedFile::from_any(@js.Any) -> Self

pub(all) struct GeneratedImage {
  base64 : String
  uint8_array : @js.Any
  raw : @js.Any
}
fn GeneratedImage::from_any(@js.Any) -> Self

pub(all) struct GoogleOptions {
  api_key : String?
  base_url : String?
}
fn GoogleOptions::as_any(Self) -> @js.Any
fn GoogleOptions::default() -> Self

#external
pub type GoogleProvider
fn GoogleProvider::create(GoogleOptions) -> Self
fn GoogleProvider::model(Self, String) -> Model
fn GoogleProvider::require() -> Self
impl @js.JsImpl for GoogleProvider

#external
pub type ImageModel
impl @js.JsImpl for ImageModel

pub(all) struct LanguageModelRequestMetadata {
  raw : @js.Any
}
fn LanguageModelRequestMetadata::from_any(@js.Any) -> Self

pub(all) struct LanguageModelResponseMetadata {
  id : String?
  model_id : String?
  timestamp : @js.Any?
  raw : @js.Any
}
fn LanguageModelResponseMetadata::from_any(@js.Any) -> Self

pub(all) struct LanguageModelUsage {
  input_tokens : Int
  output_tokens : Int
  total_tokens : Int
  cached_input_tokens : Int
}
fn LanguageModelUsage::from_any(@js.Any) -> Self

pub(all) enum MessageContent {
  Text(String)
  Parts(Array[@js.Any])
}
impl @js.JsImpl for MessageContent

pub(all) enum MockContentPart {
  Text(String)
  ToolCall(tool_call_id~ : String, tool_name~ : String, args~ : @js.Any)
}
fn MockContentPart::as_any(Self) -> @js.Any

pub(all) enum MockGenerateHandler {
  Result(MockGenerateResult)
  Results(Array[MockGenerateResult])
  Fn(@js.Any)
}

pub(all) struct MockGenerateResult {
  finish_reason : String
  usage : MockUsage
  content : Array[MockContentPart]
  warnings : Array[@js.Any]
}
fn MockGenerateResult::as_any(Self) -> @js.Any

pub(all) struct MockId {
  mut counter : Int
}
fn MockId::new() -> Self
fn MockId::next(Self) -> Int
fn MockId::next_string(Self) -> String
fn MockId::reset(Self) -> Unit

pub(all) struct MockLanguageModelOptions {
  provider : String?
  model_id : String?
  do_generate : MockGenerateHandler?
  do_stream : MockStreamHandler?
}

pub(all) enum MockStreamHandler {
  Result(MockStreamResult)
  Results(Array[MockStreamResult])
  Fn(@js.Any)
}

pub(all) struct MockStreamResult {
  stream : @js.Any
}
fn MockStreamResult::as_any(Self) -> @js.Any

pub(all) struct MockUsage {
  input_tokens : Int
  output_tokens : Int
  total_tokens : Int
}

pub(all) struct MockValues[T] {
  values : Array[T]
  mut counter : Int
}
fn[T] MockValues::new(Array[T]) -> Self[T]
fn[T] MockValues::next(Self[T]) -> T
fn[T] MockValues::reset(Self[T]) -> Unit

#external
pub type Model
impl @js.JsImpl for Model

pub(all) enum ModelMessage {
  UserMessage(content~ : MessageContent)
  AssistantMessage(content~ : MessageContent)
  SystemMessage(content~ : MessageContent)
  ToolMessage(content~ : MessageContent)
}
impl @js.JsImpl for ModelMessage

pub(all) struct OpenAIOptions {
  api_key : String?
  base_url : String?
  organization : String?
}
fn OpenAIOptions::as_any(Self) -> @js.Any
fn OpenAIOptions::default() -> Self

#external
pub type OpenAIProvider
fn OpenAIProvider::create(OpenAIOptions) -> Self
fn OpenAIProvider::model(Self, String) -> Model
fn OpenAIProvider::require() -> Self
impl @js.JsImpl for OpenAIProvider

pub(all) enum OutputStrategy {
  Object
  Array
  Enum
  NoSchema
}
fn OutputStrategy::to_string(Self) -> String

pub(all) struct PrepareStepContext {
  step_number : Int
  messages : Array[@js.Any]
  steps : Array[StepResult]
}

pub(all) struct PrepareStepResult {
  model : Model?
  active_tools : Array[String]?
  messages : Array[@js.Any]?
  system : String?
  max_tokens : Int?
  temperature : Double?
}
fn PrepareStepResult::as_any(Self) -> @js.Any
fn PrepareStepResult::empty() -> Self
fn PrepareStepResult::with_active_tools(Array[String]) -> Self
fn PrepareStepResult::with_messages(Array[@js.Any]) -> Self
fn PrepareStepResult::with_model(Model) -> Self

pub(all) struct ProviderMetadata {
  raw : @js.Any
}
fn ProviderMetadata::as_any(Self) -> @js.Any
fn ProviderMetadata::from_any(@js.Any) -> Self?

pub(all) struct ReasoningOutput {
  text : String
  provider_metadata : ProviderMetadata?
}
fn ReasoningOutput::from_any(@js.Any) -> Self

pub(all) struct SimulateStreamOptions {
  chunks : Array[@js.Any]
  initial_delay_ms : Int?
  chunk_delay_ms : Int?
}

pub(all) enum Source {
  UrlSource(SourceUrl)
  DocumentSource(SourceDocument)
}
fn Source::from_any(@js.Any) -> Self

pub(all) struct SourceDocument {
  id : String
  title : String?
  provider_metadata : ProviderMetadata?
}

pub(all) enum SourceType {
  Url
  Document
}
fn SourceType::from_string(String) -> Self
impl Eq for SourceType
impl Show for SourceType

pub(all) struct SourceUrl {
  id : String
  url : String
  title : String?
  provider_metadata : ProviderMetadata?
}

pub(all) struct StepResult {
  content : Array[ContentPart]
  text : String
  reasoning : Array[ReasoningOutput]
  finish_reason : FinishReason
  usage : LanguageModelUsage
  warnings : Array[CallWarning]
  response : LanguageModelResponseMetadata
  raw : @js.Any
}
fn StepResult::from_any(@js.Any) -> Self

pub(all) struct StopConditionContext {
  step_number : Int
  messages : Array[@js.Any]
  tool_calls : Array[ToolCall]
  finish_reason : FinishReason
}

#external
pub type StreamTextResultHandle
#alias(finish_reason)
async fn StreamTextResultHandle::finishReason(Self) -> FinishReason
#alias(full_stream)
fn StreamTextResultHandle::fullStream(Self) -> TextStreamPartIterator
#alias(full_stream_raw)
fn StreamTextResultHandle::fullStreamRaw(Self) -> @js.AsyncIterator[@js.Any]
async fn StreamTextResultHandle::steps(Self) -> Array[StepResult]
async fn StreamTextResultHandle::text(Self) -> String
#alias(text_stream)
fn StreamTextResultHandle::textStream(Self) -> @js.AsyncIterator[String]
async fn StreamTextResultHandle::usage(Self) -> LanguageModelUsage
impl @js.JsImpl for StreamTextResultHandle

pub(all) enum TextStreamPart {
  TextStart(id~ : String, provider_metadata~ : ProviderMetadata?)
  TextEnd(id~ : String, provider_metadata~ : ProviderMetadata?)
  TextDelta(id~ : String, text~ : String, provider_metadata~ : ProviderMetadata?)
  ReasoningStart(id~ : String, provider_metadata~ : ProviderMetadata?)
  ReasoningEnd(id~ : String, provider_metadata~ : ProviderMetadata?)
  ReasoningDelta(id~ : String, text~ : String, provider_metadata~ : ProviderMetadata?)
  ToolInputStart(id~ : String, tool_name~ : String, provider_metadata~ : ProviderMetadata?, provider_executed~ : Bool?, dynamic~ : Bool?, title~ : String?)
  ToolInputEnd(id~ : String, provider_metadata~ : ProviderMetadata?)
  ToolInputDelta(id~ : String, delta~ : String, provider_metadata~ : ProviderMetadata?)
  SourcePart(source~ : Source)
  FilePart(file~ : GeneratedFile)
  ToolCallPart(tool_call~ : ToolCall)
  ToolResultPart(tool_result~ : ToolResult)
  ToolErrorPart(tool_error~ : ToolError)
  ToolOutputDeniedPart(tool_output_denied~ : ToolOutputDenied)
  ToolApprovalRequestPart(tool_approval_request~ : ToolApprovalRequest)
  StartStep(request~ : LanguageModelRequestMetadata, warnings~ : Array[CallWarning])
  FinishStep(response~ : LanguageModelResponseMetadata, usage~ : LanguageModelUsage, finish_reason~ : FinishReason, provider_metadata~ : ProviderMetadata?)
  Start
  Finish(finish_reason~ : FinishReason, total_usage~ : LanguageModelUsage)
  Abort
  Error(error~ : @js.Any)
  Raw(raw_value~ : @js.Any)
  Unknown(type_~ : String, raw~ : @js.Any)
}
fn TextStreamPart::from_any(@js.Any) -> Self
fn TextStreamPart::get_reasoning_text(Self) -> String?
fn TextStreamPart::get_text(Self) -> String?
fn TextStreamPart::is_reasoning_part(Self) -> Bool
fn TextStreamPart::is_text_part(Self) -> Bool
fn TextStreamPart::is_tool_part(Self) -> Bool
fn TextStreamPart::type_string(Self) -> String

pub(all) struct TextStreamPartIterator {
  raw : @js.AsyncIterator[@js.Any]
}
async fn TextStreamPartIterator::next(Self) -> TextStreamPart?

pub(all) struct Tool {
  description : String
  input_schema : @js.Any
  execute : (@js.Any) -> @js.Any
}
fn Tool::as_any(Self) -> @js.Any
fn[Input, Output : ToJson] Tool::typed(description~ : String, input_schema~ : Json, (Input) -> Output) -> Self
fn[Input, Output : ToJson] Tool::typed_async(description~ : String, input_schema~ : Json, async (Input) -> Output) -> Self

pub(all) struct ToolApprovalRequest {
  tool_call_id : String
  tool_name : String
  input : @js.Any
}
fn ToolApprovalRequest::from_any(@js.Any) -> Self

pub(all) struct ToolCall {
  tool_call_id : String
  tool_name : String
  input : @js.Any
}
fn ToolCall::from_any(@js.Any) -> Self

pub(all) enum ToolChoice {
  Auto
  Required
  None_
  Tool(String)
}
fn ToolChoice::as_any(Self) -> @js.Any

pub(all) struct ToolError {
  tool_call_id : String
  tool_name : String
  args : @js.Any
  error : @js.Any
}
fn ToolError::from_any(@js.Any) -> Self

pub(all) struct ToolOutputDenied {
  tool_call_id : String
  tool_name : String
  input : @js.Any
}
fn ToolOutputDenied::from_any(@js.Any) -> Self

pub(all) struct ToolResult {
  tool_call_id : String
  tool_name : String
  input : @js.Any
  output : @js.Any
}
fn ToolResult::from_any(@js.Any) -> Self

pub(all) struct Tools {
  tools : Map[String, Tool]
}
fn Tools::add(Self, String, Tool) -> Self
fn Tools::as_any(Self) -> @js.Any
fn Tools::new() -> Self

// Type aliases

// Traits

