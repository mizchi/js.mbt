// Generated using `moon info`, DON'T EDIT IT
package "mizchi/js/npm/ai"

import(
  "mizchi/js"
)

// Values
fn convert_array_to_async_iterable(Array[@js.Any]) -> @js.Any

fn convert_array_to_readable_stream(Array[@js.Any]) -> @js.Any

async fn convert_readable_stream_to_array(@js.Any) -> Array[@js.Any]

fn finish_chunk(String, MockUsage) -> @js.Any

fn mock_id() -> MockId

fn mock_language_model(MockLanguageModelOptions) -> @js.Any

fn mock_model_with_stream(Array[@js.Any]) -> @js.Any

fn mock_model_with_text(String) -> @js.Any

fn mock_values_js(Array[@js.Any]) -> @js.Any

fn require_test() -> @js.Any

fn simulate_readable_stream(SimulateStreamOptions) -> @js.Any

fn simulate_stream(Array[@js.Any]) -> @js.Any

fn simulate_stream_with_delay(Array[@js.Any], Int) -> @js.Any

fn text_delta_chunk(String) -> @js.Any

fn tool_call_chunk(String, String, @js.Any) -> @js.Any

// Errors

// Types and methods
#external
pub type Ai
async fn Ai::generateText(Self, model~ : Model, messages? : Array[ModelMessage], prompt? : String, system? : String, max_tokens? : Int, temperature? : Double, tools? : Tools, tool_choice? : ToolChoice, max_steps? : Int) -> GenerateTextResult
fn Ai::require() -> Self
fn Ai::streamText(Self, model~ : Model, messages? : Array[ModelMessage], prompt? : String, system? : String, max_tokens? : Int, temperature? : Double, tools? : Tools, tool_choice? : ToolChoice, max_steps? : Int) -> StreamTextResultHandle
impl @js.JsImpl for Ai

pub(all) struct CallWarning {
  type_ : String
  message : String?
  raw : @js.Any
}
fn CallWarning::from_any(@js.Any) -> Self

pub(all) enum ContentPart {
  TextPart(text~ : String, provider_metadata~ : ProviderMetadata?)
  ReasoningPart(reasoning~ : ReasoningOutput)
  SourceContentPart(source~ : Source)
  FilePart(file~ : GeneratedFile, provider_metadata~ : ProviderMetadata?)
  ToolCallContentPart(tool_call~ : ToolCall, provider_metadata~ : ProviderMetadata?)
  ToolResultContentPart(tool_result~ : ToolResult, provider_metadata~ : ProviderMetadata?)
  ToolErrorContentPart(tool_error~ : ToolError, provider_metadata~ : ProviderMetadata?)
}
fn ContentPart::from_any(@js.Any) -> Self

pub(all) enum FinishReason {
  Stop
  Length
  ContentFilter
  ToolCalls
  Error
  Other
  Unknown
}
fn FinishReason::from_string(String) -> Self
fn FinishReason::to_string(Self) -> String
impl Eq for FinishReason
impl Show for FinishReason

pub(all) struct GenerateTextResult {
  content : Array[ContentPart]
  text : String
  reasoning : Array[ReasoningOutput]
  reasoning_text : String?
  files : Array[GeneratedFile]
  sources : Array[Source]
  tool_calls : Array[ToolCall]
  tool_results : Array[ToolResult]
  finish_reason : FinishReason
  usage : LanguageModelUsage
  total_usage : LanguageModelUsage
  warnings : Array[CallWarning]
  request : LanguageModelRequestMetadata
  response : LanguageModelResponseMetadata
  raw : @js.Any
}
fn GenerateTextResult::from_any(@js.Any) -> Self

pub(all) struct GeneratedFile {
  name : String?
  media_type : String?
  data : @js.Any
  raw : @js.Any
}
fn GeneratedFile::from_any(@js.Any) -> Self

pub(all) struct LanguageModelRequestMetadata {
  raw : @js.Any
}
fn LanguageModelRequestMetadata::from_any(@js.Any) -> Self

pub(all) struct LanguageModelResponseMetadata {
  id : String?
  model_id : String?
  timestamp : @js.Any?
  raw : @js.Any
}
fn LanguageModelResponseMetadata::from_any(@js.Any) -> Self

pub(all) struct LanguageModelUsage {
  input_tokens : Int
  output_tokens : Int
  total_tokens : Int
  cached_input_tokens : Int
}
fn LanguageModelUsage::from_any(@js.Any) -> Self

pub(all) enum MessageContent {
  Text(String)
  Parts(Array[@js.Any])
}
impl @js.JsImpl for MessageContent

pub(all) enum MockContentPart {
  Text(String)
  ToolCall(tool_call_id~ : String, tool_name~ : String, args~ : @js.Any)
}
fn MockContentPart::to_any(Self) -> @js.Any

pub(all) enum MockGenerateHandler {
  Result(MockGenerateResult)
  Results(Array[MockGenerateResult])
  Fn(@js.Any)
}

pub(all) struct MockGenerateResult {
  finish_reason : String
  usage : MockUsage
  content : Array[MockContentPart]
  warnings : Array[@js.Any]
}
fn MockGenerateResult::to_any(Self) -> @js.Any

pub(all) struct MockId {
  mut counter : Int
}
fn MockId::new() -> Self
fn MockId::next(Self) -> Int
fn MockId::next_string(Self) -> String
fn MockId::reset(Self) -> Unit

pub(all) struct MockLanguageModelOptions {
  provider : String?
  model_id : String?
  do_generate : MockGenerateHandler?
  do_stream : MockStreamHandler?
}

pub(all) enum MockStreamHandler {
  Result(MockStreamResult)
  Results(Array[MockStreamResult])
  Fn(@js.Any)
}

pub(all) struct MockStreamResult {
  stream : @js.Any
}
fn MockStreamResult::to_any(Self) -> @js.Any

pub(all) struct MockUsage {
  input_tokens : Int
  output_tokens : Int
  total_tokens : Int
}

pub(all) struct MockValues[T] {
  values : Array[T]
  mut counter : Int
}
fn[T] MockValues::new(Array[T]) -> Self[T]
fn[T] MockValues::next(Self[T]) -> T
fn[T] MockValues::reset(Self[T]) -> Unit

#external
pub type Model
impl @js.JsImpl for Model

pub(all) enum ModelMessage {
  UserMessage(content~ : MessageContent)
  AssistantMessage(content~ : MessageContent)
  SystemMessage(content~ : MessageContent)
  ToolMessage(content~ : MessageContent)
}
impl @js.JsImpl for ModelMessage

pub(all) struct ProviderMetadata {
  raw : @js.Any
}
fn ProviderMetadata::from_any(@js.Any) -> Self?
fn ProviderMetadata::to_any(Self) -> @js.Any

pub(all) struct ReasoningOutput {
  text : String
  provider_metadata : ProviderMetadata?
}
fn ReasoningOutput::from_any(@js.Any) -> Self

pub(all) struct SimulateStreamOptions {
  chunks : Array[@js.Any]
  initial_delay_ms : Int?
  chunk_delay_ms : Int?
}

pub(all) enum Source {
  UrlSource(SourceUrl)
  DocumentSource(SourceDocument)
}
fn Source::from_any(@js.Any) -> Self

pub(all) struct SourceDocument {
  id : String
  title : String?
  provider_metadata : ProviderMetadata?
}

pub(all) enum SourceType {
  Url
  Document
}
fn SourceType::from_string(String) -> Self
impl Eq for SourceType
impl Show for SourceType

pub(all) struct SourceUrl {
  id : String
  url : String
  title : String?
  provider_metadata : ProviderMetadata?
}

pub(all) struct StepResult {
  content : Array[ContentPart]
  text : String
  reasoning : Array[ReasoningOutput]
  finish_reason : FinishReason
  usage : LanguageModelUsage
  warnings : Array[CallWarning]
  response : LanguageModelResponseMetadata
  raw : @js.Any
}
fn StepResult::from_any(@js.Any) -> Self

#external
pub type StreamTextResultHandle
async fn StreamTextResultHandle::finishReason(Self) -> FinishReason
fn StreamTextResultHandle::fullStream(Self) -> TextStreamPartIterator
fn StreamTextResultHandle::fullStreamRaw(Self) -> @js.AsyncIterator[@js.Any]
async fn StreamTextResultHandle::steps(Self) -> Array[StepResult]
async fn StreamTextResultHandle::text(Self) -> String
fn StreamTextResultHandle::textStream(Self) -> @js.AsyncIterator[String]
async fn StreamTextResultHandle::usage(Self) -> LanguageModelUsage
impl @js.JsImpl for StreamTextResultHandle

pub(all) enum TextStreamPart {
  TextStart(id~ : String, provider_metadata~ : ProviderMetadata?)
  TextEnd(id~ : String, provider_metadata~ : ProviderMetadata?)
  TextDelta(id~ : String, text~ : String, provider_metadata~ : ProviderMetadata?)
  ReasoningStart(id~ : String, provider_metadata~ : ProviderMetadata?)
  ReasoningEnd(id~ : String, provider_metadata~ : ProviderMetadata?)
  ReasoningDelta(id~ : String, text~ : String, provider_metadata~ : ProviderMetadata?)
  ToolInputStart(id~ : String, tool_name~ : String, provider_metadata~ : ProviderMetadata?, provider_executed~ : Bool?, dynamic~ : Bool?, title~ : String?)
  ToolInputEnd(id~ : String, provider_metadata~ : ProviderMetadata?)
  ToolInputDelta(id~ : String, delta~ : String, provider_metadata~ : ProviderMetadata?)
  SourcePart(source~ : Source)
  FilePart(file~ : GeneratedFile)
  ToolCallPart(tool_call~ : ToolCall)
  ToolResultPart(tool_result~ : ToolResult)
  ToolErrorPart(tool_error~ : ToolError)
  ToolOutputDeniedPart(tool_output_denied~ : ToolOutputDenied)
  ToolApprovalRequestPart(tool_approval_request~ : ToolApprovalRequest)
  StartStep(request~ : LanguageModelRequestMetadata, warnings~ : Array[CallWarning])
  FinishStep(response~ : LanguageModelResponseMetadata, usage~ : LanguageModelUsage, finish_reason~ : FinishReason, provider_metadata~ : ProviderMetadata?)
  Start
  Finish(finish_reason~ : FinishReason, total_usage~ : LanguageModelUsage)
  Abort
  Error(error~ : @js.Any)
  Raw(raw_value~ : @js.Any)
  Unknown(type_~ : String, raw~ : @js.Any)
}
fn TextStreamPart::from_any(@js.Any) -> Self
fn TextStreamPart::get_reasoning_text(Self) -> String?
fn TextStreamPart::get_text(Self) -> String?
fn TextStreamPart::is_reasoning_part(Self) -> Bool
fn TextStreamPart::is_text_part(Self) -> Bool
fn TextStreamPart::is_tool_part(Self) -> Bool
fn TextStreamPart::type_string(Self) -> String

pub(all) struct TextStreamPartIterator {
  raw : @js.AsyncIterator[@js.Any]
}
async fn TextStreamPartIterator::next(Self) -> TextStreamPart?

pub(all) struct Tool {
  description : String
  input_schema : @js.Any
  execute : (@js.Any) -> @js.Any
}
fn Tool::to_any(Self) -> @js.Any
fn[Input, Output : ToJson] Tool::typed(description~ : String, input_schema~ : Json, (Input) -> Output) -> Self
fn[Input, Output : ToJson] Tool::typed_async(description~ : String, input_schema~ : Json, async (Input) -> Output) -> Self

pub(all) struct ToolApprovalRequest {
  tool_call_id : String
  tool_name : String
  input : @js.Any
}
fn ToolApprovalRequest::from_any(@js.Any) -> Self

pub(all) struct ToolCall {
  tool_call_id : String
  tool_name : String
  input : @js.Any
}
fn ToolCall::from_any(@js.Any) -> Self

pub(all) enum ToolChoice {
  Auto
  Required
  None_
  Tool(String)
}
fn ToolChoice::to_any(Self) -> @js.Any

pub(all) struct ToolError {
  tool_call_id : String
  tool_name : String
  args : @js.Any
  error : @js.Any
}
fn ToolError::from_any(@js.Any) -> Self

pub(all) struct ToolOutputDenied {
  tool_call_id : String
  tool_name : String
  input : @js.Any
}
fn ToolOutputDenied::from_any(@js.Any) -> Self

pub(all) struct ToolResult {
  tool_call_id : String
  tool_name : String
  input : @js.Any
  output : @js.Any
}
fn ToolResult::from_any(@js.Any) -> Self

pub(all) struct Tools {
  tools : Map[String, Tool]
}
fn Tools::add(Self, String, Tool) -> Self
fn Tools::new() -> Self
fn Tools::to_any(Self) -> @js.Any

// Type aliases

// Traits

