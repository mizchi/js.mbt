// Generated using `moon info`, DON'T EDIT IT
package "mizchi/js/npm/hono"

import(
  "mizchi/js"
  "mizchi/js/npm/better_auth"
  "mizchi/js/web/http"
)

// Values
fn[T] context_provider(HonoContext[T], Array[&HonoNode], value~ : T) -> JSXNode

fn cors(origin? : String, allowMethods? : Array[String], allowHeaders? : Array[String], maxAge? : Int, credentials? : Bool, exposeHeaders? : Array[String]) -> CorsMiddleware

fn[T] create_context(T?) -> HonoContext[T]

fn[Env, ExecutionContext] delete_cookie(Context[Env, ExecutionContext], String, path? : String, secure? : Bool, domain? : String) -> String?

fn fragment(Array[&HonoNode], key? : String) -> JSXNode

fn[Env, ExecutionContext] get_all_cookies(Context[Env, ExecutionContext]) -> Map[String, String]

fn[Env, ExecutionContext] get_cookie(Context[Env, ExecutionContext], String, prefix? : String) -> String?

async fn[Env, ExecutionContext] get_signed_cookie(Context[Env, ExecutionContext], String, String) -> String?

fn hc(String) -> HonoClient

fn html(String) -> HtmlEscapedString

fn jsx(String, Array[&HonoNode], props? : Map[String, @js.Any], style? : Map[String, String], class? : String, id? : String, key? : String) -> JSXNode

fn[T] jsx_component((T) -> JSXNode, T, children? : Array[&HonoNode], key? : String) -> JSXNode

fn jwt_decode(String) -> JwtDecoded

async fn jwt_sign(@js.Any, String, alg? : JwtAlgorithm) -> String

async fn jwt_sign_payload(JwtPayload, String, alg? : JwtAlgorithm) -> String

async fn jwt_verify(String, String, alg? : JwtAlgorithm) -> @js.Any

fn[T] memo((T) -> JSXNode) -> (T) -> JSXNode

fn[Env, ExecutionContext] mount_auth(Hono[Env, ExecutionContext], @better_auth.Auth) -> Hono[Env, ExecutionContext]

fn raw(String) -> JSXNode

fn render_to_readable_stream(JSXNode) -> @js.Any

fn render_to_string(JSXNode) -> String

fn[Env, ExecutionContext] set_cookie(Context[Env, ExecutionContext], String, String, domain? : String, expires? : @js.Any, httpOnly? : Bool, maxAge? : Int, path? : String, secure? : Bool, sameSite? : String, priority? : String, prefix? : String, partitioned? : Bool) -> Unit

async fn[Env, ExecutionContext] set_signed_cookie(Context[Env, ExecutionContext], String, String, String, domain? : String, expires? : @js.Any, httpOnly? : Bool, maxAge? : Int, path? : String, secure? : Bool, sameSite? : String, priority? : String, prefix? : String, partitioned? : Bool) -> Unit

fn[Env, ExecutionContext] test_client(Hono[Env, ExecutionContext]) -> HonoClient

fn[Env, ExecutionContext] toHonoHandler(@better_auth.Auth) -> async (Context[Env, ExecutionContext]) -> @http.Response

fn[T] use_context(HonoContext[T]) -> T

// Errors

// Types and methods
pub type ClientEndpoint
async fn ClientEndpoint::delete_(Self, query? : @js.Any, form? : @js.Any, json? : @js.Any, param? : @js.Any, header? : @js.Any, init? : @js.Any) -> ClientResponse
async fn ClientEndpoint::get_(Self, query? : @js.Any, form? : @js.Any, json? : @js.Any, param? : @js.Any, header? : @js.Any, init? : @js.Any) -> ClientResponse
async fn ClientEndpoint::patch_(Self, query? : @js.Any, form? : @js.Any, json? : @js.Any, param? : @js.Any, header? : @js.Any, init? : @js.Any) -> ClientResponse
async fn ClientEndpoint::post_(Self, query? : @js.Any, form? : @js.Any, json? : @js.Any, param? : @js.Any, header? : @js.Any, init? : @js.Any) -> ClientResponse
async fn ClientEndpoint::put_(Self, query? : @js.Any, form? : @js.Any, json? : @js.Any, param? : @js.Any, header? : @js.Any, init? : @js.Any) -> ClientResponse
fn ClientEndpoint::url_(Self, query? : @js.Any, form? : @js.Any, json? : @js.Any, param? : @js.Any, header? : @js.Any, init? : @js.Any) -> String
impl @js.JsImpl for ClientEndpoint

pub type ClientResponse
#alias(array_buffer)
async fn ClientResponse::arrayBuffer(Self) -> @js.ArrayBuffer
async fn ClientResponse::blob(Self) -> @js.Any
fn ClientResponse::headers(Self) -> @js.Any
async fn ClientResponse::json(Self) -> @js.Any
fn ClientResponse::ok(Self) -> Bool
fn ClientResponse::status(Self) -> Int
async fn ClientResponse::text(Self) -> String
impl @js.JsImpl for ClientResponse

pub(all) struct Context[Env, ExecutionContext] {
  req : HonoRequest
  env : Env
  executionCtx : ExecutionContext
}
fn[Env, ExecutionContext] Context::body(Self[Env, ExecutionContext], String, status? : Int, headers? : @js.Any) -> @http.Response
#alias(execution_ctx)
fn[Env, ExecutionContext] Context::executionCtx(Self[Env, ExecutionContext]) -> ExecutionContext
#alias(get_value)
fn[Env, ExecutionContext] Context::getValue(Self[Env, ExecutionContext], String) -> @js.Any
fn[Env, ExecutionContext] Context::header(Self[Env, ExecutionContext], String, String) -> Unit
fn[Env, ExecutionContext] Context::html(Self[Env, ExecutionContext], String, status? : Int) -> @http.Response
fn[Env, ExecutionContext] Context::html_jsx(Self[Env, ExecutionContext], JSXNode, status? : Int) -> @http.Response
fn[Env, ExecutionContext, T] Context::json(Self[Env, ExecutionContext], T, status? : Int) -> @http.Response
#alias(not_found)
fn[Env, ExecutionContext] Context::notFound(Self[Env, ExecutionContext]) -> @http.Response
fn[Env, ExecutionContext] Context::redirect(Self[Env, ExecutionContext], String, status? : Int) -> @http.Response
fn[Env, ExecutionContext] Context::render(Self[Env, ExecutionContext], String) -> @http.Response
fn[Env, ExecutionContext] Context::res(Self[Env, ExecutionContext]) -> @http.Response
fn[Env, ExecutionContext] Context::set(Self[Env, ExecutionContext], String, @js.Any) -> Unit
#alias(set_renderer)
fn[Env, ExecutionContext] Context::setRenderer(Self[Env, ExecutionContext], (String) -> @http.Response) -> Unit
fn[Env, ExecutionContext] Context::status(Self[Env, ExecutionContext], Int) -> Unit
async fn[Env, ExecutionContext] Context::stream_jsx(Self[Env, ExecutionContext], JSXNode, status? : Int) -> @http.Response
fn[Env, ExecutionContext] Context::text(Self[Env, ExecutionContext], String, status? : Int) -> @http.Response
fn[Env, ExecutionContext] Context::var_(Self[Env, ExecutionContext], String) -> @js.Any
impl[Env, ExecutionContext] @js.JsImpl for Context[Env, ExecutionContext]

#external
pub type CorsMiddleware
impl @js.JsImpl for CorsMiddleware

#external
pub type Hono[Env, ExecutionContext]
fn[Env, ExecutionContext] Hono::all(Self[Env, ExecutionContext], String, async (Context[Env, ExecutionContext]) -> @http.Response) -> Self[Env, ExecutionContext]
#alias(base_path)
fn[Env, ExecutionContext] Hono::basePath(Self[Env, ExecutionContext], String) -> Self[Env, ExecutionContext]
fn[Env, ExecutionContext] Hono::cors(Self[Env, ExecutionContext], String, origin? : String, allowMethods? : Array[String], allowHeaders? : Array[String], maxAge? : Int, credentials? : Bool, exposeHeaders? : Array[String]) -> Self[Env, ExecutionContext]
fn[Env, ExecutionContext] Hono::cors_all(Self[Env, ExecutionContext], origin? : String, allowMethods? : Array[String], allowHeaders? : Array[String], maxAge? : Int, credentials? : Bool, exposeHeaders? : Array[String]) -> Self[Env, ExecutionContext]
fn[Env, ExecutionContext] Hono::delete(Self[Env, ExecutionContext], String, async (Context[Env, ExecutionContext]) -> @http.Response) -> Self[Env, ExecutionContext]
fn[Env, ExecutionContext] Hono::fetch(Self[Env, ExecutionContext], @http.Request) -> @js.Promise[@http.Response]
fn[Env, ExecutionContext] Hono::fire(Self[Env, ExecutionContext]) -> Self[Env, ExecutionContext]
fn[Env, ExecutionContext] Hono::get(Self[Env, ExecutionContext], String, async (Context[Env, ExecutionContext]) -> @http.Response) -> Self[Env, ExecutionContext]
fn[Env, ExecutionContext] Hono::mount(Self[Env, ExecutionContext], String, Self[Env, ExecutionContext]) -> Self[Env, ExecutionContext]
fn[Env, ExecutionContext] Hono::new(strict? : Bool) -> Self[Env, ExecutionContext]
#alias(not_found)
fn[Env, ExecutionContext] Hono::notFound(Self[Env, ExecutionContext], async (Context[Env, ExecutionContext]) -> @http.Response) -> Self[Env, ExecutionContext]
#alias(on_error)
fn[Env, ExecutionContext] Hono::onError(Self[Env, ExecutionContext], (@js.Any, Context[Env, ExecutionContext]) -> @http.Response) -> Self[Env, ExecutionContext]
fn[Env, ExecutionContext] Hono::options(Self[Env, ExecutionContext], String, async (Context[Env, ExecutionContext]) -> @http.Response) -> Self[Env, ExecutionContext]
fn[Env, ExecutionContext] Hono::patch(Self[Env, ExecutionContext], String, async (Context[Env, ExecutionContext]) -> @http.Response) -> Self[Env, ExecutionContext]
fn[Env, ExecutionContext] Hono::post(Self[Env, ExecutionContext], String, async (Context[Env, ExecutionContext]) -> @http.Response) -> Self[Env, ExecutionContext]
fn[Env, ExecutionContext] Hono::put(Self[Env, ExecutionContext], String, async (Context[Env, ExecutionContext]) -> @http.Response) -> Self[Env, ExecutionContext]
fn[Env, ExecutionContext] Hono::route(Self[Env, ExecutionContext], String, Self[Env, ExecutionContext]) -> Self[Env, ExecutionContext]
fn[Env, ExecutionContext] Hono::use_(Self[Env, ExecutionContext], String, (Context[Env, ExecutionContext], () -> @js.Promise[@http.Response]) -> @js.Promise[@http.Response]) -> Self[Env, ExecutionContext]
fn[Env, ExecutionContext] Hono::useall(Self[Env, ExecutionContext], (Context[Env, ExecutionContext], () -> @js.Promise[@http.Response]) -> @js.Promise[@http.Response]) -> Self[Env, ExecutionContext]
impl[Env, ExecutionContext] @js.JsImpl for Hono[Env, ExecutionContext]

pub type HonoClient
fn HonoClient::path(Self, String) -> ClientEndpoint
impl @js.JsImpl for HonoClient

#external
pub type HonoContext[T]
impl[T] @js.JsImpl for HonoContext[T]

pub(all) struct HonoRequest {
  url : String
  bodyUsed : Bool
}
#alias(array_buffer)
async fn HonoRequest::arrayBuffer(Self) -> @js.ArrayBuffer
async fn HonoRequest::blob(Self) -> @js.Any
#alias(form_data)
async fn HonoRequest::formData(Self) -> @http.FormData
fn HonoRequest::header(Self, String) -> String?
async fn HonoRequest::json(Self) -> @js.Any
fn HonoRequest::method_(Self) -> String
fn HonoRequest::param(Self, String) -> String?
#alias(param_all)
fn HonoRequest::paramAll(Self) -> @js.Any
#alias(parse_body)
async fn HonoRequest::parseBody(Self, options? : @js.Any) -> @js.Any
fn HonoRequest::path(Self) -> String
fn HonoRequest::query(Self, String) -> String?
#alias(query_all)
fn HonoRequest::queryAll(Self) -> @js.Any
async fn HonoRequest::text(Self) -> String
impl @js.JsImpl for HonoRequest

#external
pub type HtmlEscapedString
impl @js.JsImpl for HtmlEscapedString
impl HonoNode for HtmlEscapedString

#external
pub type JSXNode
impl @js.JsImpl for JSXNode
impl HonoNode for JSXNode

pub enum JwtAlgorithm {
  HS256
  HS384
  HS512
  RS256
  RS384
  RS512
  PS256
  PS384
  PS512
  ES256
  ES384
  ES512
  EdDSA
}

pub struct JwtDecoded {
  header : @js.Any
  payload : @js.Any
}

pub(all) struct JwtPayload {
  sub : String?
  iss : String?
  aud : String?
  exp : Int?
  nbf : Int?
  iat : Int?
  jti : String?
}
fn JwtPayload::default() -> Self

// Type aliases
pub type FC[T] = (T) -> JSXNode

pub type Handler[Env, ExecutionContext] = async (Context[Env, ExecutionContext]) -> @http.Response

pub type Middleware[Env, ExecutionContext] = (Context[Env, ExecutionContext], () -> @js.Promise[@http.Response]) -> @js.Promise[@http.Response]

// Traits
pub trait HonoNode {
  toHonoNode(Self) -> @js.Any
}
impl HonoNode for Bool
impl HonoNode for Int
impl HonoNode for Double
impl HonoNode for String
impl[T : HonoNode] HonoNode for Array[T]

