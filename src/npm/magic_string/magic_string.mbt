///|
/// MagicString - manipulate strings while generating source maps
/// A wrapper around the magic-string npm package

///|
/// MagicString instance for string manipulation with source map support
#external
pub type MagicString

///|
pub extern "js" fn MagicString::as_any(self : MagicString) -> @core.Any =
  #| (x) => x

///|
/// SourceMap generated by MagicString
#external
pub type SourceMap

///|
pub extern "js" fn SourceMap::as_any(self : SourceMap) -> @core.Any =
  #| (x) => x

///|
/// Bundle for combining multiple MagicString instances
#external
pub type Bundle

///|
pub extern "js" fn Bundle::as_any(self : Bundle) -> @core.Any =
  #| (x) => x

// FFI imports

///|
extern "js" fn ffi_magic_string_new(source : String) -> MagicString =
  #|(source) => new (require('magic-string').default)(source)

///|
extern "js" fn ffi_magic_string_new_with_options(
  source : String,
  options : @core.Any,
) -> MagicString =
  #|(source, options) => new (require('magic-string').default)(source, options)

///|
extern "js" fn ffi_bundle_new() -> Bundle =
  #|() => new (require('magic-string').Bundle)()

// MagicString FFI methods - chainable operations

///|
extern "js" fn ffi_ms_append(s : MagicString, content : String) -> MagicString =
  #|(s, content) => s.append(content)

///|
extern "js" fn ffi_ms_prepend(s : MagicString, content : String) -> MagicString =
  #|(s, content) => s.prepend(content)

///|
extern "js" fn ffi_ms_update(
  s : MagicString,
  start : Int,
  end : Int,
  content : String,
  options : @core.Any?,
) -> MagicString =
  #|(s, start, end, content, options) => options ? s.update(start, end, content, options) : s.update(start, end, content)

///|
extern "js" fn ffi_ms_overwrite(
  s : MagicString,
  start : Int,
  end : Int,
  content : String,
  options : @core.Any?,
) -> MagicString =
  #|(s, start, end, content, options) => options ? s.overwrite(start, end, content, options) : s.overwrite(start, end, content)

///|
extern "js" fn ffi_ms_remove(
  s : MagicString,
  start : Int,
  end : Int,
) -> MagicString =
  #|(s, start, end) => s.remove(start, end)

///|
extern "js" fn ffi_ms_reset(
  s : MagicString,
  start : Int,
  end : Int,
) -> MagicString =
  #|(s, start, end) => s.reset(start, end)

///|
extern "js" fn ffi_ms_replace(
  s : MagicString,
  pattern : String,
  replacement : String,
) -> MagicString =
  #|(s, pattern, replacement) => s.replace(pattern, replacement)

///|
extern "js" fn ffi_ms_replace_regex(
  s : MagicString,
  pattern : @core.Any,
  replacement : String,
) -> MagicString =
  #|(s, pattern, replacement) => s.replace(pattern, replacement)

///|
extern "js" fn ffi_ms_replace_all(
  s : MagicString,
  pattern : String,
  replacement : String,
) -> MagicString =
  #|(s, pattern, replacement) => s.replaceAll(pattern, replacement)

///|
extern "js" fn ffi_ms_move(
  s : MagicString,
  start : Int,
  end : Int,
  index : Int,
) -> MagicString =
  #|(s, start, end, index) => s.move(start, end, index)

///|
extern "js" fn ffi_ms_append_left(
  s : MagicString,
  index : Int,
  content : String,
) -> MagicString =
  #|(s, index, content) => s.appendLeft(index, content)

///|
extern "js" fn ffi_ms_append_right(
  s : MagicString,
  index : Int,
  content : String,
) -> MagicString =
  #|(s, index, content) => s.appendRight(index, content)

///|
extern "js" fn ffi_ms_prepend_left(
  s : MagicString,
  index : Int,
  content : String,
) -> MagicString =
  #|(s, index, content) => s.prependLeft(index, content)

///|
extern "js" fn ffi_ms_prepend_right(
  s : MagicString,
  index : Int,
  content : String,
) -> MagicString =
  #|(s, index, content) => s.prependRight(index, content)

///|
extern "js" fn ffi_ms_indent(
  s : MagicString,
  prefix : String?,
  options : @core.Any?,
) -> MagicString =
  #|(s, prefix, options) => { if (prefix && options) return s.indent(prefix, options); if (prefix) return s.indent(prefix); return s.indent(); }

///|
extern "js" fn ffi_ms_trim(s : MagicString, char_type : String?) -> MagicString =
  #|(s, charType) => charType ? s.trim(charType) : s.trim()

///|
extern "js" fn ffi_ms_trim_start(
  s : MagicString,
  char_type : String?,
) -> MagicString =
  #|(s, charType) => charType ? s.trimStart(charType) : s.trimStart()

///|
extern "js" fn ffi_ms_trim_end(
  s : MagicString,
  char_type : String?,
) -> MagicString =
  #|(s, charType) => charType ? s.trimEnd(charType) : s.trimEnd()

///|
extern "js" fn ffi_ms_trim_lines(s : MagicString) -> MagicString =
  #|(s) => s.trimLines()

///|
extern "js" fn ffi_ms_generate_map(
  s : MagicString,
  options : @core.Any?,
) -> SourceMap =
  #|(s, options) => options ? s.generateMap(options) : s.generateMap()

///|
extern "js" fn ffi_ms_generate_decoded_map(
  s : MagicString,
  options : @core.Any?,
) -> @core.Any =
  #|(s, options) => options ? s.generateDecodedMap(options) : s.generateDecodedMap()

///|
extern "js" fn ffi_ms_add_sourcemap_location(
  s : MagicString,
  index : Int,
) -> Unit =
  #|(s, index) => s.addSourcemapLocation(index)

// SourceMap FFI

// Bundle FFI

///|
extern "js" fn ffi_bundle_add_source(b : Bundle, source : @core.Any) -> Bundle =
  #|(b, source) => b.addSource(source)

///|
extern "js" fn ffi_bundle_indent(b : Bundle, prefix : String?) -> Bundle =
  #|(b, prefix) => prefix ? b.indent(prefix) : b.indent()

///|
extern "js" fn ffi_bundle_prepend(b : Bundle, content : String) -> Bundle =
  #|(b, content) => b.prepend(content)

///|
extern "js" fn ffi_bundle_append(b : Bundle, content : String) -> Bundle =
  #|(b, content) => b.append(content)

///|
extern "js" fn ffi_bundle_to_string(b : Bundle) -> String =
  #|(b) => b.toString()

///|
extern "js" fn ffi_bundle_generate_map(
  b : Bundle,
  options : @core.Any?,
) -> SourceMap =
  #|(b, options) => options ? b.generateMap(options) : b.generateMap()

// ============ Public API ============

///|
/// Create a new MagicString instance
pub fn MagicString::new(
  source : String,
  filename? : String,
  offset? : Int,
) -> MagicString {
  if filename is Some(_) || offset is Some(_) {
    let obj = @core.new_object()
    if filename is Some(f) {
      obj["filename"] = @core.any(f)
    }
    if offset is Some(o) {
      obj["offset"] = @core.any(o)
    }
    ffi_magic_string_new_with_options(source, obj)
  } else {
    ffi_magic_string_new(source)
  }
}

///|
/// Create a new Bundle instance
pub fn Bundle::new() -> Bundle {
  ffi_bundle_new()
}

// MagicString instance methods

///|
/// Append content to the end
pub fn MagicString::append(self : MagicString, content : String) -> MagicString {
  ffi_ms_append(self, content)
}

///|
/// Prepend content to the start
pub fn MagicString::prepend(
  self : MagicString,
  content : String,
) -> MagicString {
  ffi_ms_prepend(self, content)
}

///|
/// Update (replace) characters from start to end with content
pub fn MagicString::update(
  self : MagicString,
  start : Int,
  end : Int,
  content : String,
  store_name? : Bool,
  overwrite? : Bool,
) -> MagicString {
  if store_name is Some(_) || overwrite is Some(_) {
    let obj = @core.new_object()
    if store_name is Some(s) {
      obj["storeName"] = @core.any(s)
    }
    if overwrite is Some(o) {
      obj["overwrite"] = @core.any(o)
    }
    ffi_ms_update(self, start, end, content, Some(obj))
  } else {
    ffi_ms_update(self, start, end, content, None)
  }
}

///|
/// Overwrite characters from start to end with content
pub fn MagicString::overwrite(
  self : MagicString,
  start : Int,
  end : Int,
  content : String,
  store_name? : Bool,
  content_only? : Bool,
) -> MagicString {
  if store_name is Some(_) || content_only is Some(_) {
    let obj = @core.new_object()
    if store_name is Some(s) {
      obj["storeName"] = @core.any(s)
    }
    if content_only is Some(c) {
      obj["contentOnly"] = @core.any(c)
    }
    ffi_ms_overwrite(self, start, end, content, Some(obj))
  } else {
    ffi_ms_overwrite(self, start, end, content, None)
  }
}

///|
/// Remove characters from start to end
pub fn MagicString::remove(
  self : MagicString,
  start : Int,
  end : Int,
) -> MagicString {
  ffi_ms_remove(self, start, end)
}

///|
/// Reset (restore) previously removed characters
pub fn MagicString::reset(
  self : MagicString,
  start : Int,
  end : Int,
) -> MagicString {
  ffi_ms_reset(self, start, end)
}

///|
/// Replace first occurrence of pattern with replacement
pub fn MagicString::replace(
  self : MagicString,
  pattern : String,
  replacement : String,
) -> MagicString {
  ffi_ms_replace(self, pattern, replacement)
}

///|
/// Replace pattern (regex) with replacement
pub fn MagicString::replace_regex(
  self : MagicString,
  pattern : @core.Any,
  replacement : String,
) -> MagicString {
  ffi_ms_replace_regex(self, pattern, replacement)
}

///|
/// Replace all occurrences of pattern with replacement
pub fn MagicString::replace_all(
  self : MagicString,
  pattern : String,
  replacement : String,
) -> MagicString {
  ffi_ms_replace_all(self, pattern, replacement)
}

///|
/// Move characters from start-end to index
pub fn MagicString::relocate(
  self : MagicString,
  start : Int,
  end : Int,
  index : Int,
) -> MagicString {
  ffi_ms_move(self, start, end, index)
}

///|
/// Insert content at index (moves with ending ranges)
pub fn MagicString::append_left(
  self : MagicString,
  index : Int,
  content : String,
) -> MagicString {
  ffi_ms_append_left(self, index, content)
}

///|
/// Insert content at index (moves with starting ranges)
pub fn MagicString::append_right(
  self : MagicString,
  index : Int,
  content : String,
) -> MagicString {
  ffi_ms_append_right(self, index, content)
}

///|
/// Prepend content before previous inserts at index
pub fn MagicString::prepend_left(
  self : MagicString,
  index : Int,
  content : String,
) -> MagicString {
  ffi_ms_prepend_left(self, index, content)
}

///|
/// Prepend content before previous inserts at index
pub fn MagicString::prepend_right(
  self : MagicString,
  index : Int,
  content : String,
) -> MagicString {
  ffi_ms_prepend_right(self, index, content)
}

///|
/// Indent each line with prefix
pub fn MagicString::indent(self : MagicString, prefix? : String) -> MagicString {
  ffi_ms_indent(self, prefix, None)
}

///|
/// Trim matching characters from both ends
pub fn MagicString::trim(
  self : MagicString,
  char_type? : String,
) -> MagicString {
  ffi_ms_trim(self, char_type)
}

///|
/// Trim matching characters from start
pub fn MagicString::trim_start(
  self : MagicString,
  char_type? : String,
) -> MagicString {
  ffi_ms_trim_start(self, char_type)
}

///|
/// Trim matching characters from end
pub fn MagicString::trim_end(
  self : MagicString,
  char_type? : String,
) -> MagicString {
  ffi_ms_trim_end(self, char_type)
}

///|
/// Remove empty lines from boundaries
pub fn MagicString::trim_lines(self : MagicString) -> MagicString {
  ffi_ms_trim_lines(self)
}

///|
/// Generate a v3 source map
pub fn MagicString::generate_map(
  self : MagicString,
  file? : String,
  source? : String,
  include_content? : Bool,
  hires? : Bool,
) -> SourceMap {
  if file is Some(_) ||
    source is Some(_) ||
    include_content is Some(_) ||
    hires is Some(_) {
    let obj = @core.new_object()
    if file is Some(f) {
      obj["file"] = @core.any(f)
    }
    if source is Some(s) {
      obj["source"] = @core.any(s)
    }
    if include_content is Some(i) {
      obj["includeContent"] = @core.any(i)
    }
    if hires is Some(h) {
      obj["hires"] = @core.any(h)
    }
    ffi_ms_generate_map(self, Some(obj))
  } else {
    ffi_ms_generate_map(self, None)
  }
}

///|
/// Generate a decoded source map (raw array mappings)
pub fn MagicString::generate_decoded_map(
  self : MagicString,
  file? : String,
  source? : String,
  include_content? : Bool,
  hires? : Bool,
) -> @core.Any {
  if file is Some(_) ||
    source is Some(_) ||
    include_content is Some(_) ||
    hires is Some(_) {
    let obj = @core.new_object()
    if file is Some(f) {
      obj["file"] = @core.any(f)
    }
    if source is Some(s) {
      obj["source"] = @core.any(s)
    }
    if include_content is Some(i) {
      obj["includeContent"] = @core.any(i)
    }
    if hires is Some(h) {
      obj["hires"] = @core.any(h)
    }
    ffi_ms_generate_decoded_map(self, Some(obj))
  } else {
    ffi_ms_generate_decoded_map(self, None)
  }
}

///|
/// Mark character index for source map inclusion
pub fn MagicString::add_sourcemap_location(
  self : MagicString,
  index : Int,
) -> Unit {
  ffi_ms_add_sourcemap_location(self, index)
}

///|
/// Get the generated string
pub extern "js" fn MagicString::to_string(self : MagicString) -> String =
  #|(s) => s.toString()

///|
/// Create an independent copy
pub extern "js" fn MagicString::clone(self : MagicString) -> MagicString =
  #|(s) => s.clone()

///|
/// Extract substring corresponding to original range
pub extern "js" fn MagicString::slice(
  self : MagicString,
  start : Int,
  end : Int,
) -> String =
  #|(s, start, end) => s.slice(start, end)

///|
/// Clone with content outside range removed
pub extern "js" fn MagicString::snip(
  self : MagicString,
  start : Int,
  end : Int,
) -> MagicString =
  #|(s, start, end) => s.snip(start, end)

///|
/// Check if the string has been modified
pub extern "js" fn MagicString::has_changed(self : MagicString) -> Bool =
  #|(s) => s.hasChanged()

///|
/// Check if result is empty (ignoring whitespace)
pub extern "js" fn MagicString::is_empty(self : MagicString) -> Bool =
  #|(s) => s.isEmpty()

///|
/// Get the original source string
pub fn MagicString::original(self : MagicString) -> String {
  self.as_any()["original"].cast()
}

///|
/// Get the current offset
pub fn MagicString::get_offset(self : MagicString) -> Int {
  self.as_any()["offset"].cast()
}

///|
/// Set the offset for position adjustment
pub fn MagicString::set_offset(self : MagicString, offset : Int) -> Unit {
  self.as_any()["offset"] = @core.any(offset)
}

// SourceMap methods

///|
/// Convert source map to JSON string
pub extern "js" fn SourceMap::to_string(self : SourceMap) -> String =
  #|(m) => m.toString()

///|
/// Convert source map to data URL
pub extern "js" fn SourceMap::to_url(self : SourceMap) -> String =
  #|(m) => m.toUrl()

///|
/// Get the file name
pub fn SourceMap::file(self : SourceMap) -> String? {
  let f = self.as_any()["file"]
  if @core.is_nullish(f) {
    None
  } else {
    Some(f.cast())
  }
}

///|
/// Get the sources array
pub fn SourceMap::sources(self : SourceMap) -> Array[String] {
  self.as_any()["sources"].cast()
}

///|
/// Get the sources content array
pub fn SourceMap::sources_content(self : SourceMap) -> Array[String]? {
  let sc = self.as_any()["sourcesContent"]
  if @core.is_nullish(sc) {
    None
  } else {
    Some(sc.cast())
  }
}

///|
/// Get the mappings string
pub fn SourceMap::mappings(self : SourceMap) -> String {
  self.as_any()["mappings"].cast()
}

// Bundle methods

///|
/// Add a MagicString source to the bundle
pub fn Bundle::add_source(self : Bundle, source : MagicString) -> Bundle {
  ffi_bundle_add_source(self, source.as_any())
}

///|
/// Add a source with filename
pub fn Bundle::add_source_with_filename(
  self : Bundle,
  filename : String,
  content : MagicString,
) -> Bundle {
  let obj = @core.new_object()
  obj["filename"] = @core.any(filename)
  obj["content"] = content.as_any()
  ffi_bundle_add_source(self, obj)
}

///|
/// Indent all sources
pub fn Bundle::indent(self : Bundle, prefix? : String) -> Bundle {
  ffi_bundle_indent(self, prefix)
}

///|
/// Prepend content to bundle
pub fn Bundle::prepend(self : Bundle, content : String) -> Bundle {
  ffi_bundle_prepend(self, content)
}

///|
/// Append content to bundle
pub fn Bundle::append(self : Bundle, content : String) -> Bundle {
  ffi_bundle_append(self, content)
}

///|
/// Get the concatenated result
pub fn Bundle::to_string(self : Bundle) -> String {
  ffi_bundle_to_string(self)
}

///|
/// Generate source map for bundle
pub fn Bundle::generate_map(
  self : Bundle,
  file? : String,
  include_content? : Bool,
  hires? : Bool,
) -> SourceMap {
  if file is Some(_) || include_content is Some(_) || hires is Some(_) {
    let obj = @core.new_object()
    if file is Some(f) {
      obj["file"] = @core.any(f)
    }
    if include_content is Some(i) {
      obj["includeContent"] = @core.any(i)
    }
    if hires is Some(h) {
      obj["hires"] = @core.any(h)
    }
    ffi_bundle_generate_map(self, Some(obj))
  } else {
    ffi_bundle_generate_map(self, None)
  }
}
