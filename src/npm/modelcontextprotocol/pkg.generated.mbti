// Generated using `moon info`, DON'T EDIT IT
package "mizchi/js/npm/modelcontextprotocol"

import(
  "mizchi/js"
  "moonbitlang/core/immut/hashmap"
)

// Values
let internal_error : Int

let invalid_params : Int

let invalid_request : Int

let method_not_found : Int

let parse_error : Int

// Errors

// Types and methods
pub(all) struct CallToolResult {
  content : Array[ContentResult]
  is_error : Bool?
  raw : @js.Any
}

pub struct ClientInfo {
  name : String
  version : String
}
fn ClientInfo::from_js(@js.Any) -> Self?
impl Show for ClientInfo

pub struct Content {
  type_ : ContentType
  text : String?
  data : String?
  mime_type : String?
  uri : String?
}
fn Content::as_any(Self) -> @js.Any
fn Content::image(String, String) -> Self
fn Content::resource(String) -> Self
fn Content::text(String) -> Self
impl Show for Content

pub(all) struct ContentResult {
  text : String?
  data : String?
  mime_type : String?
  raw : @js.Any
}
fn ContentResult::type_(Self) -> String

pub enum ContentType {
  Text
  Image
  Resource
}
fn ContentType::to_string(Self) -> String
impl Eq for ContentType
impl Show for ContentType

pub(all) struct GetPromptResult {
  description : String?
  messages : Array[PromptMessageResult]
  raw : @js.Any
}

pub struct JsonRpcError {
  code : Int
  message : String
  data : @js.Any?
}
fn JsonRpcError::as_any(Self) -> @js.Any

pub struct JsonRpcErrorResponse {
  jsonrpc : String
  id : RequestId
  error : JsonRpcError
}
fn JsonRpcErrorResponse::as_any(Self) -> @js.Any

pub(all) struct JsonRpcNotification {
  jsonrpc : String
  method_name : String
  params : @js.Any?
}
fn JsonRpcNotification::as_any(Self) -> @js.Any

pub struct JsonRpcRequest {
  jsonrpc : String
  id : RequestId
  method_name : String
  params : @js.Any?
}
fn JsonRpcRequest::as_any(Self) -> @js.Any
fn JsonRpcRequest::from_js(@js.Any) -> Self?

pub struct JsonRpcResponse {
  jsonrpc : String
  id : RequestId
  result : @js.Any
}
fn JsonRpcResponse::as_any(Self) -> @js.Any

pub(all) struct ListPromptsResult {
  prompts : Array[PromptInfo]
  raw : @js.Any
}

pub(all) struct ListResourcesResult {
  resources : Array[ResourceInfo]
  raw : @js.Any
}

pub(all) struct ListToolsResult {
  tools : Array[ToolInfo]
  raw : @js.Any
}

pub struct McpClient {
  server_info : ServerInfo?
  mut request_id : Int
  endpoint : String
}
fn McpClient::create_request(Self, String) -> JsonRpcRequest
fn McpClient::create_request_with_params(Self, String, &@js.JsImpl) -> JsonRpcRequest
fn McpClient::get_server_info(Self) -> ServerInfo?
fn McpClient::new(String) -> Self

pub struct McpServer {
  info : ServerInfo
  mut tools : @hashmap.HashMap[String, (Tool, (@js.Any) -> @js.Promise[Array[Content]])]
  mut resources : @hashmap.HashMap[String, (Resource, (String) -> @js.Promise[Array[Content]])]
  mut prompts : @hashmap.HashMap[String, (Prompt, (@js.Any) -> @js.Promise[Array[Content]])]
}
fn[T] McpServer::add_prompt(Self, Prompt, async (T) -> Array[Content]) -> Unit
fn McpServer::add_resource(Self, Resource, async (String) -> Array[Content]) -> Unit
fn[T] McpServer::add_tool(Self, Tool, async (T) -> Array[Content]) -> Unit
fn McpServer::handle_request(Self, JsonRpcRequest) -> @js.Promise[Result[JsonRpcResponse, JsonRpcErrorResponse]]
fn McpServer::new(String, String) -> Self

pub(all) struct Prompt {
  name : String
  description : String?
  arguments : Array[PromptArgument]
}
fn Prompt::as_any(Self) -> @js.Any
impl Show for Prompt

pub(all) struct PromptArgument {
  name : String
  description : String?
  required : Bool
}
fn PromptArgument::as_any(Self) -> @js.Any
impl Show for PromptArgument

pub(all) struct PromptArgumentInfo {
  name : String
  description : String?
  required : Bool?
}

pub(all) struct PromptInfo {
  name : String
  description : String?
  arguments : Array[PromptArgumentInfo]?
}

pub(all) struct PromptMessage {
  role : String
  content : Content
}
fn PromptMessage::as_any(Self) -> @js.Any

pub(all) struct PromptMessageResult {
  role : String
  content : ContentResult
}

pub(all) struct PromptResult {
  description : String?
  messages : Array[PromptMessage]
}
fn PromptResult::as_any(Self) -> @js.Any

pub(all) struct ReadResourceResult {
  contents : Array[ContentResult]
  raw : @js.Any
}

pub enum RequestId {
  String(String)
  Number(Int)
}
fn RequestId::as_any(Self) -> @js.Any
fn RequestId::from_js(@js.Any) -> Self?
impl Eq for RequestId
impl Show for RequestId

pub(all) struct Resource {
  uri : String
  name : String
  description : String?
  mime_type : String?
}
fn Resource::as_any(Self) -> @js.Any
impl Show for Resource

pub(all) struct ResourceInfo {
  uri : String
  name : String
  description : String?
  mime_type : String?
}

#external
pub type SdkClient
async fn SdkClient::call_tool(Self, String, &@js.JsImpl) -> CallToolResult
async fn SdkClient::close(Self) -> Unit
async fn SdkClient::connect(Self, StdioClientTransport) -> Unit
async fn SdkClient::get_prompt(Self, String, @js.Any?) -> GetPromptResult
async fn SdkClient::list_prompts(Self) -> ListPromptsResult
async fn SdkClient::list_resources(Self) -> ListResourcesResult
async fn SdkClient::list_tools(Self) -> ListToolsResult
fn SdkClient::new(String, String) -> Self
fn SdkClient::on_log_message(Self, (String, String, @js.Any) -> Unit) -> Unit
async fn SdkClient::read_resource(Self, String) -> ReadResourceResult
fn SdkClient::set_notification_handler(Self, String, (@js.Any) -> Unit) -> Unit
impl @js.JsImpl for SdkClient

#external
pub type SdkServer
async fn SdkServer::close(Self) -> Unit
async fn SdkServer::connect(Self, StdioServerTransport) -> Unit
fn SdkServer::log(Self, String, String) -> Unit
fn SdkServer::new(String, String, tools? : Bool, resources? : Bool, prompts? : Bool) -> Self
fn SdkServer::send_notification(Self, String, &@js.JsImpl) -> Unit
fn SdkServer::set_prompts_get_handler(Self, async (String, @js.Any) -> PromptResult) -> Unit
fn SdkServer::set_prompts_list_handler(Self, () -> Array[Prompt]) -> Unit
fn SdkServer::set_resources_list_handler(Self, () -> Array[Resource]) -> Unit
fn SdkServer::set_resources_read_handler(Self, async (String) -> Array[Content]) -> Unit
fn SdkServer::set_tools_call_handler(Self, async (String, @js.Any) -> Array[Content]) -> Unit
fn SdkServer::set_tools_list_handler(Self, () -> Array[Tool]) -> Unit
impl @js.JsImpl for SdkServer

pub struct ServerCapabilities {
  tools : Bool
  resources : Bool
  prompts : Bool
}
fn ServerCapabilities::as_any(Self) -> @js.Any
impl Show for ServerCapabilities

pub struct ServerInfo {
  name : String
  version : String
}
fn ServerInfo::as_any(Self) -> @js.Any
impl Show for ServerInfo

#external
pub type StdioClientTransport
async fn StdioClientTransport::close(Self) -> Unit
fn StdioClientTransport::new(String, Array[String], env? : @js.Any, cwd? : String) -> Self
async fn StdioClientTransport::start(Self) -> Unit
impl @js.JsImpl for StdioClientTransport

#external
pub type StdioServerTransport
fn StdioServerTransport::new() -> Self
impl @js.JsImpl for StdioServerTransport

pub(all) struct Tool {
  name : String
  description : String
  input_schema : @js.Any
}
fn Tool::as_any(Self) -> @js.Any

pub(all) struct ToolInfo {
  name : String
  description : String?
  input_schema : @js.Any
}

// Type aliases
pub type PromptHandler[T] = async (T) -> Array[Content]

pub type ResourceHandler = async (String) -> Array[Content]

pub type ToolHandler[T] = async (T) -> Array[Content]

// Traits

