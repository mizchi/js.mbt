// Generated using `moon info`, DON'T EDIT IT
package "mizchi/js/npm/preact"

import(
  "mizchi/js"
  "mizchi/js/browser/dom"
  "mizchi/js/nostd"
)

// Values
#alias(batch_updates)
fn batch(() -> Unit) -> Unit

#alias(clone_element)
fn cloneElement(VNode, props? : @nostd.Any) -> VNode

#alias(c)
fn[T] component((T) -> VNode, T, children? : Array[&PreactNode], key? : String) -> VNode

#alias(create_computed)
fn[T] computed(() -> T) -> ReadonlySignal[T]

#alias(create_context)
fn[T] createContext(T?) -> Context[T]

#alias(create_ref)
fn[T] createRef() -> Ref[T]

fn[T] createResource(() -> @nostd.Promise[T]) -> Resource[T]

async fn dynamic_import() -> Unit

#alias(create_effect)
fn effect(() -> Unit) -> () -> Unit

#alias(create_effect_with_cleanup)
fn effectWithCleanup(() -> () -> Unit) -> () -> Unit

fn fragment(Array[&PreactNode], key? : String) -> VNode

#alias(createElement)
fn h(String, Array[&PreactNode], props? : Map[String, @nostd.Any], style? : Map[String, String], ref_? : Ref[@dom.Element], key? : String) -> VNode

fn hydrate(VNode, @dom.Element) -> Unit

fn init_preact_api(@nostd.Any, @nostd.Any, global_key? : String) -> Unit

fn init_preact_signals(@nostd.Any) -> Unit

fn init_preact_ssr(@nostd.Any) -> Unit

fn[T] provider(Context[T], Array[&PreactNode], value~ : T) -> VNode

fn render(VNode, @dom.Element) -> Unit

fn renderToString(VNode) -> String

async fn renderToStringAsync(VNode) -> String

#alias(create_signal)
fn[T] signal(T) -> Signal[T]

#alias(to_child_array)
fn toChildArray(@nostd.Any) -> Array[VNode]

fn[T] untracked(() -> T) -> T

#alias(use_callback)
fn[F] useCallback(F, Array[@nostd.Any]) -> F

#alias(use_computed)
fn[T] useComputed(() -> T) -> ReadonlySignal[T]

#alias(use_context)
fn[T] useContext(Context[T]) -> T

#alias(use_debug_value)
fn[T] useDebugValue(T) -> Unit

#alias(use_effect)
fn useEffect(() -> () -> Unit, Array[@nostd.Any]) -> Unit

#alias(use_error_boundary)
fn useErrorBoundary(callback? : (@nostd.Any) -> Unit) -> (@nostd.Any?, () -> Unit)

#alias(use_id)
fn useId() -> String

#alias(use_imperative_handle)
fn[T] useImperativeHandle(Ref[T], () -> T, Array[@nostd.Any]) -> Unit

#alias(use_layout_effect)
fn useLayoutEffect(() -> () -> Unit, Array[@nostd.Any]) -> Unit

#alias(use_memo)
fn[T] useMemo(() -> T, Array[@nostd.Any]) -> T

#alias(use_reducer)
fn[T, U] useReducer((T, U) -> T, T) -> (T, (U) -> Unit)

#alias(use_ref)
fn[T] useRef(T?) -> Ref[T]

#alias(use_signal)
fn[T] useSignal(T) -> Signal[T]

#alias(use_signal_effect)
fn useSignalEffect(() -> Unit) -> Unit

#alias(use_state)
fn[T] useState(T) -> (T, (T) -> Unit)

#alias(use_state_lazy)
fn[T] useStateLazy(() -> T) -> (T, (T) -> Unit)

// Errors

// Types and methods
#external
pub type Context[T]
fn[T] Context::as_any(Self[T]) -> @nostd.Any

pub(all) struct ReadonlySignal[T] {
  value : T
}
fn[T] ReadonlySignal::as_any(Self[T]) -> @nostd.Any
fn[T] ReadonlySignal::peek(Self[T]) -> T
fn[T] ReadonlySignal::subscribe(Self[T], (T) -> Unit) -> () -> Unit

pub(all) struct Ref[T] {
  current : @nostd.Any
}
fn[T] Ref::as_any(Self[T]) -> @nostd.Any
fn[T] Ref::get_current(Self[T]) -> T?
fn[T] Ref::set_current(Self[T], T?) -> Unit

pub struct Resource[T] {
  data : Signal[T?]
  is_loading : Signal[Bool]
  error : Signal[@nostd.Any?]
  refetch : () -> Unit
}
fn[T] Resource::get_error(Self[T]) -> @nostd.Any?
fn[T] Resource::has_error(Self[T]) -> Bool
fn[T] Resource::loading(Self[T]) -> Bool
fn[T] Resource::refetch(Self[T]) -> Unit
fn[T] Resource::try_value(Self[T]) -> T?
fn[T] Resource::value(Self[T]) -> T

pub(all) struct Signal[T] {
  mut value : T
}
fn[T] Signal::as_any(Self[T]) -> @nostd.Any
fn[T] Signal::peek(Self[T]) -> T
fn[T] Signal::subscribe(Self[T], (T) -> Unit) -> () -> Unit

#external
pub type VNode
fn VNode::as_any(Self) -> @nostd.Any
impl PreactNode for VNode

// Type aliases
pub type Component[T] = (T) -> VNode

// Traits
pub(open) trait PreactNode {
  to_preact_node(Self) -> @nostd.Any
}
impl PreactNode for Bool
impl PreactNode for Int
impl PreactNode for Double
impl PreactNode for String
impl[T : PreactNode] PreactNode for T?
impl PreactNode for Array[&PreactNode]

