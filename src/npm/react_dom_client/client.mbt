///|
#external
pub type ReactDOMClient

///|
#external
pub type ReactDOMRoot

///|
pub impl @js.JsImpl for ReactDOMRoot

///|
pub impl @js.JsImpl for ReactDOMClient

///|
/// Dynamic import for react-dom/client module (internal)
/// NOTE: This uses dynamic import which doesn't support tree-shaking.
/// When MoonBit adds native ESM support, this should be replaced with static imports.
extern "js" fn import_react_dom_client_internal() -> @js.Promise[ReactDOMClient] =
  #| () => import("react-dom/client")

///|
/// Dynamic import for react-dom/client module
/// NOTE: This uses dynamic import which doesn't support tree-shaking.
/// When MoonBit adds native ESM support, this should be replaced with static imports.
pub async fn dynamic_import() -> ReactDOMClient {
  import_react_dom_client_internal().wait()
}

///|
#alias(create_root)
pub fn ReactDOMClient::createRoot(
  self : Self,
  container : &@dom.ElementImpl,
) -> ReactDOMRoot {
  self.call1("createRoot", container.as_any()).cast()
}

///|
pub fn ReactDOMRoot::render(self : ReactDOMRoot, vdom : @react.Element) -> Unit {
  let vdom_js : @js.Any = vdom.as_any().cast()
  self.call1("render", vdom_js) |> ignore
}

///|
/// Hydrate a server-rendered React application
/// hydrateRoot lets you display React components inside a browser DOM node
/// whose HTML content was previously generated by react-dom/server.
#alias(hydrate_root)
pub fn ReactDOMClient::hydrateRoot(
  self : Self,
  dom_node : &@dom.ElementImpl,
  react_node : @react.Element,
) -> ReactDOMRoot {
  let react_node_js : @js.Any = react_node.as_any().cast()
  self.call2("hydrateRoot", dom_node.as_any(), react_node_js).cast()
}

///|
pub fn ReactDOMRoot::unmount(self : ReactDOMRoot) -> Unit {
  self.call0("unmount") |> ignore
}
