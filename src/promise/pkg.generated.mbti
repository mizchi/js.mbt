// Generated using `moon info`, DON'T EDIT IT
package "mizchi/js/promise"

import(
  "mizchi/js"
)

// Values
fn[R] promisify0(async () -> R) -> () -> Promise[R]

fn[A, R] promisify1(async (A) -> R) -> (A) -> Promise[R]

fn[A, B, R] promisify2(async (A, B) -> R) -> (A, B) -> Promise[R]

fn[A, B, C, R] promisify3(async (A, B, C) -> R) -> (A, B, C) -> Promise[R]

fn run_async(async () -> Unit noraise) -> Unit

async fn sleep(Int) -> Unit noraise

async fn[T, E : Error] suspend(((T) -> Unit, (E) -> Unit) -> Unit) -> T raise E

// Errors

// Types and methods
#external
pub type Promise[T]
fn[A] Promise::all(Array[Self[A]]) -> Self[Array[A]]
fn[A, B] Promise::catch_(Self[A], (Error) -> Self[B]) -> Self[B]
fn[A] Promise::finally_(Self[A], () -> Unit) -> Self[A]
fn[A] Promise::new(((A) -> Unit, (Error) -> Unit) -> Unit) -> Self[A]
fn[T] Promise::race(Array[Self[T]]) -> Self[T]
fn Promise::reject(@js.Val) -> Self[@js.Val]
fn[A] Promise::resolve(A) -> Self[A]
fn[A, B] Promise::then(Self[A], (A) -> Self[B] raise) -> Self[B]
fn[R] Promise::try_(async () -> R) -> Self[R]
async fn[T] Promise::unwrap(Self[T]) -> T
fn[T] Promise::withResolvers() -> Resolvers[T]

pub(all) struct Resolvers[T] {
  promise : Promise[T]
  resolve : (T) -> Unit
  reject : (Error) -> Unit
}

// Type aliases

// Traits
