// Generated using `moon info`, DON'T EDIT IT
package "mizchi/js/web/crypto"

import(
  "mizchi/js"
)

// Values
#alias(get_crypto)
fn getCrypto() -> Crypto

// Errors

// Types and methods
pub(all) struct Crypto {
  subtle : SubtleCrypto
}
#alias(get_random_values)
fn[T : @js.JsImpl] Crypto::getRandomValues(Self, T) -> T
#alias(random_uuid)
fn Crypto::randomUUID(Self) -> String
impl @js.JsImpl for Crypto

#external
pub type SubtleCrypto
fn SubtleCrypto::decrypt(Self, &@js.JsImpl, &@js.JsImpl, &@js.JsImpl) -> @js.Promise[@js.Js]
#alias(derive_bits)
fn SubtleCrypto::deriveBits(Self, &@js.JsImpl, &@js.JsImpl, Int) -> @js.Promise[@js.Js]
#alias(derive_key)
fn SubtleCrypto::deriveKey(Self, &@js.JsImpl, &@js.JsImpl, &@js.JsImpl, Bool, Array[String]) -> @js.Promise[@js.Js]
fn SubtleCrypto::digest(Self, String, &@js.JsImpl) -> @js.Promise[@js.Js]
fn SubtleCrypto::encrypt(Self, &@js.JsImpl, &@js.JsImpl, &@js.JsImpl) -> @js.Promise[@js.Js]
#alias(export_key)
fn SubtleCrypto::exportKey(Self, String, &@js.JsImpl) -> @js.Promise[@js.Js]
#alias(generate_key)
fn SubtleCrypto::generateKey(Self, &@js.JsImpl, Bool, Array[String]) -> @js.Promise[@js.Js]
#alias(import_key)
fn SubtleCrypto::importKey(Self, String, &@js.JsImpl, &@js.JsImpl, Bool, Array[String]) -> @js.Promise[@js.Js]
fn SubtleCrypto::sign(Self, &@js.JsImpl, &@js.JsImpl, &@js.JsImpl) -> @js.Promise[@js.Js]
#alias(unwrap_key)
fn SubtleCrypto::unwrapKey(Self, String, &@js.JsImpl, &@js.JsImpl, &@js.JsImpl, &@js.JsImpl, Bool, Array[String]) -> @js.Promise[@js.Js]
fn SubtleCrypto::verify(Self, &@js.JsImpl, &@js.JsImpl, &@js.JsImpl, &@js.JsImpl) -> @js.Promise[Bool]
#alias(wrap_key)
fn SubtleCrypto::wrapKey(Self, String, &@js.JsImpl, &@js.JsImpl, &@js.JsImpl) -> @js.Promise[@js.Js]
impl @js.JsImpl for SubtleCrypto

// Type aliases

// Traits

